{"docstore/metadata": {"b6163bdd-4e39-43ef-86a6-15094756ba59": {"doc_hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73"}, "4575fd29-4f6f-4ebb-a52d-3856fd5917b8": {"doc_hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe"}, "e2a50949-bd6b-49eb-ad31-dca516c89046": {"doc_hash": "78671b7d3f97b028a99701f244381b8caf3cfbbe9e2ecca38a094609f85f1a73"}, "5cf46890-de49-46f0-8f22-4bbb95a5e604": {"doc_hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e"}, "ecda3066-4bf3-4294-be8b-bedf56ca2c23": {"doc_hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567"}, "f91dce28-9d1b-41cd-98a6-8aee5b85070a": {"doc_hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490"}, "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74": {"doc_hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489"}, "391b810d-540a-40be-914e-9a31306607cf": {"doc_hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e"}, "9ebaed13-13c4-4fb1-958b-1d901b614163": {"doc_hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19"}, "9902006e-65e3-41c5-9933-ab84e016afd6": {"doc_hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e"}, "c9e863b1-6a1c-494c-8cd3-812888e067cc": {"doc_hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333"}, "6173c44e-5815-41db-b385-fe5d507dc819": {"doc_hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6"}, "a40c0a51-2e45-4364-b9a3-c79c8fbc8a47": {"doc_hash": "0a6d17498013aa34d5d597f5641e31e4aee030e68a4ab2bf65520c809cb419c0", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "80766a41-e2a3-4c03-aba2-d523a8ad09ae": {"doc_hash": "9cce2fbcf6ddd52b0d378beb7dec9afaf6b9786ee0c50e4475b0da651e1b3afb", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "006cdbdb-df73-4333-b390-a7ba4954faff": {"doc_hash": "570113f6bf7169b1b10da22fd809f94d2c0f3bc6772db95ea6c77a44c314036e", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "a6d42a8f-a17e-4eec-beb7-b6ad4b3f66db": {"doc_hash": "f81af7b582b9630d5419e132fd9997d03af0414e3aed482cb57f2d5ed55f18fd", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "1f16ebb0-0ca8-49af-867e-32fd92b0fc8a": {"doc_hash": "37c68e24aa327aab070d1a37d8055d3fa1f02fad39f15586ae404b403c236c90", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "a5829581-10a8-48bd-be21-dde8ffadb40b": {"doc_hash": "cabd1387559ee0235b96cf90d4c8d3429050c7e4e4232ccc3461808987464c02", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "b154dff4-4bc1-4385-84c0-cbc0f90bfbc0": {"doc_hash": "de4b144b58d1f82a8027ffec56aa7bcd9546a47858135cd5aadd037bb13fcd41", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "6a18421e-e48b-4279-97a2-ebf780eb72c8": {"doc_hash": "ea5ed3aa603d2dd4c0eab330db9ba1841096032346d10d61528d08063f8bcd60", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "25a9cfe9-20c5-40ba-ad06-cc933c95025a": {"doc_hash": "19b47e9f664730960c9ad394d5ade3cc3e4de93fec73f6aaa1cd4fb7890ba61e", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "30803c9b-9c54-4b53-b90b-ca2b3a5e9c2d": {"doc_hash": "1a8148866db2e30ede00b3eabb7a41d210e6c65cbcb0a87f4095a2c91acd55ef", "ref_doc_id": "b6163bdd-4e39-43ef-86a6-15094756ba59"}, "63ebeaac-b0f7-4b72-a69c-fb210fa15212": {"doc_hash": "d39810bc8952f6097a4eee703d4b829a6430633f5be0c1f518c28cc2b8316182", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "8159c0bd-a585-42aa-ac2f-f3f324912192": {"doc_hash": "03c74c6119b6649199e47f62fd98a4c54de3b17acac36c0474ff2c717eb40f9f", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "f5d90bdc-c464-49e6-8fb7-9d824732d34e": {"doc_hash": "a0e5268c0b9d4f06fbd2b92c4c5ba232f560dfe82211f5ddcaf375b5951cee3b", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "94d8ee8d-9b8e-4f52-b482-6023dc27b61d": {"doc_hash": "42436eb5c734702945b2a6b9a13bb0650525ac41023772a9f4f8c38ae7b50fad", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "923b54d2-d305-442b-8f3e-1820ea82f8a8": {"doc_hash": "19fbd67a6aa341e0f477a59ad39271d897b578fdf477e5bf66ce1945648eef88", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "02f93b3d-66b3-43ec-8048-e07b5c0f300e": {"doc_hash": "4f9b8bf1201e4cb968e1b73b56e7091e64e50e4ca1c126e5b1deb6a35df8285e", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "d63c0e15-8e81-441b-a158-15828f5c5390": {"doc_hash": "25a8f75aea97503becce3f44d39f80afb636461381ca4304e940443df7d05b73", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "44ec0e76-b94d-4476-9c71-d20bf2f5c630": {"doc_hash": "76e9c05a979eda9e970b1c52b888d7476da110c4ea7fa9701de9a7112b4fe071", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "28ce6eb2-7ab7-4012-9a2e-5c12261971a6": {"doc_hash": "6ee156728a95a8a45ed634f70f6d458413fd181a8dd809f1c73ecddb03aa81ec", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "11aeba91-6ace-4021-9712-0d30e5e0bc6a": {"doc_hash": "e6df39b2e7792aa2463587f51d01ed47d82e9f6ec547b395d42fc4b95f1ff15c", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "9f7b8cf4-f099-4eb6-a50d-61e15bcaed20": {"doc_hash": "63b3902fdd23a56600e18bba153eddd8b36e7490e1302f84828830fc033338c4", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "f40a06e5-8f43-4d66-a141-38534f4cf685": {"doc_hash": "d18ec2bba3700a72f9e17ae8a40bb930aaf0a0c94d22b4067606a23f9734416b", "ref_doc_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8"}, "3181be21-44b3-4baf-a463-5861511f3b7f": {"doc_hash": "4d4b08d68f43297d465ed332f75460a75c0bae6f0ba3c23e1e0a8f3bcc4a574f", "ref_doc_id": "e2a50949-bd6b-49eb-ad31-dca516c89046"}, "e3ec9b3c-278e-4781-b3df-3feef2bcce93": {"doc_hash": "5d2cedd59f0478dfaf27e782d44d73630e1705f848b328fa83da8a85e92a3521", "ref_doc_id": "e2a50949-bd6b-49eb-ad31-dca516c89046"}, "027924a9-8986-41d6-96a0-0533e7e8c7d6": {"doc_hash": "acbecae4c99175cd4ca2340be7e6a29ef2fdda977eda6167f83f0d2e858848cf", "ref_doc_id": "e2a50949-bd6b-49eb-ad31-dca516c89046"}, "79eca348-b85d-4ce6-8ce8-8af995e215e4": {"doc_hash": "0c1b43f0abf4de6651ad45c7d0a7dd67d8dab581389e87b7363434b3590fd480", "ref_doc_id": "e2a50949-bd6b-49eb-ad31-dca516c89046"}, "f10d9399-371d-4045-a8d3-69a49aeb1b0f": {"doc_hash": "f39d6a61402445a19cb3413f76783aa93ba940d2b3a3087e5df94f2472fb91da", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "26557338-1e28-47a7-8131-3b83b3b9374c": {"doc_hash": "199a62645dd1caf1a02510f0d3a2e696b77ca1e894907abde1ef5ee1077d37e0", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "a4525e03-035c-42c5-a2a9-990b62bebedc": {"doc_hash": "3d12001c8b4fb4e3cd1e01eb5dbf4123eda4e9b495084aa88f2a11f51f25ac12", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "29e21863-a00b-4ab9-8a6f-af491974a70b": {"doc_hash": "cfcf2253ae6e6d2179fbb9f650ba6f9676dba34e1921f9a93e2a0e2afe9224a4", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "f7d130bf-7c4b-42f8-b8b5-c6fe0cb6446e": {"doc_hash": "005db225e0bd087368009ce39661c19623a11ebd325f990212e39f4a0fadf425", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "678b9544-a096-484f-8951-42aeba1888da": {"doc_hash": "195540b0863dafb89dcf1a88cc0f713c7360c372cdf4502fc61e1d3b23dd13da", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "72f79cfd-419b-4797-8639-d6996e653bb1": {"doc_hash": "25e4e0afd9465f1e6c778d2e35ff8c8913fbb3782fc6c4b524d573c0b0187fab", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "23e6fd71-cdce-4692-abcc-b6aed1f211fc": {"doc_hash": "861356d62cc1f7aa4391f7e8f01288b05bce14515dc087b0d445aefaa681a91c", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "88ffe720-91ce-41b8-9c24-2d80123ae8c7": {"doc_hash": "96a8b7ea3abc70e8fb70166ac7aee47fc5bcb82281919a5f3f6f4f6af857f649", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "00e18875-47bd-4eb7-bfcf-f456519fb6e4": {"doc_hash": "a6a9313f75bf73ef2231dd1ba3698b4aaa78690181b4b0052af731cf8be48a1e", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "550bb27f-78dc-45a7-829d-f1cf21831dda": {"doc_hash": "36c8856c643e34f45fba93c471f578754bef6e9ede65fdcc347405cc05122179", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "d137bc9b-2ad3-4420-b6f8-e9e545a5299f": {"doc_hash": "eeb2dbe78ea35b6425c008122cb77707d4001c5e4116a5b0b0e2622d57507735", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "73024c29-f129-4631-bf9f-de3b16681178": {"doc_hash": "b9c089b145c37b27140acf1bd1c992fbc029d12ba02909403f516cb7947092fa", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "f092208e-9812-4910-8693-793b259505a5": {"doc_hash": "e5d6c4bdec5e5feb0d1659ac085ecbec48ac1192a1401988221e25e71b7ffb2d", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "17100df4-e384-4536-ae14-0232c2e8f3d3": {"doc_hash": "659c5d3d1b27c80c54a8188b26479f86372eb46416cfb35caadb67256492f51a", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "f30d9b5f-a1e2-468b-b7e6-c98b239afd1f": {"doc_hash": "3e43dceb6b652cb2f604d704eaa161429f1d6474f54254cf449c6c9ab14b24e8", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "0998b92a-3ee6-4e15-af08-b7c3970e497f": {"doc_hash": "e7aaf3e241e46080de3aeb01ce5957546d89841aedb346288ebb7adb24c8b424", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "5ce26c8f-6c5d-48a1-9077-28e6ca23ef0d": {"doc_hash": "eab9765f3ff9908faf86dd3ee26a1dcb4167c5afa9b805ee798654e2bfed8be3", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "12f99cdb-0691-4192-bb22-92ae465ae961": {"doc_hash": "da4781684ccfa4747e8793c935d5ca6268e6b6c1d227c688240b8f403d2fc578", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "db44c17f-c453-4a12-a419-49aa13d01182": {"doc_hash": "b93841b8c7646097e042952a3254cb25bf90cad2c48209dd6971e0d96b30c49c", "ref_doc_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604"}, "2b614eb8-8b85-459d-a695-93c185d8be3e": {"doc_hash": "3847938937354ec22f2ee3fd269676ff7cd98d449fd09d16802ff3e6b3d5af54", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "c82cb3b9-f60b-42db-be19-0fd6da899349": {"doc_hash": "69a64a2e4c72411e3cc008654af46c5b6113e32a07e9564cd0ba0d3610a2db42", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "c80c69e2-3787-4796-9ff6-2acb10c37ffe": {"doc_hash": "fa2553e725d61349a2082ad7822d35ec9bf62c9f97fbd9bdd6b834b25318e1e1", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "8f50ef58-085e-4436-bd24-9be02ece8b4b": {"doc_hash": "55902afaadcd25190f03282fd3d65ce5939e930c04b470b22aae9f9beb324b9a", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "4ec898ac-395c-4b74-81e4-f926ff34c54b": {"doc_hash": "c889e40153548448d3d969c6634b4ff37d6f4cd9779aaa6a3798722686be3a18", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "0a4255e7-23db-4987-820c-371332918189": {"doc_hash": "9f0b1a45685e4841bc9625b7341c092561afbd7ccc9835521f747b2ca6657cd4", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "0e85cb49-a08b-46b9-b012-2e924a8f12d5": {"doc_hash": "b5954308711ede4349f1f83a13b46c2fc265980b7e61a3196d2e38567ca78889", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "cc2de2f8-7ff1-4d6d-a5f9-2ab6936db26f": {"doc_hash": "4e0b1f334d3b5ff860da7d0b08e463393ecc3ca438c5ace41b8e5e116b857d13", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "d6084fad-9b5c-468b-8565-5741b46fcf80": {"doc_hash": "2c87332f15c873a142930970bc8777d69d61d28176d90df52039b73beddd6e53", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "c5d9a2c3-7718-4f58-a6a1-ac87db47bf1f": {"doc_hash": "5b26948de106bd6f7a767271f31c7098a241bafe5934d2e17b9437400d90c333", "ref_doc_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23"}, "da57b87f-aeb6-4ec2-9b07-333d63cc63f6": {"doc_hash": "26678ade94b2844d2af8e92a78fab2dd63d5437e3b4c607fb3f0af1369055554", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "34b24aa1-1182-493e-abb8-b9ecd31a0ea1": {"doc_hash": "79e6836b1eb8e08e3c715d9d65f81933f2656cf89597c50fed6425e6ac24b6ac", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "f1eca6a0-2634-4dab-ad7d-4666d9adf0a4": {"doc_hash": "c2b159a7ec6e435575b0c67b7b75a825daafeb02e8c7c44d6611f3cc720f6fae", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "ba090a84-1424-46ce-a9b9-12ce64cb5bbe": {"doc_hash": "b0cf0fbf61357b21d4db3560b50102c7c5e2d533f24e872bb33bb762ed978d0a", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "63ccce18-eac9-463d-bdff-3b2326e61c31": {"doc_hash": "aac0ec80043ddf54a6758a5d30d82c6fd144d59284703e9186d5dd002b89152d", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "0a89c82e-e0d6-459e-9155-1be2b62f1f9d": {"doc_hash": "85356600981759ad462211d791b8a049f3f252b21cc92022d9f1633e24bd54eb", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "5608d51c-72c4-4783-968c-827c9fff8828": {"doc_hash": "b97fc83672a1e53677a1af99c0b86fe640658c9d60201dd4021143875d722e09", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "cdd33744-b8d7-4a84-a363-ea73aca9be2e": {"doc_hash": "3f57526b2e98d645bf9b9799af910f871604906a26a6179d315b495f4a390675", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "db1f6153-a92e-4ef3-9838-673493bd84cb": {"doc_hash": "44b5fc7d6703b6356cc5389a39d81478e517a0492ac35fbbe7b80678fae834c7", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "8fa1043e-3974-43a4-9fd8-f11c79b56262": {"doc_hash": "f46c75e0a8fc67eb560df47b1403b03c9b00ed969d2f0944d329ea6869ec7f7e", "ref_doc_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a"}, "86261f56-8db9-443b-9712-026895ffacb5": {"doc_hash": "5eca313df995193914d520e6945f4e166eab8306aa28ff01083f00e1c465d664", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "5274178b-3b60-4127-bbe7-dc3f26fdf4f4": {"doc_hash": "a81ffbae52379170e9a8063900ee97a3a8adc30f13c7abb06b1d37573187bece", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "56bc4c0b-d617-40f4-8448-daf36bfd4a5e": {"doc_hash": "63cf14b6c278f9a8f55134f8896ade9e37d9e93438bd43b54138e2d8c70413d8", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "aaf593b5-2f7d-4b62-a146-4d8d2a131b53": {"doc_hash": "3ac3a347d0c0c641617ab2a4f815596d66c9b8bf369b9290e75062940cbcff6f", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "36b98408-ac01-4be5-be06-b75aa79c836f": {"doc_hash": "3e10779942a7f7fbec6b4036911e8788b3848268d3168a6626d808825041968b", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "b190dff2-bf42-49cd-b8b7-9bb16fcfb102": {"doc_hash": "998371a83d67bcc86b74bb3f8c16aa751590f5bcd69b2392e46e55675154d899", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "3dff4fff-749e-41ea-9cf0-8b212c543856": {"doc_hash": "fc1fd49c3ad1835ee02f67248126b51dad83354b087970fb66630b32aacf98e6", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "eaaec151-1d0f-4f66-bfef-f9439f8be60b": {"doc_hash": "6a0ea099b5133bf2454f66bc4f1888791feb117ce83d7ea0150c160fd1249abb", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "dd4ce108-ec97-4048-8773-aea24d74b060": {"doc_hash": "7ceb079af425d6dd49ba0726a2060c289cae43494b8f01eb469e3a2be706d20b", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "ed00e8d4-7f7a-478c-aa80-352b4ea4b076": {"doc_hash": "4d1842b77cf5e60600f5d998d0c20d5437bad7bdf7c7bf414558e0b8eac05d7f", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "b8941e0b-ef8c-4a4d-b6b2-18211a941b7c": {"doc_hash": "662a00c5b3a1156f6442a19a278190c3d34ac63785eb2e6afaacf36404a0c248", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "538ba89e-6235-46f3-abad-c0b2fb78697a": {"doc_hash": "efc37690201c91331336414cc9947840a1893583181a49a2af209281f959432d", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "e317f44e-ef91-4fbd-aeba-6f435d81be6f": {"doc_hash": "1f0e7829729f3719bb7d1858a94224c8c704b0d4161d58d067621976564412a2", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "fb231ae5-71cb-4f0b-895c-7b8ddc5b269e": {"doc_hash": "e1326f0a62e0bae415de83345569e6741989d9b913bd03ea01a89437bb90e49d", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "c8edfb4f-dc0f-460e-a66d-f679b60a038c": {"doc_hash": "016b7dee60c7daa32d06c689adba5ef86edc4e8f1b42ae21c47fdadebcc2b05d", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "e2e496b9-c670-468f-b11c-4669d3d280e1": {"doc_hash": "39e2fc7777a4d690e9f3c8dd8203237f34ee748320ad700aa6d2c7406a7cac52", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "fff063f9-a903-43f8-b895-68f1d9909030": {"doc_hash": "29909c4a91ac13424153dde7f27b6b767af5f75ed15e740919b5acd292eb0a53", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "c5688728-04e5-4639-b4e5-4cf7a1b818e6": {"doc_hash": "e30ab161914405093be179d515bd3780e8481db5255d30a79567e8f6949b6526", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "27dd9c46-7b87-42ff-9ebe-c3553d1b8f57": {"doc_hash": "051b8ae13a5254fb36f9675279d830796137f023af5a4c9c3edfbd49b6c82017", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "3f4bc013-e0f3-4f82-9eed-699ddcf0b96d": {"doc_hash": "31afe359ce44d52d0edca09e8b504e9e4dc3d29e9f2cd88be17e425246c1f0fb", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "99d64770-9a8c-4e62-9d51-c6f13e3bac50": {"doc_hash": "a14c3d05b3f1faa3c649c54285cd9bf2d8ac24d5125582f0ac3c351d4ccf557b", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "057b7ebb-3d9a-40f5-8cfd-5c58336cfba3": {"doc_hash": "6bc118904f7af2de1f3ca9178b7e271ce0eb11f80be50594f5564bf05a1498d8", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "88e76fd9-49d8-455b-a97a-d4a118f89b17": {"doc_hash": "ef08251c2a580a18d585aa233d477f93ba7f358de3c101b23c1428f16c280d2d", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "ce45ddd1-6ad8-473d-9854-cbcbbd5cf819": {"doc_hash": "7e7b8b1a57ed4c08311c2550c7aca995c322ca847b0cb43bdd3a5655049ebd87", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "d895da4a-0700-4d40-b739-4de1757e446a": {"doc_hash": "abae58efd0408edec86de451f9c4493cf22a5b91d782c15cb90621f0b310ee44", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "f07308ea-b65f-41eb-a5a8-d2fad64f33be": {"doc_hash": "971e95e53162bccdcd928d32daab42d091c405de004f8ff087177818787bd5b6", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "e5fe8c28-7b66-447e-ab5b-fe35687b372b": {"doc_hash": "ac4856ba5ff5f782737acab54450431003e127a42181740f3c278b9ec6c06bf0", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "ae64c893-8820-4906-b899-00284645a751": {"doc_hash": "800a73ba868cd1c671d072abe2d926b988962517a94118234ad41227e19a1bf3", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "81a96d25-465a-4671-9601-a2a124466295": {"doc_hash": "06a029e19929f05294accba12b03c2be8b7264ad47a8a16a896ed61107954e6a", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "ef7e1911-8a48-4fa5-b0da-d67bf3c4929b": {"doc_hash": "eb013f20380ad8db9f6319a82fd99b23590e4e22841b423d8213bf8f576954e2", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "50e96c4b-0f82-4d4c-9534-9bff8be68473": {"doc_hash": "7dbb3abec68d686345e49e483d73c218eac1bb20d5f4db57fe7751fbc0403a73", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "0a55eedc-829f-46cd-b416-bd569cdf306f": {"doc_hash": "539ca43124560495551dfaa999b86e515bf01c18ad19d315340ceefef5ecfa4a", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "db8faae0-3523-4ffb-89da-a4ccdfa8bdfc": {"doc_hash": "28152246ded26589ce7a599bb543b4cad82e47989530dbf1b1c16da54e63d47b", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "29b165c2-183c-4807-92d0-49b9e848e72d": {"doc_hash": "b170b26d6fc5cdcccbfc91aec4aea2b4fb478ce46828626d6463b148d6d6c1a1", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "6bb88a23-fc78-439c-aec5-7d03bfae2563": {"doc_hash": "b3f2b73aa7dffb5682ad7cae3ad14171c464cf062fc141426d3cffe0286756fa", "ref_doc_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74"}, "b627187c-2e8c-43cd-bd20-9176bd46ceaf": {"doc_hash": "a23c5d3c41fc0b321bbfa83a1cc630e118176ef1ccd52fa845acaac3e534ff85", "ref_doc_id": "391b810d-540a-40be-914e-9a31306607cf"}, "300430d5-652e-43b5-8bbb-de8a4445d3d3": {"doc_hash": "fe40cd783a14dc288ffb8717a764221959ef724ecb40343b3c3f1a3fca2613ef", "ref_doc_id": "391b810d-540a-40be-914e-9a31306607cf"}, "8e01e8d9-e932-4881-ae80-34c221ecab3b": {"doc_hash": "d8afef300c789a5fc9ece22feca9bc1aa311223ae887ff02cc6912a62039c5e7", "ref_doc_id": "391b810d-540a-40be-914e-9a31306607cf"}, "0c60307c-59f8-47be-8d55-ac3a11d55743": {"doc_hash": "2b4674b8850440a560dc292f7ad8862621651bf752452544d480609ee0d5190f", "ref_doc_id": "391b810d-540a-40be-914e-9a31306607cf"}, "bd5723d0-7e3b-4025-82b0-715571310a83": {"doc_hash": "a7e40029e36731f0ee1ca8833953d22734f4c632e33b7651c2d777b8e4de7382", "ref_doc_id": "391b810d-540a-40be-914e-9a31306607cf"}, "5a2fcac5-4080-4970-a51e-c353607580fa": {"doc_hash": "f8c8c18ec12eb9c8d5a8cbd3810ac2aa80d55c817ac35b9dc7a3379dc86fa3bf", "ref_doc_id": "391b810d-540a-40be-914e-9a31306607cf"}, "055df13a-4c8a-45ce-afc0-b417230667e8": {"doc_hash": "0c9d0d896c107dc5825555320006ca53f3c5383e9e5ae09dfc17bbc1eff3b792", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "60e7ace1-cc7b-4fe4-a05d-3a0c569afcbb": {"doc_hash": "bef045a6cdd3595f7753578d904ad656cbd7c1c897162efff8537a6d16695611", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "fe6ca578-7fd8-41f0-bc39-64840459f5a8": {"doc_hash": "d737edd9cbd852e2332542faf29e00772b5ff8cd799aa584734b394186de50c7", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "8daed4df-7a98-4bd4-8eb4-a07adddb3220": {"doc_hash": "166596f0da9b5fc812c5559a24b4616554b30a86009c4cfd52408fa9a3b7b9bc", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "0e512a84-524e-4377-8b16-b352890f4a7d": {"doc_hash": "97b88f2f4cda298c5db0fa6e9b386f41bb1ea8675cd7296c9eb77fbf262da136", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "49b5fa49-f2b2-4eaf-9fa4-9b87e954f9ce": {"doc_hash": "4ac852eb51ca23f2310452c20fe6e1de34004264fbe002c753fbf5618743a1b7", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "be50dd89-e34a-4108-b84d-7b30aece13c0": {"doc_hash": "7000b5535fe981d4ec6dc35020a0b75c32ff42be8d5e520c0405227ab5e274ab", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "99104018-0577-4ea3-ac2d-7c3ee66b79b4": {"doc_hash": "5c928e768dd36d38684279a5d0151f80d0003bdac7251a729d26b5962a2b661f", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "b6147262-ba42-491e-b599-af12aa780687": {"doc_hash": "78b85fe23354caf1027c701d7968acc66cdfd2c74d1d3a7664da52aedf779740", "ref_doc_id": "9ebaed13-13c4-4fb1-958b-1d901b614163"}, "3da069da-4613-4ffa-b703-a6e611c72c9e": {"doc_hash": "c4a22cbd4514671d66fab6dda2216c55c0ab79e95bf6412e38295c49720b6e17", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "a5f3732d-3457-4b62-9ed8-18ddf5d5fcf7": {"doc_hash": "8e26027b1dab13076025a16cc2d9b98f0007a5bd86992415d493a00d416d621a", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "c529181b-c8f6-480a-b65e-8bd66de70ef9": {"doc_hash": "aa3bea55a53f7f7bd3f9d0210beeb9feee941748ddade2db90ef6af1cf9aab8a", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "954bee3a-ec11-47ca-8dce-3057004fea06": {"doc_hash": "5b8d16d28c55d214f1ecb0a89b7fd73b944ca1be5a45dbb89548871f73f949a4", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "27bc06fe-ded1-4ef7-89c8-55d66245f95c": {"doc_hash": "1ad5205b9baa5dd974cc2d6bd59f8cf2768c3425d08fa59fde7e10bd3940642a", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "187f38e1-9bf5-4254-b197-7bb86c0cdba9": {"doc_hash": "387319c62f86a88d5c23e6e9606109a24d01c628943330787711acd32d93b71a", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "fb18bdda-d33f-464a-af39-b408f6e16c41": {"doc_hash": "785aaff2c63fa7a9018fce5f579632a4abc48247f4953e0673e0870749ed8121", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "6086d7f6-2bb7-4741-aa32-e8bfedf1aeac": {"doc_hash": "c504aee02eecb5c00b9dc86c6b701e88eb368ea41aa74c43d9d8eb32052bb4e9", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "c7384d99-8130-4d7b-97f2-75dd0c6b45af": {"doc_hash": "c4132df18eaa70d3c87b5cf674c5cb8586f9c823e9734671d2824efa669582d5", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "66302d08-b2cb-492d-a660-6e301e33569e": {"doc_hash": "134d9a5c4be7963bc78fc73febaf09b2b6dfe36eba9931cc439323eb2eb55230", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "b2f54f3b-bd03-49af-a426-4eb16339e99d": {"doc_hash": "2d773514fbc5cc4bd3e52ca0bbedb03d0364c7600426a08f1e4f8b419349acdb", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "ad2e5552-8e36-47d7-8686-c8d4f41a70fc": {"doc_hash": "2859333689d62e75a7884312ad3028d5914fb5fef22888ab8a1ba7d417402792", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "d4e696ef-06d2-4283-a467-9e5786e5b7a7": {"doc_hash": "04b92d1e1be4a5b14255b4c1ed08aa9c24c7d5808a82df484a621636e10a9156", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "ca5925ba-f690-4092-a934-603344c8ebab": {"doc_hash": "6231a767ebf5de76478cf852e426145c1910205826046bfdba4433057bfc17fa", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "30c44384-3643-4d52-ab9f-59140664db99": {"doc_hash": "575cb4c8e9a12c370fe0dc2888352c6a873167724674fde29f7cf396785d6a28", "ref_doc_id": "9902006e-65e3-41c5-9933-ab84e016afd6"}, "d1492e08-6161-49cd-94b1-551aa42e75c9": {"doc_hash": "d26fecb9d65172906b032bec268ba4448e2b561a489af6c56af19ef58e8390af", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "b939572a-9ca0-450a-a0e5-c2cd904da8a4": {"doc_hash": "41c11939ff686dc517b9ff5644ce5ed833da2a3652227b82e1b7d6f4e8178fb5", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "6662634b-449a-4f2a-a389-cf2112dfb8ad": {"doc_hash": "06f6bc1a0767ba0e280bfd565c363de33aa6d8c03d56d719e855ffeb70b79b73", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "15559778-461f-4d10-b7f4-517d286b4384": {"doc_hash": "136d2d30cdb6978344213d660c45bb6cd87c9a6cca476b073d5c238becaa4ccb", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "54aaf650-63de-4e82-a5ac-995f4bb6d0ef": {"doc_hash": "219ad2bce13af8f7c78c326c3ce2d26429f0c14b7ebda73880642ac0a42f040f", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "4e7b27c1-9a4e-47e9-a000-acf365fe20b9": {"doc_hash": "f8e5e8673bf4ead1eee6a2f61c33b1b04bb0d9c144f53ee101c6c4f37c09c454", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "dcb8b949-a400-4033-a6cc-153076c4edf0": {"doc_hash": "338d8933c651063ec45539521a446c82ea22283988b614b20ebf71c8429b1b63", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "416032bc-6ec5-40f4-bcbc-c0dabef88a69": {"doc_hash": "1508a658b0ae77f246c4785099f0cb3f1c196e77d87abb16649267f0e425c575", "ref_doc_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc"}, "0b6ffb33-51dd-4ad6-bfc4-f17c019683e1": {"doc_hash": "d564df657bb78c89fddb93b7b5be39d3d13a75e3b29f34d981bededdb816ae82", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "a567e4f6-51d8-4c76-bbde-14c6fc05f458": {"doc_hash": "e08f75f59d8645e6987aeb0e0e476d8df1373fdce731c3a2038fdd6b3ad00a2e", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "caf5be9f-4350-4e36-995f-120abe976a4e": {"doc_hash": "c0fa56332df91ae6a7ab364f2009a6350440f84fb4a114b30dd72b8a62403288", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "5d4b4a1d-cbeb-4a7b-8430-c0a6368cdd16": {"doc_hash": "531e919f662b99ceae8490630edceffdb1ed0264165624531b9ab04cc3367fff", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "17f86ef6-2bd5-4f38-93ca-ca669c2829f9": {"doc_hash": "d874bc33969f98b01775c002864bc285c0ebb93126798e764288453c180f2386", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "e81fcac5-a6d4-4985-97d9-1459bfc32744": {"doc_hash": "a4325e74abf07d319ffda387a6b4de058d1893f1d296e1f55a3338f47a66578f", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "a330f51c-e3ec-4f04-97c9-3ea61db49426": {"doc_hash": "ca64c5d5d7d0a92a26259dcfaa856c3f29b7a0a41a1e0565ed7d8726ac7abbfd", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "03a8645c-1bd3-4632-ac9f-4434b4085650": {"doc_hash": "f8ceb09fa5eccf2fe2430d0aca1c1b9805dde37ef846a419b277831b28df35cd", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "5bf06c3a-a7ab-473d-9240-2869a15683e4": {"doc_hash": "2d4c3b5197984122241ccf1d32a4a4d8cf7d69be8c54e26d563c3b4fcb0c6ff4", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "c175c9d7-39bd-4026-be64-f5d0df600644": {"doc_hash": "59438939ac0a0fc639fa4e84b788053062f016ab64d3b0c8015acf37fa8337eb", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "9fadeb1c-2cd8-4032-92cd-920248b9963c": {"doc_hash": "396f296c4dfec3aaf9a03cdd6b4cbf4ce4725532a7887f2c64365916302a4b3c", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "bd41bf3c-92fe-486b-805b-8ad55c07c0b0": {"doc_hash": "80cd8e2fdfeca7fa7fa6ecc91e7010dc52f4713bd56e7f8986700f3d719f7234", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "f65a3ad9-149c-49a6-87a6-afdf5f457f30": {"doc_hash": "a7b45a38abe451356d518b5456d3c650e43227b9d95505d739a2e4f4b208fa85", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "fcb627f0-507c-4f6a-a239-cc5cece49878": {"doc_hash": "4c57d67adf66be787f158184dacc69afd403b4df03913ac3b123944dcfa3fe07", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "87d70abd-3c01-4749-b1ae-93729ddd947a": {"doc_hash": "8ec622ab5d3447a00b868782582bc4512d85655eb86b5229483a2b65b0a404b1", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "25241697-315f-48f4-8ef7-974f2abd50e3": {"doc_hash": "9283eacdd50a90d68adc95978e349eaa63e582241d2053abc3800688b1e267fb", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "f9545f6b-fade-42f7-a843-82e04cbcbe68": {"doc_hash": "a9a011e26f027e4d26bfbdeaba96325d8d8dec334d30a22fe64cb314618fef64", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}, "4ef0ab90-5a91-48ff-91bf-72a3e6f1ca9f": {"doc_hash": "cd444e03b2f8a1e0a399272fa0b616828d8c6ce0eeebe5d645f6e5d1fabf5aa7", "ref_doc_id": "6173c44e-5815-41db-b385-fe5d507dc819"}}, "docstore/ref_doc_info": {"b6163bdd-4e39-43ef-86a6-15094756ba59": {"node_ids": ["a40c0a51-2e45-4364-b9a3-c79c8fbc8a47", "80766a41-e2a3-4c03-aba2-d523a8ad09ae", "006cdbdb-df73-4333-b390-a7ba4954faff", "a6d42a8f-a17e-4eec-beb7-b6ad4b3f66db", "1f16ebb0-0ca8-49af-867e-32fd92b0fc8a", "a5829581-10a8-48bd-be21-dde8ffadb40b", "b154dff4-4bc1-4385-84c0-cbc0f90bfbc0", "6a18421e-e48b-4279-97a2-ebf780eb72c8", "25a9cfe9-20c5-40ba-ad06-cc933c95025a", "30803c9b-9c54-4b53-b90b-ca2b3a5e9c2d"], "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}}, "4575fd29-4f6f-4ebb-a52d-3856fd5917b8": {"node_ids": ["63ebeaac-b0f7-4b72-a69c-fb210fa15212", "8159c0bd-a585-42aa-ac2f-f3f324912192", "f5d90bdc-c464-49e6-8fb7-9d824732d34e", "94d8ee8d-9b8e-4f52-b482-6023dc27b61d", "923b54d2-d305-442b-8f3e-1820ea82f8a8", "02f93b3d-66b3-43ec-8048-e07b5c0f300e", "d63c0e15-8e81-441b-a158-15828f5c5390", "44ec0e76-b94d-4476-9c71-d20bf2f5c630", "28ce6eb2-7ab7-4012-9a2e-5c12261971a6", "11aeba91-6ace-4021-9712-0d30e5e0bc6a", "9f7b8cf4-f099-4eb6-a50d-61e15bcaed20", "f40a06e5-8f43-4d66-a141-38534f4cf685"], "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}}, "e2a50949-bd6b-49eb-ad31-dca516c89046": {"node_ids": ["3181be21-44b3-4baf-a463-5861511f3b7f", "e3ec9b3c-278e-4781-b3df-3feef2bcce93", "027924a9-8986-41d6-96a0-0533e7e8c7d6", "79eca348-b85d-4ce6-8ce8-8af995e215e4"], "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}}, "5cf46890-de49-46f0-8f22-4bbb95a5e604": {"node_ids": ["f10d9399-371d-4045-a8d3-69a49aeb1b0f", "26557338-1e28-47a7-8131-3b83b3b9374c", "a4525e03-035c-42c5-a2a9-990b62bebedc", "29e21863-a00b-4ab9-8a6f-af491974a70b", "f7d130bf-7c4b-42f8-b8b5-c6fe0cb6446e", "678b9544-a096-484f-8951-42aeba1888da", "72f79cfd-419b-4797-8639-d6996e653bb1", "23e6fd71-cdce-4692-abcc-b6aed1f211fc", "88ffe720-91ce-41b8-9c24-2d80123ae8c7", "00e18875-47bd-4eb7-bfcf-f456519fb6e4", "550bb27f-78dc-45a7-829d-f1cf21831dda", "d137bc9b-2ad3-4420-b6f8-e9e545a5299f", "73024c29-f129-4631-bf9f-de3b16681178", "f092208e-9812-4910-8693-793b259505a5", "17100df4-e384-4536-ae14-0232c2e8f3d3", "f30d9b5f-a1e2-468b-b7e6-c98b239afd1f", "0998b92a-3ee6-4e15-af08-b7c3970e497f", "5ce26c8f-6c5d-48a1-9077-28e6ca23ef0d", "12f99cdb-0691-4192-bb22-92ae465ae961", "db44c17f-c453-4a12-a419-49aa13d01182"], "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}}, "ecda3066-4bf3-4294-be8b-bedf56ca2c23": {"node_ids": ["2b614eb8-8b85-459d-a695-93c185d8be3e", "c82cb3b9-f60b-42db-be19-0fd6da899349", "c80c69e2-3787-4796-9ff6-2acb10c37ffe", "8f50ef58-085e-4436-bd24-9be02ece8b4b", "4ec898ac-395c-4b74-81e4-f926ff34c54b", "0a4255e7-23db-4987-820c-371332918189", "0e85cb49-a08b-46b9-b012-2e924a8f12d5", "cc2de2f8-7ff1-4d6d-a5f9-2ab6936db26f", "d6084fad-9b5c-468b-8565-5741b46fcf80", "c5d9a2c3-7718-4f58-a6a1-ac87db47bf1f"], "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}}, "f91dce28-9d1b-41cd-98a6-8aee5b85070a": {"node_ids": ["da57b87f-aeb6-4ec2-9b07-333d63cc63f6", "34b24aa1-1182-493e-abb8-b9ecd31a0ea1", "f1eca6a0-2634-4dab-ad7d-4666d9adf0a4", "ba090a84-1424-46ce-a9b9-12ce64cb5bbe", "63ccce18-eac9-463d-bdff-3b2326e61c31", "0a89c82e-e0d6-459e-9155-1be2b62f1f9d", "5608d51c-72c4-4783-968c-827c9fff8828", "cdd33744-b8d7-4a84-a363-ea73aca9be2e", "db1f6153-a92e-4ef3-9838-673493bd84cb", "8fa1043e-3974-43a4-9fd8-f11c79b56262"], "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}}, "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74": {"node_ids": ["86261f56-8db9-443b-9712-026895ffacb5", "5274178b-3b60-4127-bbe7-dc3f26fdf4f4", "56bc4c0b-d617-40f4-8448-daf36bfd4a5e", "aaf593b5-2f7d-4b62-a146-4d8d2a131b53", "36b98408-ac01-4be5-be06-b75aa79c836f", "b190dff2-bf42-49cd-b8b7-9bb16fcfb102", "3dff4fff-749e-41ea-9cf0-8b212c543856", "eaaec151-1d0f-4f66-bfef-f9439f8be60b", "dd4ce108-ec97-4048-8773-aea24d74b060", "ed00e8d4-7f7a-478c-aa80-352b4ea4b076", "b8941e0b-ef8c-4a4d-b6b2-18211a941b7c", "538ba89e-6235-46f3-abad-c0b2fb78697a", "e317f44e-ef91-4fbd-aeba-6f435d81be6f", "fb231ae5-71cb-4f0b-895c-7b8ddc5b269e", "c8edfb4f-dc0f-460e-a66d-f679b60a038c", "e2e496b9-c670-468f-b11c-4669d3d280e1", "fff063f9-a903-43f8-b895-68f1d9909030", "c5688728-04e5-4639-b4e5-4cf7a1b818e6", "27dd9c46-7b87-42ff-9ebe-c3553d1b8f57", "3f4bc013-e0f3-4f82-9eed-699ddcf0b96d", "99d64770-9a8c-4e62-9d51-c6f13e3bac50", "057b7ebb-3d9a-40f5-8cfd-5c58336cfba3", "88e76fd9-49d8-455b-a97a-d4a118f89b17", "ce45ddd1-6ad8-473d-9854-cbcbbd5cf819", "d895da4a-0700-4d40-b739-4de1757e446a", "f07308ea-b65f-41eb-a5a8-d2fad64f33be", "e5fe8c28-7b66-447e-ab5b-fe35687b372b", "ae64c893-8820-4906-b899-00284645a751", "81a96d25-465a-4671-9601-a2a124466295", "ef7e1911-8a48-4fa5-b0da-d67bf3c4929b", "50e96c4b-0f82-4d4c-9534-9bff8be68473", "0a55eedc-829f-46cd-b416-bd569cdf306f", "db8faae0-3523-4ffb-89da-a4ccdfa8bdfc", "29b165c2-183c-4807-92d0-49b9e848e72d", "6bb88a23-fc78-439c-aec5-7d03bfae2563"], "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}}, "391b810d-540a-40be-914e-9a31306607cf": {"node_ids": ["b627187c-2e8c-43cd-bd20-9176bd46ceaf", "300430d5-652e-43b5-8bbb-de8a4445d3d3", "8e01e8d9-e932-4881-ae80-34c221ecab3b", "0c60307c-59f8-47be-8d55-ac3a11d55743", "bd5723d0-7e3b-4025-82b0-715571310a83", "5a2fcac5-4080-4970-a51e-c353607580fa"], "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}}, "9ebaed13-13c4-4fb1-958b-1d901b614163": {"node_ids": ["055df13a-4c8a-45ce-afc0-b417230667e8", "60e7ace1-cc7b-4fe4-a05d-3a0c569afcbb", "fe6ca578-7fd8-41f0-bc39-64840459f5a8", "8daed4df-7a98-4bd4-8eb4-a07adddb3220", "0e512a84-524e-4377-8b16-b352890f4a7d", "49b5fa49-f2b2-4eaf-9fa4-9b87e954f9ce", "be50dd89-e34a-4108-b84d-7b30aece13c0", "99104018-0577-4ea3-ac2d-7c3ee66b79b4", "b6147262-ba42-491e-b599-af12aa780687"], "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}}, "9902006e-65e3-41c5-9933-ab84e016afd6": {"node_ids": ["3da069da-4613-4ffa-b703-a6e611c72c9e", "a5f3732d-3457-4b62-9ed8-18ddf5d5fcf7", "c529181b-c8f6-480a-b65e-8bd66de70ef9", "954bee3a-ec11-47ca-8dce-3057004fea06", "27bc06fe-ded1-4ef7-89c8-55d66245f95c", "187f38e1-9bf5-4254-b197-7bb86c0cdba9", "fb18bdda-d33f-464a-af39-b408f6e16c41", "6086d7f6-2bb7-4741-aa32-e8bfedf1aeac", "c7384d99-8130-4d7b-97f2-75dd0c6b45af", "66302d08-b2cb-492d-a660-6e301e33569e", "b2f54f3b-bd03-49af-a426-4eb16339e99d", "ad2e5552-8e36-47d7-8686-c8d4f41a70fc", "d4e696ef-06d2-4283-a467-9e5786e5b7a7", "ca5925ba-f690-4092-a934-603344c8ebab", "30c44384-3643-4d52-ab9f-59140664db99"], "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}}, "c9e863b1-6a1c-494c-8cd3-812888e067cc": {"node_ids": ["d1492e08-6161-49cd-94b1-551aa42e75c9", "b939572a-9ca0-450a-a0e5-c2cd904da8a4", "6662634b-449a-4f2a-a389-cf2112dfb8ad", "15559778-461f-4d10-b7f4-517d286b4384", "54aaf650-63de-4e82-a5ac-995f4bb6d0ef", "4e7b27c1-9a4e-47e9-a000-acf365fe20b9", "dcb8b949-a400-4033-a6cc-153076c4edf0", "416032bc-6ec5-40f4-bcbc-c0dabef88a69"], "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}}, "6173c44e-5815-41db-b385-fe5d507dc819": {"node_ids": ["0b6ffb33-51dd-4ad6-bfc4-f17c019683e1", "a567e4f6-51d8-4c76-bbde-14c6fc05f458", "caf5be9f-4350-4e36-995f-120abe976a4e", "5d4b4a1d-cbeb-4a7b-8430-c0a6368cdd16", "17f86ef6-2bd5-4f38-93ca-ca669c2829f9", "e81fcac5-a6d4-4985-97d9-1459bfc32744", "a330f51c-e3ec-4f04-97c9-3ea61db49426", "03a8645c-1bd3-4632-ac9f-4434b4085650", "5bf06c3a-a7ab-473d-9240-2869a15683e4", "c175c9d7-39bd-4026-be64-f5d0df600644", "9fadeb1c-2cd8-4032-92cd-920248b9963c", "bd41bf3c-92fe-486b-805b-8ad55c07c0b0", "f65a3ad9-149c-49a6-87a6-afdf5f457f30", "fcb627f0-507c-4f6a-a239-cc5cece49878", "87d70abd-3c01-4749-b1ae-93729ddd947a", "25241697-315f-48f4-8ef7-974f2abd50e3", "f9545f6b-fade-42f7-a843-82e04cbcbe68", "4ef0ab90-5a91-48ff-91bf-72a3e6f1ca9f"], "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}}}, "docstore/data": {"a40c0a51-2e45-4364-b9a3-c79c8fbc8a47": {"__data__": {"id_": "a40c0a51-2e45-4364-b9a3-c79c8fbc8a47", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "80766a41-e2a3-4c03-aba2-d523a8ad09ae", "node_type": "1", "metadata": {}, "hash": "31150d53fbac8864ab254717a45f22edcbc6d7a3aa0f35d11f9d17e21cf70c99", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 1: Introduction\nZhiyi HuangCOMP3251Welcome to COMP3251Instructor: -HUANG, Zhiyi (zhiyi@cs.hku.hk)\n-423 Chow Yei Ching Building\n-Tuesday, 4:00pm to 5:00pm\n-Other time slots may be available by appointment\nTutors: -LI, Dongchen (dongchen.li@connect.hku.hk)\n-SUN, Enze (sunenze@connect.hku.hk)\n-YANG, Peilin (peilinyang@connect.hku.hk)\n-LG101 Chow Yei Ching Building\n-Wednesday and Friday, 4:00pm to 5:00pm2\nWhat are algorithms?\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.Examples:  Multiplying two numbers, say, 1234 and 5678.\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n22712Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n2271217034Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1408, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "80766a41-e2a3-4c03-aba2-d523a8ad09ae": {"__data__": {"id_": "80766a41-e2a3-4c03-aba2-d523a8ad09ae", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a40c0a51-2e45-4364-b9a3-c79c8fbc8a47", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "0a6d17498013aa34d5d597f5641e31e4aee030e68a4ab2bf65520c809cb419c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "006cdbdb-df73-4333-b390-a7ba4954faff", "node_type": "1", "metadata": {}, "hash": "fda03364d188e335162f497da0c35301edab61b3cdac69af9ae957edfc376138", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2271217034Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n227121703411356Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n2271217034113565678Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP32514An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n22712170341135656787006652Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP3251In primary school, we learnt this as\u2028\u201cthe correct way\u201d of calculating the\u2028multiplication of two numbers.\u2028\n4An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n22712170341135656787006652Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP3251In primary school, we learnt this as\u2028\u201cthe correct way\u201d of calculating the\u2028multiplication of two numbers.\u2028In this course: -How good is this algorithm?\n-Can we do better?4An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n22712170341135656787006652Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.", "mimetype": "text/plain", "start_char_idx": 1217, "end_char_idx": 2701, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "006cdbdb-df73-4333-b390-a7ba4954faff": {"__data__": {"id_": "006cdbdb-df73-4333-b390-a7ba4954faff", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "80766a41-e2a3-4c03-aba2-d523a8ad09ae", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "9cce2fbcf6ddd52b0d378beb7dec9afaf6b9786ee0c50e4475b0da651e1b3afb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a6d42a8f-a17e-4eec-beb7-b6ad4b3f66db", "node_type": "1", "metadata": {}, "hash": "bb27cc17ccefbaa1841e40b35a5eccdd4fc0874216c829cd8cc8b7edd371afa5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Can we do better?4An algorithm is a set of precise step-by-step rules for solving a speci\ufb01c computational problem.\n22712170341135656787006652Examples:  Multiplying two numbers, say, 1234 and 5678.5678\u2a091234\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.\n5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).\n5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).\n5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).\n5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).4)Multiply (34) and (78) and get (2652).", "mimetype": "text/plain", "start_char_idx": 2381, "end_char_idx": 3633, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a6d42a8f-a17e-4eec-beb7-b6ad4b3f66db": {"__data__": {"id_": "a6d42a8f-a17e-4eec-beb7-b6ad4b3f66db", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "006cdbdb-df73-4333-b390-a7ba4954faff", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "570113f6bf7169b1b10da22fd809f94d2c0f3bc6772db95ea6c77a44c314036e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1f16ebb0-0ca8-49af-867e-32fd92b0fc8a", "node_type": "1", "metadata": {}, "hash": "415a7cfa6670bafb4807cdddc5848e65e26f71b0e0f819a7a37baa702e2a87c4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).4)Multiply (34) and (78) and get (2652).\n5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).4)Multiply (34) and (78) and get (2652).5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).\n5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).4)Multiply (34) and (78) and get (2652).5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).", "mimetype": "text/plain", "start_char_idx": 3339, "end_char_idx": 4431, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1f16ebb0-0ca8-49af-867e-32fd92b0fc8a": {"__data__": {"id_": "1f16ebb0-0ca8-49af-867e-32fd92b0fc8a", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a6d42a8f-a17e-4eec-beb7-b6ad4b3f66db", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "f81af7b582b9630d5419e132fd9997d03af0414e3aed482cb57f2d5ed55f18fd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a5829581-10a8-48bd-be21-dde8ffadb40b", "node_type": "1", "metadata": {}, "hash": "1cea22c0b22f5f9f51d84c6099fedcf4ff016bb8c152bf3df1ea462bf16cf1a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).4)Multiply (34) and (78) and get (2652).5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).7)Sum up (6720000) (1st number padded with four 0\u2019s), (2652) (2nd number), and (284000) (4th number padded with two 0\u2019s), and get5\nZhiyi HuangCOMP3251An alternative multiplication algorithmExamples:  Multiplying two numbers, say, 1234 and 5678.1)Partition (1234) into two numbers (12) and (34).2)Partition (5678) into two numbers (56) and (78).3)Multiply (12) and (56) and get (672).4)Multiply (34) and (78) and get (2652).5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).7)Sum up (6720000) (1st number padded with four 0\u2019s), (2652) (2nd number), and (284000) (4th number padded with two 0\u2019s), and get(6720000) + (2652) + (284000) = (7006652).5\nZhiyi HuangCOMP3251An alternative multiplication algorithm\nExamples:  Multiplying two numbers, say, 1234 and 5678.\n1)Partition (1234) into two numbers (12) and (34).", "mimetype": "text/plain", "start_char_idx": 4432, "end_char_idx": 5781, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a5829581-10a8-48bd-be21-dde8ffadb40b": {"__data__": {"id_": "a5829581-10a8-48bd-be21-dde8ffadb40b", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1f16ebb0-0ca8-49af-867e-32fd92b0fc8a", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "37c68e24aa327aab070d1a37d8055d3fa1f02fad39f15586ae404b403c236c90", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b154dff4-4bc1-4385-84c0-cbc0f90bfbc0", "node_type": "1", "metadata": {}, "hash": "b08549d214845eb2fa1aeee73ed2ccd3710d7bbcf1418d2565116c580a4ac037", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1)Partition (1234) into two numbers (12) and (34).\n2)Partition (5678) into two numbers (56) and (78).\n3)Multiply (12) and (56) and get (672).\n4)Multiply (34) and (78) and get (2652).\n5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).\n6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).\n7)Sum up (6720000) (1st number padded with four 0\u2019s), (2652) (2nd number), and (284000) (4th number padded with two 0\u2019s), and get\n(6720000) + (2652) + (284000) = (7006652).\n6\nCannot make any sense?\nZhiyi HuangCOMP3251An alternative multiplication algorithm\nExamples:  Multiplying two numbers, say, 1234 and 5678.\n1)Partition (1234) into two numbers (12) and (34).\n2)Partition (5678) into two numbers (56) and (78).\n3)Multiply (12) and (56) and get (672).\n4)Multiply (34) and (78) and get (2652).\n5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).\n6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).\n7)Sum up (6720000) (1st number padded with four 0\u2019s), (2652) (2nd number), and (284000) (4th number padded with two 0\u2019s), and get\n(6720000) + (2652) + (284000) = (7006652).\n6\nCannot make any sense?\u2022That\u2019s expected for now!\nZhiyi HuangCOMP3251An alternative multiplication algorithm\nExamples:  Multiplying two numbers, say, 1234 and 5678.\n1)Partition (1234) into two numbers (12) and (34).", "mimetype": "text/plain", "start_char_idx": 5731, "end_char_idx": 7096, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b154dff4-4bc1-4385-84c0-cbc0f90bfbc0": {"__data__": {"id_": "b154dff4-4bc1-4385-84c0-cbc0f90bfbc0", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a5829581-10a8-48bd-be21-dde8ffadb40b", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "cabd1387559ee0235b96cf90d4c8d3429050c7e4e4232ccc3461808987464c02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6a18421e-e48b-4279-97a2-ebf780eb72c8", "node_type": "1", "metadata": {}, "hash": "2259b591560c7ecdb6731a85a48247989040df554e11e859c6c3984751a7f950", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "6\nCannot make any sense?\u2022That\u2019s expected for now!\nZhiyi HuangCOMP3251An alternative multiplication algorithm\nExamples:  Multiplying two numbers, say, 1234 and 5678.\n1)Partition (1234) into two numbers (12) and (34).\n2)Partition (5678) into two numbers (56) and (78).\n3)Multiply (12) and (56) and get (672).\n4)Multiply (34) and (78) and get (2652).\n5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).\n6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).\n7)Sum up (6720000) (1st number padded with four 0\u2019s), (2652) (2nd number), and (284000) (4th number padded with two 0\u2019s), and get\n(6720000) + (2652) + (284000) = (7006652).\n6\nCannot make any sense?\u2022That\u2019s expected for now!\u2022After a few classes, you will understand this alternative multiplication algorithm. \nZhiyi HuangCOMP3251An alternative multiplication algorithm\nExamples:  Multiplying two numbers, say, 1234 and 5678.\n1)Partition (1234) into two numbers (12) and (34).\n2)Partition (5678) into two numbers (56) and (78).\n3)Multiply (12) and (56) and get (672).\n4)Multiply (34) and (78) and get (2652).\n5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).\n6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).", "mimetype": "text/plain", "start_char_idx": 6881, "end_char_idx": 8132, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6a18421e-e48b-4279-97a2-ebf780eb72c8": {"__data__": {"id_": "6a18421e-e48b-4279-97a2-ebf780eb72c8", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b154dff4-4bc1-4385-84c0-cbc0f90bfbc0", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "de4b144b58d1f82a8027ffec56aa7bcd9546a47858135cd5aadd037bb13fcd41", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25a9cfe9-20c5-40ba-ad06-cc933c95025a", "node_type": "1", "metadata": {}, "hash": "884901fd65ec1bfad01721c54dc551ff4dc1a010e6b26ac61d2ca0285de4d3d2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)Partition (5678) into two numbers (56) and (78).\n3)Multiply (12) and (56) and get (672).\n4)Multiply (34) and (78) and get (2652).\n5)Multiply (12)+(34)=(46) and (56)+(78)=(134) and get (6164).\n6)Subtract the \ufb01rst two numbers from the third one and get (6164)-(672)-(2652)=(2840).\n7)Sum up (6720000) (1st number padded with four 0\u2019s), (2652) (2nd number), and (284000) (4th number padded with two 0\u2019s), and get\n(6720000) + (2652) + (284000) = (7006652).\n6\nCannot make any sense?\u2022That\u2019s expected for now!\u2022After a few classes, you will understand this alternative multiplication algorithm. \u2022By the end of the semester, you will be able to design algorithms like this one (and other fancy techniques too).\nWhy study algorithms?\nZhiyi HuangCOMP3251Useful for all areas in CS\n8\nZhiyi HuangCOMP3251Useful for all areas in CS\n8\ndatabase\nZhiyi HuangCOMP3251Useful for all areas in CS\n8\ndatabase\nnetworking\nZhiyi HuangCOMP3251Useful for all areas in CS\n8\ndatabase\nnetworking\nmachine learning\nZhiyi HuangCOMP3251Useful for all areas in CS\n8\ndatabase\nnetworking\ncomputer vision\nmachine learning\nZhiyi HuangCOMP3251Algorithms that run the world\n9\nPage Rank\nZhiyi HuangCOMP3251Algorithms that run the world\n10\nShortest Path Algorithms\nZhiyi HuangCOMP3251Algorithms that run the world\n11\nOnline Advertisement\nZhiyi HuangCOMP3251Online Advertisement is Big!\n12\n\nZhiyi HuangCOMP3251LeetCode Prep Course?", "mimetype": "text/plain", "start_char_idx": 7852, "end_char_idx": 9239, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "25a9cfe9-20c5-40ba-ad06-cc933c95025a": {"__data__": {"id_": "25a9cfe9-20c5-40ba-ad06-cc933c95025a", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6a18421e-e48b-4279-97a2-ebf780eb72c8", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "ea5ed3aa603d2dd4c0eab330db9ba1841096032346d10d61528d08063f8bcd60", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "30803c9b-9c54-4b53-b90b-ca2b3a5e9c2d", "node_type": "1", "metadata": {}, "hash": "8edc134d5390513a78bdcea194b01a6cdd454e7609af687352c60c0f9080c731", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "12\n\nZhiyi HuangCOMP3251LeetCode Prep Course?\n13\n\nZhiyi HuangCOMP3251What you will get from this course?\u2022Become a better programmer\u2028\u2022Sharpen your analytical and mathematical skills\u2028\u2022Ace the algorithm questions in your job interviews\u2028\u2022Think \u201calgorithmically\u201d\n14\nZhiyi HuangCOMP3251TextbookLecture notes: -Self-contained\n-Available on Moodle before each lecture\nTextbook (required supplementary readings): -Algorithms\u2028S. Dasgupta, C. H. Papadimitriou, and U. Vazirani\nOther resources (optional): -Algorithm Design\u2028E. Tardos and J. Kleinberg\n-Introduction to Algorithms\u2028T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein\n-Online course by Tim Roughgarden15\nZhiyi HuangCOMP3251Course TopicsAlgorithm design paradigms: -Divide and conquer (DPV Ch. 2)\n-Greedy (DPV Ch. 5)\n-Dynamic programming (DPV Ch. 6)\nGraph algorithms: -Graph decomposition (DPV Ch. 3)\n-Shortest path (DPV Ch. 4)\n-Max \ufb02ow (DPV Ch. 7.2, supplementary materials will be available on Moodle)\nComplexity theory: -NP-completeness and reduction (DPV Ch.", "mimetype": "text/plain", "start_char_idx": 9195, "end_char_idx": 10212, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "30803c9b-9c54-4b53-b90b-ca2b3a5e9c2d": {"__data__": {"id_": "30803c9b-9c54-4b53-b90b-ca2b3a5e9c2d", "embedding": null, "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "b6163bdd-4e39-43ef-86a6-15094756ba59", "node_type": "4", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "dc16c5e11f997db38e3d1f3025be2800b25b4e3c2230724c3f073e6b9444ac73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25a9cfe9-20c5-40ba-ad06-cc933c95025a", "node_type": "1", "metadata": {"file_name": "S01 Introduction_processed.txt", "source_file": "S01 Introduction", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S01 Introduction_processed.txt"}, "hash": "19b47e9f664730960c9ad394d5ade3cc3e4de93fec73f6aaa1cd4fb7890ba61e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)\n-Greedy (DPV Ch. 5)\n-Dynamic programming (DPV Ch. 6)\nGraph algorithms: -Graph decomposition (DPV Ch. 3)\n-Shortest path (DPV Ch. 4)\n-Max \ufb02ow (DPV Ch. 7.2, supplementary materials will be available on Moodle)\nComplexity theory: -NP-completeness and reduction (DPV Ch. 8)16\nZhiyi HuangCOMP3251Assessment\u2022Homework assignments (40%)\n-5 assignments \n-Count best 4 out of 5\n-No late submission: If you happen to be extremely busy before one of the deadlines, that\u2019s your worst 1 out of 5 \n-About 4 problems in each assignment\n\u2022Midterm (10%)\n-90 min, semi-open book (2 sheets of A4), in class\n-Most likely in the week after the reading week\n\u2022Final (50%)\n-3 hours, 4-5 questions, semi-open book (2 sheets of A4)17\nZhiyi HuangCOMP3251Collaboration Policy for Homework AssignmentsYES:Discuss with friends, ask ChatGPT, acknowledge them, \u2028write your own solutions.\nNO:Copy solutions word-for-word or with minor modi\ufb01cations (from your friends, from the Internet, from past-year, etc.)\nNote:  I strongly recommend that you try to complete the homework assignments on your own.\n18\nZhiyi HuangCOMP32513251 (Regular Class) vs. 3252 (Advanced Class)\u2022COMP3251 focuses on\n-How basic algorithms work\n-Applications of algorithms\u2028\u2022COMP3252 emphasizes more on\n-Problem solving skills\n-Mathematical proofs\n19", "mimetype": "text/plain", "start_char_idx": 9944, "end_char_idx": 11231, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "63ebeaac-b0f7-4b72-a69c-fb210fa15212": {"__data__": {"id_": "63ebeaac-b0f7-4b72-a69c-fb210fa15212", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8159c0bd-a585-42aa-ac2f-f3f324912192", "node_type": "1", "metadata": {}, "hash": "fe95dd615bf030e144dae0d0625f6d50642363151fd780be5c824638dc06d4e5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 2: Merge Sort (Chapter 2.3)\nZhiyi HuangCOMP3251SortingInput:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\n2\nZhiyi HuangCOMP3251SortingInput:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.\n312567322093978InputOutput\nZhiyi HuangCOMP3251SortingInput:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.\n41256732209397812InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n512567322093978512InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n61256732209397851267InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n7125673220939785123267InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n812567322093978512203267InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1491, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8159c0bd-a585-42aa-ac2f-f3f324912192": {"__data__": {"id_": "8159c0bd-a585-42aa-ac2f-f3f324912192", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63ebeaac-b0f7-4b72-a69c-fb210fa15212", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "d39810bc8952f6097a4eee703d4b829a6430633f5be0c1f518c28cc2b8316182", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f5d90bdc-c464-49e6-8fb7-9d824732d34e", "node_type": "1", "metadata": {}, "hash": "f0da13e8105ec274c07b4bd4d27e91f948e8a67ad6961cc8ca62d7acb0241234", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Output:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n812567322093978512203267InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n9125673220939785912203267InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n1012567322093978591220323967InputOutput\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm.Sorting\n111256732209397859122032396778InputOutput\nZhiyi HuangCOMP3251How good is insertion sort?\u2022Worst-case analysis -For any input length n, consider the maximum number of steps the algorithm needs on the worst input of length n.\n-Measuring performance instance by instance does not lead to reasonable algorithms (too specialized).\n-Average performance is a reasonable alternative, but not the focus of this course.\n\u2022Asymptotic analysis -Big-O notation\n-Focus on the performance when n gets really big\n-Example:  5n2+2n+10 = O(n2)12\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.", "mimetype": "text/plain", "start_char_idx": 1232, "end_char_idx": 2598, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f5d90bdc-c464-49e6-8fb7-9d824732d34e": {"__data__": {"id_": "f5d90bdc-c464-49e6-8fb7-9d824732d34e", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8159c0bd-a585-42aa-ac2f-f3f324912192", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "03c74c6119b6649199e47f62fd98a4c54de3b17acac36c0474ff2c717eb40f9f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "94d8ee8d-9b8e-4f52-b482-6023dc27b61d", "node_type": "1", "metadata": {}, "hash": "765428b8c6077eb84867cade47ad7ecf8eba58b9c88a490cc9f7322ba722a606", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Average performance is a reasonable alternative, but not the focus of this course.\n\u2022Asymptotic analysis -Big-O notation\n-Focus on the performance when n gets really big\n-Example:  5n2+2n+10 = O(n2)12\nZhiyi HuangCOMP3251Input:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\nWarm-up:  The insertion sort algorithm takes O(n2) time.Sorting\n1312567322093978InputOutputn numbers \u2028in the inputinserting a number\u2028to the output takes\u2028at most O(n) time59122032396778\nZhiyi HuangCOMP3251The divide-and-conquer algorithm design paradigm solves a problem as follows:\n1)Divide:  Breaking the problem into subproblems that are themselves smaller instances of the same type of problem;  \n2)Recurse:  Recursively solving these subproblems;\n3)Combine:  Appropriately combining their answers to get an answer of the original problem.\nNote:  If the size of a subproblem is small enough, we will stop using the divide-and-conquer strategy; instead, we may solve the subproblem by brute-force.\nDivide and Conquer (Ch. 2)\n14\nZhiyi HuangCOMP3251Merge SortInput:  A set of n integers \u2014 x1, x2, \u2026 , xn.\nOutput:  The same set of n integers in ascending order.\n15\nDivide:        Divide the input integers into two subsets \u2028                   x1, \u2026 , xn/2 and xn/2+1, \u2026 , xn.\nRecurse:    Sort the two subsets (n/2-size subproblems).\u2028                   Let y1, \u2026 , yn/2 and yn/2+1, \u2026 , yn be the output.\nCombine:   Merge two sorted list y1, \u2026 , yn/2 and yn/2+1, \u2026 , yn\u2028                   into a single sorted lists of integers.Running time:  T(n), total time for sorting a set of n integers.\nT(n) = 2T(n/2) +", "mimetype": "text/plain", "start_char_idx": 2277, "end_char_idx": 3905, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "94d8ee8d-9b8e-4f52-b482-6023dc27b61d": {"__data__": {"id_": "94d8ee8d-9b8e-4f52-b482-6023dc27b61d", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f5d90bdc-c464-49e6-8fb7-9d824732d34e", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "a0e5268c0b9d4f06fbd2b92c4c5ba232f560dfe82211f5ddcaf375b5951cee3b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "923b54d2-d305-442b-8f3e-1820ea82f8a8", "node_type": "1", "metadata": {}, "hash": "3cf9de3e8fe0e78c538953425bc4d9b403a7bfab0c3b1a521c9b2c9fa3161ff4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Let y1, \u2026 , yn/2 and yn/2+1, \u2026 , yn be the output.\nCombine:   Merge two sorted list y1, \u2026 , yn/2 and yn/2+1, \u2026 , yn\u2028                   into a single sorted lists of integers.Running time:  T(n), total time for sorting a set of n integers.\nT(n) = 2T(n/2) + (running time of merging two n/2-size sorted lists) \nZhiyi HuangCOMP3251An Example of Merge Sort\n1612567322093978\nZhiyi HuangCOMP3251An Example of Merge Sort\n161256732209397812567322093978\nZhiyi HuangCOMP3251An Example of Merge Sort\n1612567322093978125673220939781)  Sort the top list recursively\nZhiyi HuangCOMP3251An Example of Merge Sort\n1612567322093978125673220939782)  Sor", "mimetype": "text/plain", "start_char_idx": 3650, "end_char_idx": 4284, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "923b54d2-d305-442b-8f3e-1820ea82f8a8": {"__data__": {"id_": "923b54d2-d305-442b-8f3e-1820ea82f8a8", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "94d8ee8d-9b8e-4f52-b482-6023dc27b61d", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "42436eb5c734702945b2a6b9a13bb0650525ac41023772a9f4f8c38ae7b50fad", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "02f93b3d-66b3-43ec-8048-e07b5c0f300e", "node_type": "1", "metadata": {}, "hash": "d869c05d6f0097aa3129515050570beee2c35df812653a79d9e1271784f3931b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "p list recursively\nZhiyi HuangCOMP3251An Example of Merge Sort\n1612567322093978125673220939782)  Sort the bottom list recursively1)  Sort the top list recursively\nZhiyi HuangCOMP3251An Example of Merge Sort\n1612567322093978125673220939782)  Sort the bottom list recursively1)  Sort the top list recursively\n3)  Merge the two sorted list output by the subproblems to get a sorted list of all integers\nZhiyi HuangCOMP3251An Example of Merge Sort\n171256732209397812567322093", "mimetype": "text/plain", "start_char_idx": 4184, "end_char_idx": 4655, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "02f93b3d-66b3-43ec-8048-e07b5c0f300e": {"__data__": {"id_": "02f93b3d-66b3-43ec-8048-e07b5c0f300e", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "923b54d2-d305-442b-8f3e-1820ea82f8a8", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "19fbd67a6aa341e0f477a59ad39271d897b578fdf477e5bf66ce1945648eef88", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d63c0e15-8e81-441b-a158-15828f5c5390", "node_type": "1", "metadata": {}, "hash": "87255e023018c5b5f2d1d29dc09a22b5ca78e70df44c2e7d8b74e16c126d0591", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "sorted list of all integers\nZhiyi HuangCOMP3251An Example of Merge Sort\n1712567322093978125673220939781256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n1812567322093978125673220939781256732125\nZhiyi HuangCOMP3251An Example of Merge Sort\n1912567322093978125673220939785126732125\nZhiyi HuangCOMP3251An Example of Merge Sort\n20125673220939781256732209397851267321256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n21125673220939781256732209397851232671256732\nZhiyi HuangC", "mimetype": "text/plain", "start_char_idx": 4556, "end_char_idx": 5026, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d63c0e15-8e81-441b-a158-15828f5c5390": {"__data__": {"id_": "d63c0e15-8e81-441b-a158-15828f5c5390", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "02f93b3d-66b3-43ec-8048-e07b5c0f300e", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "4f9b8bf1201e4cb968e1b73b56e7091e64e50e4ca1c126e5b1deb6a35df8285e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "44ec0e76-b94d-4476-9c71-d20bf2f5c630", "node_type": "1", "metadata": {}, "hash": "30b46a9c06c70b37632394e3c4708571525f2a555742e19a25f8fb719e60915b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "hiyi HuangCOMP3251An Example of Merge Sort\n21125673220939781256732209397851232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n22125673220939785123267209397851232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort1256732209397820939782093978512326751232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n241256732209397820939782093978209512326751232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n2512567322093978673212520939781256732125673292039782095123", "mimetype": "text/plain", "start_char_idx": 4926, "end_char_idx": 5397, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "44ec0e76-b94d-4476-9c71-d20bf2f5c630": {"__data__": {"id_": "44ec0e76-b94d-4476-9c71-d20bf2f5c630", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d63c0e15-8e81-441b-a158-15828f5c5390", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "25a8f75aea97503becce3f44d39f80afb636461381ca4304e940443df7d05b73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "28ce6eb2-7ab7-4012-9a2e-5c12261971a6", "node_type": "1", "metadata": {}, "hash": "9ff6858220fe8c410473b205eb0d9979fdfeae3d0fbfd62ba672dfbf2c6fa3ab", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "iyi HuangCOMP3251An Example of Merge Sort\n251256732209397867321252093978125673212567329203978209512326751232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n2612567322093978209397839783978673212512567321256732920209512326751232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n2712567322093978209397839783978673212512567321256732920209512326751232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n2812567322093978920397839783978673212512567321256732920209512", "mimetype": "text/plain", "start_char_idx": 5297, "end_char_idx": 5768, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "28ce6eb2-7ab7-4012-9a2e-5c12261971a6": {"__data__": {"id_": "28ce6eb2-7ab7-4012-9a2e-5c12261971a6", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "44ec0e76-b94d-4476-9c71-d20bf2f5c630", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "76e9c05a979eda9e970b1c52b888d7476da110c4ea7fa9701de9a7112b4fe071", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "11aeba91-6ace-4021-9712-0d30e5e0bc6a", "node_type": "1", "metadata": {}, "hash": "41ba454b14df74030d6a4367421284131dedff59d1f142b429d950bef74b825a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "HuangCOMP3251An Example of Merge Sort\n2812567322093978920397839783978673212512567321256732920209512326751232671256732\nZhiyi HuangCOMP3251An Example of Merge Sort\n2959122032396778920397839783978673212512567321256732920209512326751232671256732\nRest of this lecture:1)How to merge two sorted lists of integers?\n2)Solving T(n).", "mimetype": "text/plain", "start_char_idx": 5669, "end_char_idx": 5992, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "11aeba91-6ace-4021-9712-0d30e5e0bc6a": {"__data__": {"id_": "11aeba91-6ace-4021-9712-0d30e5e0bc6a", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "28ce6eb2-7ab7-4012-9a2e-5c12261971a6", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "6ee156728a95a8a45ed634f70f6d458413fd181a8dd809f1c73ecddb03aa81ec", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9f7b8cf4-f099-4eb6-a50d-61e15bcaed20", "node_type": "1", "metadata": {}, "hash": "bf1479897db44df88a52dc47c0b08c362794759567eb411e6b300070c1d2172f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "20209512326751232671256732\nRest of this lecture:1)How to merge two sorted lists of integers?\n2)Solving T(n).\nZhiyi HuangCOMP3251Merging Two Sorted Lists of Numbers\n31\n\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n5\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n5\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n59\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n59\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n5912\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n5912\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n591220\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n591220\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n59122032\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n59122032\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n5912203239\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n5912203239\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n591220323967\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n591220323967\nZhiyi HuangCOMP3251An Example of Merging Two Sorted Lists\n3251232679203978\n59122032396778\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time,", "mimetype": "text/plain", "start_char_idx": 5884, "end_char_idx": 7441, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9f7b8cf4-f099-4eb6-a50d-61e15bcaed20": {"__data__": {"id_": "9f7b8cf4-f099-4eb6-a50d-61e15bcaed20", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "11aeba91-6ace-4021-9712-0d30e5e0bc6a", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "e6df39b2e7792aa2463587f51d01ed47d82e9f6ec547b395d42fc4b95f1ff15c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f40a06e5-8f43-4d66-a141-38534f4cf685", "node_type": "1", "metadata": {}, "hash": "65b4801108f14676ef5a284f14f8dd9a14720d39cd1262f0d5bdfd65d3f43748", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "we measure progress by the number of integers that have been put into the output list.\n33\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time, we measure progress by the number of integers that have been put into the output list.-After a comparison, the algorithm will put an integer into the output list.\n33\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time, we measure progress by the number of integers that have been put into the output list.-After a comparison, the algorithm will put an integer into the output list.-Initially, there is no integer in the output list.\n33\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time, we measure progress by the number of integers that have been put into the output list.-After a comparison, the algorithm will put an integer into the output list.-Initially, there is no integer in the output list.-To merge two sorted lists of length m and n, the \ufb01nal output list has m+n integers.\n33\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time, we measure progress by the number of integers that have been put into the output list.-After a comparison, the algorithm will put an integer into the output list.-Initially, there is no integer in the output list.-To merge two sorted lists of length m and n, the \ufb01nal output list has m+n integers.-The algorithm makes at most m+n comparisons.\n33\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time, we measure progress by the number of integers that have been put into the output list.-After a comparison, the algorithm will put an integer into the output list.-Initially, there is no integer in the output list.-To merge two sorted lists of length m and n, the \ufb01nal output list has m+n integers.-The algorithm makes at most m+n comparisons.\u2022Note that the size of the input is m+n, and the merging algorithm runs in O(m+n) time.", "mimetype": "text/plain", "start_char_idx": 7442, "end_char_idx": 9361, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f40a06e5-8f43-4d66-a141-38534f4cf685": {"__data__": {"id_": "f40a06e5-8f43-4d66-a141-38534f4cf685", "embedding": null, "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4575fd29-4f6f-4ebb-a52d-3856fd5917b8", "node_type": "4", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "838fb7be3489d33fd9fd3557ba225ff23904de6f6ade2e7b6df46693236af4fe", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9f7b8cf4-f099-4eb6-a50d-61e15bcaed20", "node_type": "1", "metadata": {"file_name": "S02 Merge Sort_processed.txt", "source_file": "S02 Merge Sort", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S02 Merge Sort_processed.txt"}, "hash": "63b3902fdd23a56600e18bba153eddd8b36e7490e1302f84828830fc033338c4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "So it is a linear-time algorithm.33\nZhiyi HuangCOMP3251What is the running time?\u2022To analyze the running time, we measure progress by the number of integers that have been put into the output list.-After a comparison, the algorithm will put an integer into the output list.-Initially, there is no integer in the output list.-To merge two sorted lists of length m and n, the \ufb01nal output list has m+n integers.-The algorithm makes at most m+n comparisons.\u2022Note that the size of the input is m+n, and the merging algorithm runs in O(m+n) time. So it is a linear-time algorithm.\u2022Thus, we have T(n) = 2T(n/2) + O(n)33\nZhiyi HuangCOMP3251Solving the Recursion\u2022Suppose\n\u2022Keep expanding the RHS until it is a function of n and T(1):\n34T(n)=2T(n/2)+O(n)\u22642T(n/2)+cnT(n)\u22642T(n/2)+cn\u22642(2T(n/4)+c(n/2))+cn=4T(n/4)+2cn\u22644(2T(n/8)+c(n/4))+2cn=8T(n/8)+3cn\u2026\u22642iT(n/2i)+icn\u2026=2lognT(1)+cnlogn=O(nlogn)", "mimetype": "text/plain", "start_char_idx": 9362, "end_char_idx": 10239, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3181be21-44b3-4baf-a463-5861511f3b7f": {"__data__": {"id_": "3181be21-44b3-4baf-a463-5861511f3b7f", "embedding": null, "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2a50949-bd6b-49eb-ad31-dca516c89046", "node_type": "4", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "78671b7d3f97b028a99701f244381b8caf3cfbbe9e2ecca38a094609f85f1a73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e3ec9b3c-278e-4781-b3df-3feef2bcce93", "node_type": "1", "metadata": {}, "hash": "e4e6a1da7f5e7ed95e473fd178c47a1ecf02f7f71ce732c85f62bd488476ec06", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 3: Master Theorem \u2028(Chapter 2.2)\nZhiyi HuangCOMP3251\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=dA General Theorem for \u2028Solving Recurrence RelationsThe most important formula that you need to remember in this chapter.\n2\nZhiyi HuangCOMP3251\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=dA General Theorem for \u2028Solving Recurrence RelationsThe most important formula that you need to remember in this chapter.\n2\ndivide the problem into a subproblems\nZhiyi HuangCOMP3251\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=dA General Theorem for \u2028Solving Recurrence RelationsThe most important formula that you need to remember in this chapter.\n2\ndivide the problem into a subproblems\neach subproblem has size n/b\nZhiyi HuangCOMP3251\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=dA General Theorem for \u2028Solving Recurrence RelationsThe most important formula that you need to remember in this chapter.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1292, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e3ec9b3c-278e-4781-b3df-3feef2bcce93": {"__data__": {"id_": "e3ec9b3c-278e-4781-b3df-3feef2bcce93", "embedding": null, "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2a50949-bd6b-49eb-ad31-dca516c89046", "node_type": "4", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "78671b7d3f97b028a99701f244381b8caf3cfbbe9e2ecca38a094609f85f1a73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3181be21-44b3-4baf-a463-5861511f3b7f", "node_type": "1", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "4d4b08d68f43297d465ed332f75460a75c0bae6f0ba3c23e1e0a8f3bcc4a574f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "027924a9-8986-41d6-96a0-0533e7e8c7d6", "node_type": "1", "metadata": {}, "hash": "1a8176d9ad084db205b5fbd9cfacc1b1489d931c8a7329acaab38f10dc5da14e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=dA General Theorem for \u2028Solving Recurrence RelationsThe most important formula that you need to remember in this chapter.\n2\ndivide the problem into a subproblems\neach subproblem has size n/b\ndividing and combining takes O(nd) time\nZhiyi HuangCOMP3251\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=dA General Theorem for \u2028Solving Recurrence RelationsThe most important formula that you need to remember in this chapter.\n2\ndivide the problem into a subproblems\neach subproblem has size n/b\ndividing and combining takes O(nd) time\nImplicit assumptions:  (1) constant-size subproblems can be solved in O(1) time;  (2) all subproblems have the same size.\nZhiyi HuangCOMP3251\nProof of the Master Theorem for\u2028T(n) = a T(n/b) + O(nd)\n3n\u2026level 0\nlevel logb nlevel 1level 2level kn/b2n/b2n/b2n/b2n/bkn/bkn/bkn/bk1111\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026O(nd)a O((n/b)d)a2 O((n/b2)d)ak O((n/bk)d)alog_b(n) O(1)\u2026\u2026running time of \u2028the combine step\nrunning time of solving             size-1 \u2028subproblems is                   .", "mimetype": "text/plain", "start_char_idx": 1047, "end_char_idx": 2250, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "027924a9-8986-41d6-96a0-0533e7e8c7d6": {"__data__": {"id_": "027924a9-8986-41d6-96a0-0533e7e8c7d6", "embedding": null, "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2a50949-bd6b-49eb-ad31-dca516c89046", "node_type": "4", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "78671b7d3f97b028a99701f244381b8caf3cfbbe9e2ecca38a094609f85f1a73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e3ec9b3c-278e-4781-b3df-3feef2bcce93", "node_type": "1", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "5d2cedd59f0478dfaf27e782d44d73630e1705f848b328fa83da8a85e92a3521", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "79eca348-b85d-4ce6-8ce8-8af995e215e4", "node_type": "1", "metadata": {}, "hash": "e382fb677b99ab8ccf1eaca3dd0fc00fe01086cfb2a5492768e072d46e467ee2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "a subproblems\nak subproblemsn/bn/bn/b\nZhiyi HuangCOMP3251\u2022The running time of solving size-1 subproblems is\n\u2022The total running time of the combine steps (for all levels) is\n\u2022After simpli\ufb01cation, it is equal toProof of the Master Theorem for\u2028T(n) = a T(n/b) + O(nd)\n4\nCase 1:  a < bd, namely, logb a < d. \u2028Then, the \ufb01rst term dominates the above sum:\n\u2022Running time of the combine steps is O(nd).\n\u2022So                                                         .\n\nZhiyi HuangCOMP3251\u2022The running time of solving size-1 subproblems is\n\u2022The total running time of the combine steps (for all levels) is\n\u2022After simpli\ufb01cation, it is equal toProof of the Master Theorem for\u2028T(n) = a T(n/b) + O(nd)\n5\nCase 2:  a > bd, namely, logb a > d. \u2028Then, the last term dominates the above sum:\n\u2022Running time of the combine steps is\u2028\u2022So                                                                   .\nO\u0000nd(a/bd)logbn\u0000=O\u0000ndalogbn/nd\u0000=O\u0000alogbn\u0000=O\u0000nlogba\u0000\n\nZhiyi HuangCOMP3251\u2022The running time of solving size-1 subproblems is\n\u2022The total running time of the combine steps (for all levels) is\n\u2022After simpli\ufb01cation, it is equal toProof of the Master Theorem for\u2028T(n) = a T(n/b) + O(nd)\n6\nCase 3:  a = bd, namely, logb a = d. \u2028Then, all log n terms equal 1 in the above sum:\n\u2022Running time of the combine steps is O(nd log n).\n\u2022So                                                                       .\nT(n)=O\u0000nlogba\u0000+O\u0000ndlogn\u0000=O\u0000ndlogn\u0000\nZhiyi HuangCOMP3251\nMaster Theorem.", "mimetype": "text/plain", "start_char_idx": 2251, "end_char_idx": 3696, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "79eca348-b85d-4ce6-8ce8-8af995e215e4": {"__data__": {"id_": "79eca348-b85d-4ce6-8ce8-8af995e215e4", "embedding": null, "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2a50949-bd6b-49eb-ad31-dca516c89046", "node_type": "4", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "78671b7d3f97b028a99701f244381b8caf3cfbbe9e2ecca38a094609f85f1a73", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "027924a9-8986-41d6-96a0-0533e7e8c7d6", "node_type": "1", "metadata": {"file_name": "S03 Master Theorem_processed.txt", "source_file": "S03 Master Theorem", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S03 Master Theorem_processed.txt"}, "hash": "acbecae4c99175cd4ca2340be7e6a29ef2fdda977eda6167f83f0d2e858848cf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022So                                                                       .\nT(n)=O\u0000nlogba\u0000+O\u0000ndlogn\u0000=O\u0000ndlogn\u0000\nZhiyi HuangCOMP3251\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenAn Alternative Form of the Master Theorem\n7\ndivide the problem into a subproblems\neach subproblem has size n/b\ndividing and combining takes O(nd) timeT(n)={O(nmax{d,logba})logba\u2260dO(ndlogn)logba=d\nZhiyi HuangCOMP3251Example: Running Time of Merge Sort\nRecall that:\n\u2022Merge Sort divides the problem into two n/2-size subproblems.\n\u2022Merging two n/2-size sorted lists takes O(n) time.\nHence,\n\u2022a = 2, b = 2, d = 1.\n\u2022The running time of Merge Sort is T(n) = O(n log n).8\nMaster Theorem.  If T(n) = a T(n/b) + O(nd) for some constants \u2028a > 0, b > 1, and d \u2265 0, thenT(n)=O(nd)logba<dO(nlogba)logba>dO(ndlogn)logba=d", "mimetype": "text/plain", "start_char_idx": 3550, "end_char_idx": 4379, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f10d9399-371d-4045-a8d3-69a49aeb1b0f": {"__data__": {"id_": "f10d9399-371d-4045-a8d3-69a49aeb1b0f", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "26557338-1e28-47a7-8131-3b83b3b9374c", "node_type": "1", "metadata": {}, "hash": "ec2fef2d7ac35ab45465577c07cab0954e851a43858f483d2ea8a7d44946c9ea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 4: Selection (Chapter 2.4)\nZhiyi HuangCOMP3251SelectionInput:  A set S of n integers x1, x2, \u2026 , xn, and an integer 1 \u2264 k \u2264 n.\nOutput:  The k-th smallest integer x* among x1, x2, \u2026 , xn.\n2\nZhiyi HuangCOMP3251SelectionInput:  A set S of n integers x1, x2, \u2026 , xn, and an integer 1 \u2264 k \u2264 n.\nOutput:  The k-th smallest integer x* among x1, x2, \u2026 , xn.\n2\nA straight-forward selection algorithm: 1)Find the smallest integer.                     (O(n) time)\n2)Find the 2nd smallest integer.              (O(n-1) time)\n\u2026\nk)Find the k-th smallest integer.              (O(n-k+1) time)\nZhiyi HuangCOMP3251SelectionInput:  A set S of n integers x1, x2, \u2026 , xn, and an integer 1 \u2264 k \u2264 n.\nOutput:  The k-th smallest integer x* among x1, x2, \u2026 , xn.\n2\nA straight-forward selection algorithm: 1)Find the smallest integer.                     (O(n) time)\n2)Find the 2nd smallest integer.              (O(n-1) time)\n\u2026\nk)Find the k-th smallest integer.              (O(n-k+1) time)\nRunning time: O(nk)\nZhiyi HuangCOMP3251Example:  \u2028Select the 3rd smallest integer among 73, 44, 34, 18, 29, 27.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1093, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "26557338-1e28-47a7-8131-3b83b3b9374c": {"__data__": {"id_": "26557338-1e28-47a7-8131-3b83b3b9374c", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f10d9399-371d-4045-a8d3-69a49aeb1b0f", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "f39d6a61402445a19cb3413f76783aa93ba940d2b3a3087e5df94f2472fb91da", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4525e03-035c-42c5-a2a9-990b62bebedc", "node_type": "1", "metadata": {}, "hash": "9b40c0ec6f62ff7a66cb1dc85153fc257d6b64cf963dbc23fde94fb6f1f4f4fe", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "(O(n) time)\n2)Find the 2nd smallest integer.              (O(n-1) time)\n\u2026\nk)Find the k-th smallest integer.              (O(n-k+1) time)\nRunning time: O(nk)\nZhiyi HuangCOMP3251Example:  \u2028Select the 3rd smallest integer among 73, 44, 34, 18, 29, 27. 1)x1, x2, \u2026 , x6 = 73, 44, 34, 18, 29, 27;\n2)y1, y2, \u2026 , y6 = 18, 27, 29, 34, 44, 73;\n3)k = 3 and x* = y3 = 29.SelectionInput:  A set S of n integers x1, x2, \u2026 , xn, and an integer 1 \u2264 k \u2264 n.\nOutput:  The k-th smallest integer x* among x1, x2, \u2026 , xn.\n3\nAnother straight-forward selection algorithm: 1)Sort the input integers in ascending order (e.g., Merge Sort); \u2028Let y1, \u2026 , yn be the sorted list.\n2)Output yk.\nZhiyi HuangCOMP3251Example:  \u2028Select the 3rd smallest integer among 73, 44, 34, 18, 29, 27. 1)x1, x2, \u2026 , x6 = 73, 44, 34, 18, 29, 27;\n2)y1, y2, \u2026 , y6 = 18, 27, 29, 34, 44, 73;\n3)k = 3 and x* = y3 = 29.SelectionInput:  A set S of n integers x1, x2, \u2026 , xn, and an integer 1 \u2264 k \u2264 n.\nOutput:  The k-th smallest integer x* among x1, x2, \u2026 , xn.\n3\nAnother straight-forward selection algorithm: 1)Sort the input integers in ascending order (e.g., Merge Sort); \u2028Let y1, \u2026 , yn be the sorted list.\n2)Output yk.", "mimetype": "text/plain", "start_char_idx": 845, "end_char_idx": 2013, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a4525e03-035c-42c5-a2a9-990b62bebedc": {"__data__": {"id_": "a4525e03-035c-42c5-a2a9-990b62bebedc", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "26557338-1e28-47a7-8131-3b83b3b9374c", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "199a62645dd1caf1a02510f0d3a2e696b77ca1e894907abde1ef5ee1077d37e0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29e21863-a00b-4ab9-8a6f-af491974a70b", "node_type": "1", "metadata": {}, "hash": "dcfbce1d730a7b810b3632cf19f6a3feda8641bbab14f33dfa5a367adaf49d9d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3\nAnother straight-forward selection algorithm: 1)Sort the input integers in ascending order (e.g., Merge Sort); \u2028Let y1, \u2026 , yn be the sorted list.\n2)Output yk.\nRunning time: O(n log n)\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n4\nSelect(S, k) Divide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    Recurse on the subset that contains x*.Note:  The ranks are for explanation only; we don\u2019t need to sort the numbers.rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSv\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n4\nSelect(S, k) Divide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    Recurse on the subset that contains x*.Note:  The ranks are for explanation only; we don\u2019t need to sort the numbers.rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSv\nKey questions:  Which subset contains x*?\u2028What is the rank of x* in the subset?\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n5rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSv\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n5rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSvCase 1:   k \u2264 |SL|.\u2028    - x* is the k-th smallest integer in SL.\u2028    - Output Select(SL, k).", "mimetype": "text/plain", "start_char_idx": 1852, "end_char_idx": 3540, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "29e21863-a00b-4ab9-8a6f-af491974a70b": {"__data__": {"id_": "29e21863-a00b-4ab9-8a6f-af491974a70b", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4525e03-035c-42c5-a2a9-990b62bebedc", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "3d12001c8b4fb4e3cd1e01eb5dbf4123eda4e9b495084aa88f2a11f51f25ac12", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f7d130bf-7c4b-42f8-b8b5-c6fe0cb6446e", "node_type": "1", "metadata": {}, "hash": "f487dc991f3fadbf4395ea9b7ad43bff2a0b8954c468f64c02a3d9a5bb3b771b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n5rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSv\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n5rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSvCase 1:   k \u2264 |SL|.\u2028    - x* is the k-th smallest integer in SL.\u2028    - Output Select(SL, k).\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n5rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSvCase 1:   k \u2264 |SL|.\u2028    - x* is the k-th smallest integer in SL.\u2028    - Output Select(SL, k).Case 2:  |SL| < k \u2264 |SL| + |Sv|.\u2028    - x* is in Sv.\u2028    - Output v. (Note that all numbers in Sv are equal to v.)\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n5rank123\u2026\u2026\u2026\u2026integer\nvvvSLSRSvCase 1:   k \u2264 |SL|.\u2028    - x* is the k-th smallest integer in SL.\u2028    - Output Select(SL, k).Case 2:  |SL| < k \u2264 |SL| + |Sv|.\u2028    - x* is in Sv.\u2028    - Output v. (Note that all numbers in Sv are equal to v.)Case 3:  |SL| + |Sv| < k \u2264 n.\u2028    - x* is the (k - |SL| - |Sv|)-th smallest integer in SR.\u2028    - Output Select(SR, k - |SL| - |Sv|).\nThe 1st number in SR is the \u2028(|SL| + |Sv| + 1)-th number in S.\nSo the i-th number in SR is the \u2028(|SL| + |Sv| + i)-th number in S.\nThus x* is the (k - |SL| - |Sv|)-th smallest integer in SR.", "mimetype": "text/plain", "start_char_idx": 3269, "end_char_idx": 4452, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f7d130bf-7c4b-42f8-b8b5-c6fe0cb6446e": {"__data__": {"id_": "f7d130bf-7c4b-42f8-b8b5-c6fe0cb6446e", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29e21863-a00b-4ab9-8a6f-af491974a70b", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "cfcf2253ae6e6d2179fbb9f650ba6f9676dba34e1921f9a93e2a0e2afe9224a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "678b9544-a096-484f-8951-42aeba1888da", "node_type": "1", "metadata": {}, "hash": "919ad53130daf15f2e429231678edecf0d16a9b219fd02759994f2e00532a62d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "- Output Select(SR, k - |SL| - |Sv|).\nThe 1st number in SR is the \u2028(|SL| + |Sv| + 1)-th number in S.\nSo the i-th number in SR is the \u2028(|SL| + |Sv| + i)-th number in S.\nThus x* is the (k - |SL| - |Sv|)-th smallest integer in SR.\nZhiyi HuangCOMP3251A Divide and Conquer Selection Algorithm\n6\nSelect(S, k) Divide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    1)  If k \u2264 |SL|, output Select(SL, k).\u2028                   2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR27\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.", "mimetype": "text/plain", "start_char_idx": 4225, "end_char_idx": 5398, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "678b9544-a096-484f-8951-42aeba1888da": {"__data__": {"id_": "678b9544-a096-484f-8951-42aeba1888da", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f7d130bf-7c4b-42f8-b8b5-c6fe0cb6446e", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "005db225e0bd087368009ce39661c19623a11ebd325f990212e39f4a0fadf425", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "72f79cfd-419b-4797-8639-d6996e653bb1", "node_type": "1", "metadata": {}, "hash": "8c75599d0272a181ca943940860da43b3fddb454044330f658ad4b144b256e9e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR27\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR27\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR7327\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR7327\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR732744\n1)  If k \u2264 |SL|, output Select(SL, k).", "mimetype": "text/plain", "start_char_idx": 5199, "end_char_idx": 6165, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "72f79cfd-419b-4797-8639-d6996e653bb1": {"__data__": {"id_": "72f79cfd-419b-4797-8639-d6996e653bb1", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "678b9544-a096-484f-8951-42aeba1888da", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "195540b0863dafb89dcf1a88cc0f713c7360c372cdf4502fc61e1d3b23dd13da", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "23e6fd71-cdce-4692-abcc-b6aed1f211fc", "node_type": "1", "metadata": {}, "hash": "b6f8caf557a0081675078849438ed8a065fae1aa99c217ddcb0c962b4123ba59", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR732744\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR732744\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR73274434\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR73274434\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).", "mimetype": "text/plain", "start_char_idx": 5962, "end_char_idx": 6882, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "23e6fd71-cdce-4692-abcc-b6aed1f211fc": {"__data__": {"id_": "23e6fd71-cdce-4692-abcc-b6aed1f211fc", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "72f79cfd-419b-4797-8639-d6996e653bb1", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "25e4e0afd9465f1e6c778d2e35ff8c8913fbb3782fc6c4b524d573c0b0187fab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "88ffe720-91ce-41b8-9c24-2d80123ae8c7", "node_type": "1", "metadata": {}, "hash": "1306492bbe5a24c1ecf5a0b6b9d903fa2cd94d2c399fbf7a1d39760d5ca480af", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR7327443418\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR7327443418\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR732744341829\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR732744341829\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).", "mimetype": "text/plain", "start_char_idx": 6782, "end_char_idx": 7718, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "88ffe720-91ce-41b8-9c24-2d80123ae8c7": {"__data__": {"id_": "88ffe720-91ce-41b8-9c24-2d80123ae8c7", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "23e6fd71-cdce-4692-abcc-b6aed1f211fc", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "861356d62cc1f7aa4391f7e8f01288b05bce14515dc087b0d445aefaa681a91c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "00e18875-47bd-4eb7-bfcf-f456519fb6e4", "node_type": "1", "metadata": {}, "hash": "20afbb8fb35a6cabca52ec4eaf051a75d2ea5c44ba36646af7b4cde9add8bc45", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n7734434182927level 1SvSSLSR732744341829\u2022|SL| = 1\n\u2022|Sv| = 1\n\u2022k = 3 > |SL| + |Sv| and k - |SL| + |Sv| = 1\n\u2022So x* is the 1st number is SR.\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR29\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).", "mimetype": "text/plain", "start_char_idx": 7618, "end_char_idx": 8464, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "00e18875-47bd-4eb7-bfcf-f456519fb6e4": {"__data__": {"id_": "00e18875-47bd-4eb7-bfcf-f456519fb6e4", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88ffe720-91ce-41b8-9c24-2d80123ae8c7", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "96a8b7ea3abc70e8fb70166ac7aee47fc5bcb82281919a5f3f6f4f6af857f649", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "550bb27f-78dc-45a7-829d-f1cf21831dda", "node_type": "1", "metadata": {}, "hash": "735b4eda38e4f8466d843c3eee0b3fc8c4d0c5b7ff8e20066945530d34333166", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR29\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR2973\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR2973\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR297344\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.", "mimetype": "text/plain", "start_char_idx": 8364, "end_char_idx": 9296, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "550bb27f-78dc-45a7-829d-f1cf21831dda": {"__data__": {"id_": "550bb27f-78dc-45a7-829d-f1cf21831dda", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "00e18875-47bd-4eb7-bfcf-f456519fb6e4", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "a6a9313f75bf73ef2231dd1ba3698b4aaa78690181b4b0052af731cf8be48a1e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d137bc9b-2ad3-4420-b6f8-e9e545a5299f", "node_type": "1", "metadata": {}, "hash": "e6b3f61406863afcfee342e871d7fdca5f642329a0662093932707f09b9fbdef", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR297344\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR297344\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR29734434\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR29734434\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).", "mimetype": "text/plain", "start_char_idx": 9132, "end_char_idx": 10035, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d137bc9b-2ad3-4420-b6f8-e9e545a5299f": {"__data__": {"id_": "d137bc9b-2ad3-4420-b6f8-e9e545a5299f", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "550bb27f-78dc-45a7-829d-f1cf21831dda", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "36c8856c643e34f45fba93c471f578754bef6e9ede65fdcc347405cc05122179", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73024c29-f129-4631-bf9f-de3b16681178", "node_type": "1", "metadata": {}, "hash": "5c207d78fb9ef3375ed2296a1e25fceb5ac236f8f93b059e209833976d222a16", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Sample Run\n873443418292727level 1SS\u20197344342918level 2SvSLSR29734434\u2022|SL| = 0\n\u2022|Sv| = 1\n\u2022|SL| < k = 1 \u2264 |SL| + |Sv|\n\u2022So x* is in Sv and output x* = v = 29.\n1)  If k \u2264 |SL|, output Select(SL, k).\u20282)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u20283)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251What is the running time?\n9\nDivide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    1)  If k \u2264 |SL|, output Select(SL, k).\u2028                   2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251What is the running time?\n9\u2022Divide takes O(n) time.", "mimetype": "text/plain", "start_char_idx": 9935, "end_char_idx": 11000, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73024c29-f129-4631-bf9f-de3b16681178": {"__data__": {"id_": "73024c29-f129-4631-bf9f-de3b16681178", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d137bc9b-2ad3-4420-b6f8-e9e545a5299f", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "eeb2dbe78ea35b6425c008122cb77707d4001c5e4116a5b0b0e2622d57507735", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f092208e-9812-4910-8693-793b259505a5", "node_type": "1", "metadata": {}, "hash": "5c8482c79ebe09318a4e5e8b1dbe7ef7b0aaae71e84ac4a75e93f5fda77e0d9c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251What is the running time?\n9\u2022Divide takes O(n) time.\nDivide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    1)  If k \u2264 |SL|, output Select(SL, k).\u2028                   2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251What is the running time?\n9\u2022Divide takes O(n) time.\u2022Recurse takes either T(|SL|) time (case 1), or O(1) time (case 2), or T(|SR|) time (case 3).\nDivide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    1)  If k \u2264 |SL|, output Select(SL, k).\u2028                   2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).", "mimetype": "text/plain", "start_char_idx": 10810, "end_char_idx": 12230, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f092208e-9812-4910-8693-793b259505a5": {"__data__": {"id_": "f092208e-9812-4910-8693-793b259505a5", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73024c29-f129-4631-bf9f-de3b16681178", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "b9c089b145c37b27140acf1bd1c992fbc029d12ba02909403f516cb7947092fa", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "17100df4-e384-4536-ae14-0232c2e8f3d3", "node_type": "1", "metadata": {}, "hash": "e1d33900ba9266cca9dc184a72ba86c9edac8300c73a64ce221616b6c82cf0bd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251What is the running time?\n9\u2022Divide takes O(n) time.\u2022Recurse takes either T(|SL|) time (case 1), or O(1) time (case 2), or T(|SR|) time (case 3).\u2022Note that both |SL| and |SR| are at most n-1. So we have:T(n) \u2264 T(n-1) + O(n) \u2264 T(n-2) + O(n-1) + O(n) = \u2026 = O(1 + 2 + \u2026 + n) = O(n2)\nDivide:        Pick an arbitrary value v among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    1)  If k \u2264 |SL|, output Select(SL, k).\u2028                   2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Is it really that bad?\n10\nZhiyi HuangCOMP3251Is it really that bad?\u2022Yes, if we are extremely unlucky, and pick either the smallest or largest number as v in every round.", "mimetype": "text/plain", "start_char_idx": 12111, "end_char_idx": 13250, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "17100df4-e384-4536-ae14-0232c2e8f3d3": {"__data__": {"id_": "17100df4-e384-4536-ae14-0232c2e8f3d3", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f092208e-9812-4910-8693-793b259505a5", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "e5d6c4bdec5e5feb0d1659ac085ecbec48ac1192a1401988221e25e71b7ffb2d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f30d9b5f-a1e2-468b-b7e6-c98b239afd1f", "node_type": "1", "metadata": {}, "hash": "8df5879f3e0da538b060be0956dec06e9c81cdd912ddc54e48e1e27c15bf9733", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251Is it really that bad?\n10\nZhiyi HuangCOMP3251Is it really that bad?\u2022Yes, if we are extremely unlucky, and pick either the smallest or largest number as v in every round.\n10\nZhiyi HuangCOMP3251Is it really that bad?\u2022Yes, if we are extremely unlucky, and pick either the smallest or largest number as v in every round.\u2022But, if we are extremely lucky, and pick the n/2 smallest every time, then \n10\nZhiyi HuangCOMP3251Is it really that bad?\u2022Yes, if we are extremely unlucky, and pick either the smallest or largest number as v in every round.\u2022But, if we are extremely lucky, and pick the n/2 smallest every time, then T(n) = T(n/2) + O(n) = T(n/4) + O(n/2) + O(n) = \u2026 = O(n).\n10\nZhiyi HuangCOMP3251Is it really that bad?\u2022Yes, if we are extremely unlucky, and pick either the smallest or largest number as v in every round.\u2022But, if we are extremely lucky, and pick the n/2 smallest every time, then T(n) = T(n/2) + O(n) = T(n/4) + O(n/2) + O(n) = \u2026 = O(n).\u2022In reality, we cannot be that lucky; on the other hand, we may not be that unlucky to always pick the extreme numbers.\n10\nZhiyi HuangCOMP3251Is it really that bad?\u2022Yes, if we are extremely unlucky, and pick either the smallest or largest number as v in every round.\u2022But, if we are extremely lucky, and pick the n/2 smallest every time, then T(n) = T(n/2) + O(n) = T(n/4) + O(n/2) + O(n) = \u2026 = O(n).\u2022In reality, we cannot be that lucky; on the other hand, we may not be that unlucky to always pick the extreme numbers.", "mimetype": "text/plain", "start_char_idx": 13002, "end_char_idx": 14551, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f30d9b5f-a1e2-468b-b7e6-c98b239afd1f": {"__data__": {"id_": "f30d9b5f-a1e2-468b-b7e6-c98b239afd1f", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "17100df4-e384-4536-ae14-0232c2e8f3d3", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "659c5d3d1b27c80c54a8188b26479f86372eb46416cfb35caadb67256492f51a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0998b92a-3ee6-4e15-af08-b7c3970e497f", "node_type": "1", "metadata": {}, "hash": "da7bf79f52c8bedcb806135a0543e313a435e3f53e3dba2e0c4fc726a299193f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "10\nIdea:  Choose v randomly and hope that v is \u2028           \u201creasonably good\u201d on average?\nZhiyi HuangCOMP3251A Randomized Divide and Conquer \u2028Selection Algorithm\n11\nSelect(S, k) Divide:        Pick value v randomly among x1, x2, \u2026 , xn;\u2028                   Divide the input integers into three subsets:\u2028                   - SL: The subset of integers that are smaller than v;\u2028                   - Sv: The subset of integers that are equal to v;\u2028                   - SR: The subset of integers that are greater than v;\nRecurse:    1)  If k \u2264 |SL|, output Select(SL, k).\u2028                   2)  If |SL| < k \u2264 |SL| + |Sv|, output v.\u2028                   3)  If |SL| + |Sv| < k, output Select(SR, k - |SL| - |Sv|).\nZhiyi HuangCOMP3251What is \u201creasonably good\u201d?\n12|S|/2|S|/4|S|/4: \u201creasonably good\u201d: bad\nObservation 1:  In each round, v is \u201creasonably good\u201d with probability 1/2.\nObservation 2:  If v is always \u201creasonably good\u201d, then both \u2028|SL| and |SR| are at most 3n/4, and T(n)  = T(3n/4) + O(n) = O(n)!!\nZhiyi HuangCOMP3251Expected Running Time Analysis\n13\nIn each round, v is \u201creasonably good\u201d with probability 1/2.\nZhiyi HuangCOMP3251\u201cbad\u201d pivotExpected Running Time Analysis\n13\nIn each round, v is \u201creasonably good\u201d with probability 1/2.\u201creasonably good\u201d pivotET(n)\u226412(ET(3n4)+ET(n))+O(n)\nZhiyi HuangCOMP3251\u201cbad\u201d pivotExpected Running Time Analysis\n13\nIn each round, v is \u201creasonably good\u201d with probability 1/2.", "mimetype": "text/plain", "start_char_idx": 14552, "end_char_idx": 15962, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0998b92a-3ee6-4e15-af08-b7c3970e497f": {"__data__": {"id_": "0998b92a-3ee6-4e15-af08-b7c3970e497f", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f30d9b5f-a1e2-468b-b7e6-c98b239afd1f", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "3e43dceb6b652cb2f604d704eaa161429f1d6474f54254cf449c6c9ab14b24e8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5ce26c8f-6c5d-48a1-9077-28e6ca23ef0d", "node_type": "1", "metadata": {}, "hash": "5ed61f723a3feaf1d0cf75fb1dbc17bd1ae4d56ae70110106407ef2a33d8b2fc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251\u201cbad\u201d pivotExpected Running Time Analysis\n13\nIn each round, v is \u201creasonably good\u201d with probability 1/2.\u201creasonably good\u201d pivotET(n)\u226412(ET(3n4)+ET(n))+O(n)\nZhiyi HuangCOMP3251\u201cbad\u201d pivotExpected Running Time Analysis\n13\nIn each round, v is \u201creasonably good\u201d with probability 1/2.\u201creasonably good\u201d pivotET(n)\u226412(ET(3n4)+ET(n))+O(n)\u2022Rearranging all  terms to the left:ET(n)ET(n)\u2264ET(3n4)+O(n)\nZhiyi HuangCOMP3251\u201cbad\u201d pivotExpected Running Time Analysis\n13\nIn each round, v is \u201creasonably good\u201d with probability 1/2.\u201creasonably good\u201d pivotET(n)\u226412(ET(3n4)+ET(n))+O(n)\u2022Rearranging all  terms to the left:ET(n)ET(n)\u2264ET(3n4)+O(n)\u2022Viewing  as a function of n, Master Theorem gives:ET(n)ET(n)=O(n)\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general, we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general,", "mimetype": "text/plain", "start_char_idx": 15664, "end_char_idx": 16672, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5ce26c8f-6c5d-48a1-9077-28e6ca23ef0d": {"__data__": {"id_": "5ce26c8f-6c5d-48a1-9077-28e6ca23ef0d", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0998b92a-3ee6-4e15-af08-b7c3970e497f", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "e7aaf3e241e46080de3aeb01ce5957546d89841aedb346288ebb7adb24c8b424", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "12f99cdb-0691-4192-bb22-92ae465ae961", "node_type": "1", "metadata": {}, "hash": "1b9fb7d41eaf95c5381124f6f4e53f4ecc809aa8c5f159c072a574332ef812da", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general, we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\u2022The expected (average) running time is       E[ T(n) ] = E[ (time to reduce the array to \u2264 3n/4) + T(3n/4) ]                    = E[ (time to reduce the array to \u2264 3n/4) ] + E[ T(3n/4) ]\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general, we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\u2022The expected (average) running time is       E[ T(n) ] = E[ (time to reduce the array to \u2264 3n/4) + T(3n/4) ]                    = E[ (time to reduce the array to \u2264 3n/4) ] + E[ T(3n/4) ]\u2022Since v is \u201creasonably good\u201d with probability 1/2 each round, by Discrete Mathematics, the algorithm gets a \u201creasonably good\u201d v in every two rounds on average.\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general,", "mimetype": "text/plain", "start_char_idx": 16500, "end_char_idx": 17552, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "12f99cdb-0691-4192-bb22-92ae465ae961": {"__data__": {"id_": "12f99cdb-0691-4192-bb22-92ae465ae961", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5ce26c8f-6c5d-48a1-9077-28e6ca23ef0d", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "eab9765f3ff9908faf86dd3ee26a1dcb4167c5afa9b805ee798654e2bfed8be3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "db44c17f-c453-4a12-a419-49aa13d01182", "node_type": "1", "metadata": {}, "hash": "892e6f6f8f611e4045372e3abc380f8a6c444eb2ba1a60741f0c0a97642d1207", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "by Discrete Mathematics, the algorithm gets a \u201creasonably good\u201d v in every two rounds on average.\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general, we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\u2022The expected (average) running time is       E[ T(n) ] = E[ (time to reduce the array to \u2264 3n/4) + T(3n/4) ]                    = E[ (time to reduce the array to \u2264 3n/4) ] + E[ T(3n/4) ]\u2022Since v is \u201creasonably good\u201d with probability 1/2 each round, by Discrete Mathematics, the algorithm gets a \u201creasonably good\u201d v in every two rounds on average.\u2022Since process one v takes O(n) time, we conclude thatE[ (time to reduce the array to \u2264 3n/4) ] = O(n)\n14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general, we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\u2022The expected (average) running time is       E[ T(n) ] = E[ (time to reduce the array to \u2264 3n/4) + T(3n/4) ]                    = E[ (time to reduce the array to \u2264 3n/4) ] + E[ T(3n/4) ]\u2022Since v is \u201creasonably good\u201d with probability 1/2 each round, by Discrete Mathematics, the algorithm gets a \u201creasonably good\u201d v in every two rounds on average.\u2022Since process one v takes O(n) time, we conclude thatE[ (time to reduce the array to \u2264 3n/4) ] = O(n)\u2022So E[ T(n) ] = O(n) + E[ T(3n/4) ].14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general,", "mimetype": "text/plain", "start_char_idx": 17384, "end_char_idx": 18831, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "db44c17f-c453-4a12-a419-49aa13d01182": {"__data__": {"id_": "db44c17f-c453-4a12-a419-49aa13d01182", "embedding": null, "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "5cf46890-de49-46f0-8f22-4bbb95a5e604", "node_type": "4", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "2c242680d2792ea4bcf06ac0cd9e8a9a844ffecce9cf37c19af452bdddaa423e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "12f99cdb-0691-4192-bb22-92ae465ae961", "node_type": "1", "metadata": {"file_name": "S04 Selection_processed.txt", "source_file": "S04 Selection", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S04 Selection_processed.txt"}, "hash": "da4781684ccfa4747e8793c935d5ca6268e6b6c1d227c688240b8f403d2fc578", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "by Discrete Mathematics, the algorithm gets a \u201creasonably good\u201d v in every two rounds on average.\u2022Since process one v takes O(n) time, we conclude thatE[ (time to reduce the array to \u2264 3n/4) ] = O(n)\u2022So E[ T(n) ] = O(n) + E[ T(3n/4) ].14\nZhiyi HuangCOMP3251Alternative Analysis (from Textbook)\u2022In general, we can reason about the running time as follows:T(n) = (time to reduce the array to \u2264 3n/4) + T(3n/4)\u2022The expected (average) running time is       E[ T(n) ] = E[ (time to reduce the array to \u2264 3n/4) + T(3n/4) ]                    = E[ (time to reduce the array to \u2264 3n/4) ] + E[ T(3n/4) ]\u2022Since v is \u201creasonably good\u201d with probability 1/2 each round, by Discrete Mathematics, the algorithm gets a \u201creasonably good\u201d v in every two rounds on average.\u2022Since process one v takes O(n) time, we conclude thatE[ (time to reduce the array to \u2264 3n/4) ] = O(n)\u2022So E[ T(n) ] = O(n) + E[ T(3n/4) ].\u2022Let E[ T(n) ] = A(n), we have A(n) = A(3n/4) + O(n) = \u2026 = O(n).14", "mimetype": "text/plain", "start_char_idx": 18526, "end_char_idx": 19484, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2b614eb8-8b85-459d-a695-93c185d8be3e": {"__data__": {"id_": "2b614eb8-8b85-459d-a695-93c185d8be3e", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c82cb3b9-f60b-42db-be19-0fd6da899349", "node_type": "1", "metadata": {}, "hash": "78e9a120a85e0ebbe95003eb702ab5e3ecc0e0665e5a9ef19031d41d13ad91f1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 5: Fast Multiplication \u2028(Chapter 2.1 and 2.5)\nZhiyi HuangCOMP3251The divide-and-conquer algorithm design paradigm solves a problem as follows:\n1)Divide:  Breaking the problem into subproblems that are themselves smaller instances of the same type of problem;  \n2)Recurse:  Recursively solving these subproblems;\n3)Combine:  Appropriately combining their answers to get an answer of the original problem.\nNote:  If the size of a subproblem is small enough, we will stop using the divide-and-conquer strategy; instead, we may solve the subproblem by brute-force.\nRecall Divide and Conquer (Ch. 2)\n2\nZhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nWarm-up:  The straightforward algorithm runs in O(n2) time.\n31011\u2a09011000001011101100001000010n steps per row for \u2028either copying 1011 \u2028or writing down 0000n rows in totalroughly n steps for calculating each bit in the \ufb01nal result,\u2028and there are 2n-1 bits in total\nZhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nMethod:  Use divide and conquer to design an algorithm for integer multiplication with running time faster than O(n2).\n4\nZhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nMethod:  Use divide and conquer to design an algorithm for integer multiplication with running time faster than O(n2).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1639, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c82cb3b9-f60b-42db-be19-0fd6da899349": {"__data__": {"id_": "c82cb3b9-f60b-42db-be19-0fd6da899349", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2b614eb8-8b85-459d-a695-93c185d8be3e", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "3847938937354ec22f2ee3fd269676ff7cd98d449fd09d16802ff3e6b3d5af54", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c80c69e2-3787-4796-9ff6-2acb10c37ffe", "node_type": "1", "metadata": {}, "hash": "a0b84fed1b94f19988836a2113f10f2c00df5861da325e98cf2d0bbc07bedf8f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "4\nZhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nMethod:  Use divide and conquer to design an algorithm for integer multiplication with running time faster than O(n2).\nFact:  Any n-bit binary integer x = (xn xn-1 \u2026 x1)2 can be decomposed into two n/2-bit binary integers xL = (xn \u2026 xn/2+1)2 and xR = (xn/2 \u2026 x1)2 such that x = xL \u2a09 2n/2 + xR.\n4\nZhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nMethod:  Use divide and conquer to design an algorithm for integer multiplication with running time faster than O(n2).\nFact:  Any n-bit binary integer x = (xn xn-1 \u2026 x1)2 can be decomposed into two n/2-bit binary integers xL = (xn \u2026 xn/2+1)2 and xR = (xn/2 \u2026 x1)2 such that x = xL \u2a09 2n/2 + xR.\n4Note:  We don't need to do any multiplication here; we may simply shift xL n/2 positions left, or pad it with n/2 zeros.\nZhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nMethod:  Use divide and conquer to design an algorithm for integer multiplication with running time faster than O(n2).", "mimetype": "text/plain", "start_char_idx": 1345, "end_char_idx": 2699, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c80c69e2-3787-4796-9ff6-2acb10c37ffe": {"__data__": {"id_": "c80c69e2-3787-4796-9ff6-2acb10c37ffe", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c82cb3b9-f60b-42db-be19-0fd6da899349", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "69a64a2e4c72411e3cc008654af46c5b6113e32a07e9564cd0ba0d3610a2db42", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8f50ef58-085e-4436-bd24-9be02ece8b4b", "node_type": "1", "metadata": {}, "hash": "b4c311a8c73bb9706b2481514f2cd14a5aa0f9f21a7a2623ebce116d9dee5db9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nMethod:  Use divide and conquer to design an algorithm for integer multiplication with running time faster than O(n2).\nFor example, (1011)2 = 1 \u2a09 23 + 0 \u2a09 22 + 1 \u2a09 21 + 1 \u2a09 20\u2028                                  = (1 \u2a09 21 + 0 \u2a09 20) \u2a09 22 + 1 \u2a09 21 + 1 \u2a09 20\u2028                                  = (10)2 \u2a09 22 + (11)2\nFact:  Any n-bit binary integer x = (xn xn-1 \u2026 x1)2 can be decomposed into two n/2-bit binary integers xL = (xn \u2026 xn/2+1)2 and xR = (xn/2 \u2026 x1)2 such that x = xL \u2a09 2n/2 + xR.\n4Note:  We don't need to do any multiplication here; we may simply shift xL n/2 positions left, or pad it with n/2 zeros.\nZhiyi HuangCOMP3251A Simple Divide and Conquer Algorithm\u2028for Integer MultiplicationInput:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nDivide:        Let x = xL \u2a09 2n/2 + xR and y = yL \u2a09 2n/2 + yR, \u2028                   where xL, xR, yL, yR are n/2-bit binary integers.\nRecurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.", "mimetype": "text/plain", "start_char_idx": 2407, "end_char_idx": 3643, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8f50ef58-085e-4436-bd24-9be02ece8b4b": {"__data__": {"id_": "8f50ef58-085e-4436-bd24-9be02ece8b4b", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c80c69e2-3787-4796-9ff6-2acb10c37ffe", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "fa2553e725d61349a2082ad7822d35ec9bf62c9f97fbd9bdd6b834b25318e1e1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ec898ac-395c-4b74-81e4-f926ff34c54b", "node_type": "1", "metadata": {}, "hash": "dc4d83a3e23eb333435bb50fa6078321acff72c1c52299088b61f15815a9dc2f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Recurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.\nCombine:   x y = (xL \u2a09 2n/2 + xR) (yL \u2a09 2n/2 + yR)\u2028                         = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yRRunning time:  T(n), total time for multiplying two n-bit integers.\n\u2022Computing 4 multiplications of n/2-bit integers: 4 T(n/2);\n\u2022Padding the results with zeros and adding them together: O(n).\nHence, T(n) = 4 T(n/2) + O(n).", "mimetype": "text/plain", "start_char_idx": 3534, "end_char_idx": 3987, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4ec898ac-395c-4b74-81e4-f926ff34c54b": {"__data__": {"id_": "4ec898ac-395c-4b74-81e4-f926ff34c54b", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8f50ef58-085e-4436-bd24-9be02ece8b4b", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "55902afaadcd25190f03282fd3d65ce5939e930c04b470b22aae9f9beb324b9a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0a4255e7-23db-4987-820c-371332918189", "node_type": "1", "metadata": {}, "hash": "b2ec751286422022018e6362ba0a233ce57028017765fc0d40c9edfa4be56d34", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Computing 4 multiplications of n/2-bit integers: 4 T(n/2);\n\u2022Padding the results with zeros and adding them together: O(n).\nHence, T(n) = 4 T(n/2) + O(n).\nZhiyi HuangCOMP3251What is T(n) = 4 T(n/2) + O(n)?Recall that O(n) \u2264 cn for some constant c. Hence,\n            T(n) \u2264 4 T(n/2) + cn\u2028                   \u2264 4 ( 4 T(n/22) + c(n/2) ) + cn \u2028                            = 42 T(n/22) + cn (2 + 1)\u2028                   \u2264 42 ( 4 T(n/23) + c(n/22) ) + cn (2+1) \u2028                            = 43 T(n/23) + cn (22+2+1)\u2028                   \u2264 \u2026\u2028                   \u2264 4k T(n/2k) + cn (2k-1 + \u2026 + 22 + 2 + 1) Note that when k = log2 n, we have 2k = n. Thus,\n            T(n) \u2264 4k T(n/2k) + cn (2k-1 + \u2026 + 22 + 2 + 1)\u2028                   = n2 T(1) + cn (2k - 1)/(2 - 1)\u2028                   = n2 T(1) + cn (n-1)\u2028                   = O(n2) We can also use Master Theorem to get the same result.6\nZhiyi HuangCOMP3251Can we do better?\n7Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.", "mimetype": "text/plain", "start_char_idx": 3833, "end_char_idx": 4812, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0a4255e7-23db-4987-820c-371332918189": {"__data__": {"id_": "0a4255e7-23db-4987-820c-371332918189", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4ec898ac-395c-4b74-81e4-f926ff34c54b", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "c889e40153548448d3d969c6634b4ff37d6f4cd9779aaa6a3798722686be3a18", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e85cb49-a08b-46b9-b012-2e924a8f12d5", "node_type": "1", "metadata": {}, "hash": "49ea6d671197f401f23b09d91b4462291276cd0200f4495fdbbada8e25be1b35", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "7Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nDivide:        Let x = xL \u2a09 2n/2 + xR and y = yL \u2a09 2n/2 + yR, \u2028                   where xL, xR, yL, yR are n/2-bit binary integers.\nRecurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.\nCombine:   x y = (xL \u2a09 2n/2 + xR) (yL \u2a09 2n/2 + yR)\u2028                         = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yR\nZhiyi HuangCOMP3251Can we do better?\n\u2022The combine step needs 3 terms: xL yL, xL yR + xR yL, and xR yR.\n7Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nDivide:        Let x = xL \u2a09 2n/2 + xR and y = yL \u2a09 2n/2 + yR, \u2028                   where xL, xR, yL, yR are n/2-bit binary integers.\nRecurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.", "mimetype": "text/plain", "start_char_idx": 4745, "end_char_idx": 5721, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0e85cb49-a08b-46b9-b012-2e924a8f12d5": {"__data__": {"id_": "0e85cb49-a08b-46b9-b012-2e924a8f12d5", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a4255e7-23db-4987-820c-371332918189", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "9f0b1a45685e4841bc9625b7341c092561afbd7ccc9835521f747b2ca6657cd4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cc2de2f8-7ff1-4d6d-a5f9-2ab6936db26f", "node_type": "1", "metadata": {}, "hash": "1f205d3a43783f3d2dba09ec51c0e62ec2b31c33f0d4dd71e7f014e063041e83", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Recurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.\nCombine:   x y = (xL \u2a09 2n/2 + xR) (yL \u2a09 2n/2 + yR)\u2028                         = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yR\nZhiyi HuangCOMP3251Can we do better?\n\u2022The combine step needs 3 terms: xL yL, xL yR + xR yL, and xR yR.\u2022The recurse step uses 4 multiplications to get the 3 terms.7Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nDivide:        Let x = xL \u2a09 2n/2 + xR and y = yL \u2a09 2n/2 + yR, \u2028                   where xL, xR, yL, yR are n/2-bit binary integers.\nRecurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.\nCombine:   x y = (xL \u2a09 2n/2 + xR) (yL \u2a09 2n/2 + yR)\u2028                         = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yR\nZhiyi HuangCOMP3251Can we do better?", "mimetype": "text/plain", "start_char_idx": 5612, "end_char_idx": 6540, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cc2de2f8-7ff1-4d6d-a5f9-2ab6936db26f": {"__data__": {"id_": "cc2de2f8-7ff1-4d6d-a5f9-2ab6936db26f", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e85cb49-a08b-46b9-b012-2e924a8f12d5", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "b5954308711ede4349f1f83a13b46c2fc265980b7e61a3196d2e38567ca78889", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6084fad-9b5c-468b-8565-5741b46fcf80", "node_type": "1", "metadata": {}, "hash": "c1bb2dfa81f352bf5d9c08e044026f6f073020153687039206e69f8bb75b0d7f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Combine:   x y = (xL \u2a09 2n/2 + xR) (yL \u2a09 2n/2 + yR)\u2028                         = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yR\nZhiyi HuangCOMP3251Can we do better?\n\u2022The combine step needs 3 terms: xL yL, xL yR + xR yL, and xR yR.\u2022The recurse step uses 4 multiplications to get the 3 terms.7Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nDivide:        Let x = xL \u2a09 2n/2 + xR and y = yL \u2a09 2n/2 + yR, \u2028                   where xL, xR, yL, yR are n/2-bit binary integers.\nRecurse:    Compute 4 multiplications of n/2-bit integers,\u2028                   xL yL, xL yR, xR yL, and xR yR.\nCombine:   x y = (xL \u2a09 2n/2 + xR) (yL \u2a09 2n/2 + yR)\u2028                         = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yR\nQuestion:  Can we use 3 multiplications to \ufb01nd the 3 terms?\nZhiyi HuangCOMP3251A Faster Divide and Conquer Algorithm\u2028for Integer Multiplication\n8Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.", "mimetype": "text/plain", "start_char_idx": 6382, "end_char_idx": 7375, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d6084fad-9b5c-468b-8565-5741b46fcf80": {"__data__": {"id_": "d6084fad-9b5c-468b-8565-5741b46fcf80", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cc2de2f8-7ff1-4d6d-a5f9-2ab6936db26f", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "4e0b1f334d3b5ff860da7d0b08e463393ecc3ca438c5ace41b8e5e116b857d13", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5d9a2c3-7718-4f58-a6a1-ac87db47bf1f", "node_type": "1", "metadata": {}, "hash": "a069920ae553228ec28f8dabe900e74be225db0e2718a4fe616367c207320796", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251A Faster Divide and Conquer Algorithm\u2028for Integer Multiplication\n8Input:  Two n-bit binary integers x, y, e.g., (1011)2 and (0110)2.\nOutput:  A (2n-1)-bit integer that equals the product of x and y.\nDivide:        Let x = xL \u2a09 2n/2 + xR and y = yL \u2a09 2n/2 + yR, \u2028                   where xL, xR, yL, yR are n/2-bit binary integers.\nRecurse:    Compute 3 multiplications of n/2-bit integers,\u2028                   xL yL, (xL + xR) (yL + yR), and xR yR.\nCombine:  Compute xL yR + xR yL = (xL + xR) (yL + yR) - xL yL - xR yR.\u2028                   Then, x y = xL yL \u2a09 2n + (xL yR + xR yL) \u2a09 2n/2 + xR yR.Running time: \nNote:  Actually, it should be T(n) = 2 T(n/2) + T(n/2+1) + O(n) because xL + xR and yL + yR could be (n/2+1)-bit integers, which also leads to T(n) = O(n1.59).T(n)=3T(n/2) +O(n)=O(nlog23)=O(n1.59)\nOptional: Matrix multiplication\nZhiyi HuangCOMP3251Matrix MultiplicationA 2\u2a092 matrix\nThe product of two 2\u2a092 matrices:\nThe product Z = (zij) of two n\u2a09n matrices X = (xij) and Y = (yjk) is:\n10\nRunning time:  Since Z has n2 entries, and computing each entry zij takes O(n) time.", "mimetype": "text/plain", "start_char_idx": 7224, "end_char_idx": 8324, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c5d9a2c3-7718-4f58-a6a1-ac87db47bf1f": {"__data__": {"id_": "c5d9a2c3-7718-4f58-a6a1-ac87db47bf1f", "embedding": null, "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ecda3066-4bf3-4294-be8b-bedf56ca2c23", "node_type": "4", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "8cd33bd372c89cb80296a8b767c537acf1048a703f333e9b15705ea699296567", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6084fad-9b5c-468b-8565-5741b46fcf80", "node_type": "1", "metadata": {"file_name": "S05 Fast Multiplication_processed.txt", "source_file": "S05 Fast Multiplication", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S05 Fast Multiplication_processed.txt"}, "hash": "2c87332f15c873a142930970bc8777d69d61d28176d90df52039b73beddd6e53", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "So O(n3) time in total to \ufb01nd Z = XY .Note:  Here, we assume that algorithm can add or multiply two numbers in constant time and count the number of additions/multiplications. \nZhiyi HuangCOMP3251A Simple Divide and Conquer \u2028Matrix Multiplication Algorithm\n11\n\u2028Key fact:  If                       and                      , then\nX, Y are n\u2a09n matrices, \u2028A, B, C, D, E, F, G, H are n/2 \u2a09 n/2 matrices.\nDivide:        Decompose X and Y each into four n/2 \u2a09 n/2 \u2028                   matrices as above, namely, A, B, C, D, E, F , G, H.\nRecurse:    Compute 8 multiplications of n/2 \u2a09 n/2 matrices,\u2028                   AE, BG, AF , BH, CE, DG, CF , DH.\nCombine:   Add them as above to get XY .Running time:  T(n) = 8 T(n/2) + O(n2) = O(n3).\nZhiyi HuangCOMP3251Strassen\u2019s Magical Idea\nSo, the running time becomes12\n\u2028Divide:        Decompose X and Y into two n/2\u2a09n/2 matrices\u2028                   as above, namely, A, B, C, D, E, F , G, H.\nRecurse:    Compute 7 multiplications of n/2\u2a09n/2 matrices,\u2028                   P1 = A(F-H), P2 = (A+B)H, P3 = (C+D)E, P4 = D(G-E), \u2028                   P5 = (A+D)(E+H), P6 = (B-D)(G+H), P7 = (A-C)(E+F).\nCombine:   Add them as above to get XY as follows:", "mimetype": "text/plain", "start_char_idx": 8325, "end_char_idx": 9504, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "da57b87f-aeb6-4ec2-9b07-333d63cc63f6": {"__data__": {"id_": "da57b87f-aeb6-4ec2-9b07-333d63cc63f6", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "34b24aa1-1182-493e-abb8-b9ecd31a0ea1", "node_type": "1", "metadata": {}, "hash": "c0f7da6716a444d21b85c9e2ee34eb309ccde00fe84e7c85152a6850ee253c6b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 6: Closest Pair\nZhiyi HuangCOMP3251Closest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nZhiyi HuangCOMP3251Closest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nA straight-forward closest algorithm: 1)Compute the distance of all n(n-1)/2 pairs of distinct points.\n2)Output the pair whose distance is smallest.\nZhiyi HuangCOMP3251Closest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nA straight-forward closest algorithm: 1)Compute the distance of all n(n-1)/2 pairs of distinct points.\n2)Output the pair whose distance is smallest.\nZhiyi HuangCOMP3251Closest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nA straight-forward closest algorithm: 1)Compute the distance of all n(n-1)/2 pairs of distinct points.\n2)Output the pair whose distance is smallest.1065699\nZhiyi HuangCOMP3251\nClosest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nA straight-forward closest algorithm: 1)Compute the distance of all n(n-1)/2 pairs of distinct points.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1425, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "34b24aa1-1182-493e-abb8-b9ecd31a0ea1": {"__data__": {"id_": "34b24aa1-1182-493e-abb8-b9ecd31a0ea1", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "da57b87f-aeb6-4ec2-9b07-333d63cc63f6", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "26678ade94b2844d2af8e92a78fab2dd63d5437e3b4c607fb3f0af1369055554", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f1eca6a0-2634-4dab-ad7d-4666d9adf0a4", "node_type": "1", "metadata": {}, "hash": "506da12216d5d9bff74b696586c4c53e605ff5245f2f3fca0aff807d40dfbe09", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)Output the pair whose distance is smallest.1065699\nZhiyi HuangCOMP3251\nClosest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nA straight-forward closest algorithm: 1)Compute the distance of all n(n-1)/2 pairs of distinct points.\n2)Output the pair whose distance is smallest.1065699\nZhiyi HuangCOMP3251\nClosest PairInput:  A set of n points in a plane (x1, y1), (x2, y2), \u2026 , (xn, yn).\nOutput:  A pair of distinct points whose distance is smallest.\n2\nA straight-forward closest algorithm: 1)Compute the distance of all n(n-1)/2 pairs of distinct points.\n2)Output the pair whose distance is smallest.\nRunning time: O(n2)1065699\nZhiyi HuangCOMP3251Is it possible to do any better?\n3\nZhiyi HuangCOMP3251\n35726836Is it possible to do any better?\n3\nZhiyi HuangCOMP3251\n35726836Is it possible to do any better?\u2022If all points are on the same line, we can \ufb01rst sort them and then check only the n - 1 neighboring pairs.\n3\nZhiyi HuangCOMP3251\n35726836Is it possible to do any better?\u2022If all points are on the same line, we can \ufb01rst sort them and then check only the n - 1 neighboring pairs.\u2022This takes O(n log n) time.\n3\nZhiyi HuangCOMP3251\n35726836Is it possible to do any better?\u2022If all points are on the same line, we can \ufb01rst sort them and then check only the n - 1 neighboring pairs.\u2022This takes O(n log n) time.\n3\nIdea:  If some pairs of points are obviously too far, then we can simply ignore them.", "mimetype": "text/plain", "start_char_idx": 1102, "end_char_idx": 2591, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f1eca6a0-2634-4dab-ad7d-4666d9adf0a4": {"__data__": {"id_": "f1eca6a0-2634-4dab-ad7d-4666d9adf0a4", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "34b24aa1-1182-493e-abb8-b9ecd31a0ea1", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "79e6836b1eb8e08e3c715d9d65f81933f2656cf89597c50fed6425e6ac24b6ac", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ba090a84-1424-46ce-a9b9-12ce64cb5bbe", "node_type": "1", "metadata": {}, "hash": "d4437317efa2f5a10e0bd1eb78e0735aa26002e9e11a6b81a2941b7ef5b7e299", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3\nZhiyi HuangCOMP3251\n35726836Is it possible to do any better?\u2022If all points are on the same line, we can \ufb01rst sort them and then check only the n - 1 neighboring pairs.\u2022This takes O(n log n) time.\n3\nIdea:  If some pairs of points are obviously too far, then we can simply ignore them.\nZhiyi HuangCOMP3251A Divide and Conquer Algorithm for Closest PairDivide:  Sort the points by their x-coordinates.\u2028              Draw a vertical line L so that n/2 points on each side.\nAssumption (for ease of discussion):  No two points have same x-coordinate.\n4y-axis\nx-axisn/2 pointsn/2 points\nZhiyi HuangCOMP3251Recurse:  Find the closest pair on each side.\n545A Divide and Conquer Algorithm for Closest Pairy-axis\nx-axis\nZhiyi HuangCOMP3251Recurse:  Find the closest pair on each side.Combine:  Find the closest pair with one point on each side.\u2028                   Output the closest of the three pairs.\n5456A Divide and Conquer Algorithm for Closest Pairy-axis\nx-axis\nZhiyi HuangCOMP3251\nRecurse:  Find the closest pair on each side.Combine:  Find the closest pair with one point on each side.\u2028                   Output the closest of the three pairs.\n5456A Divide and Conquer Algorithm for Closest Pairy-axis\nx-axis\nZhiyi HuangCOMP3251\nRecurse:  Find the closest pair on each side.Combine:  Find the closest pair with one point on each side.\u2028                   Output the closest of the three pairs.\n5456\nQuestion: How?", "mimetype": "text/plain", "start_char_idx": 2306, "end_char_idx": 3717, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ba090a84-1424-46ce-a9b9-12ce64cb5bbe": {"__data__": {"id_": "ba090a84-1424-46ce-a9b9-12ce64cb5bbe", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f1eca6a0-2634-4dab-ad7d-4666d9adf0a4", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "c2b159a7ec6e435575b0c67b7b75a825daafeb02e8c7c44d6611f3cc720f6fae", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "63ccce18-eac9-463d-bdff-3b2326e61c31", "node_type": "1", "metadata": {}, "hash": "1568cdb16daac640b866fc0d75c58b29f17418400eea58f3dab2ce78019d7d78", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Output the closest of the three pairs.\n5456A Divide and Conquer Algorithm for Closest Pairy-axis\nx-axis\nZhiyi HuangCOMP3251\nRecurse:  Find the closest pair on each side.Combine:  Find the closest pair with one point on each side.\u2028                   Output the closest of the three pairs.\n5456\nQuestion: How? What is the running time?A Divide and Conquer Algorithm for Closest Pairy-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n6y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n6A straightforward brute-force approach:  Compare all (n/2)2 pairs with one point on each side, and return the smallest one.y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n6A straightforward brute-force approach:  Compare all (n/2)2 pairs with one point on each side, and return the smallest one.1) Divide takes O(n log n) time; 2) Recurse takes 2 T(n/2) time; \u20283) Combine takes O(n2) time. So T(n) = 2 T(n/2) + O(n2) = O(n2).y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n7Let \u03b4L and \u03b4R be the distance of the closest pairs on the left and on the right respectively.  Let \u03b4 = min (\u03b4L, \u03b4R).y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n7Let \u03b4L and \u03b4R be the distance of the closest pairs on the left and on the right respectively.", "mimetype": "text/plain", "start_char_idx": 3410, "end_char_idx": 4750, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "63ccce18-eac9-463d-bdff-3b2326e61c31": {"__data__": {"id_": "63ccce18-eac9-463d-bdff-3b2326e61c31", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ba090a84-1424-46ce-a9b9-12ce64cb5bbe", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "b0cf0fbf61357b21d4db3560b50102c7c5e2d533f24e872bb33bb762ed978d0a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0a89c82e-e0d6-459e-9155-1be2b62f1f9d", "node_type": "1", "metadata": {}, "hash": "90befede990b314c942f8f531c634ea106236299e822577fd09d47434e7490fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Let \u03b4 = min (\u03b4L, \u03b4R).y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n7Let \u03b4L and \u03b4R be the distance of the closest pairs on the left and on the right respectively.  Let \u03b4 = min (\u03b4L, \u03b4R).Example:  \u03b4L = 4, \u03b4R = 5, and \u03b4 = 4.45y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n7Let \u03b4L and \u03b4R be the distance of the closest pairs on the left and on the right respectively.  Let \u03b4 = min (\u03b4L, \u03b4R).Example:  \u03b4L = 4, \u03b4R = 5, and \u03b4 = 4.Idea:  Focus on pairs with one point in each side and has distance < \u03b4.45y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8\nNote:  We only need to consider points within \u03b4 of the dividing line.\u03b4\u03b4y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8\nNote:  We only need to consider points within \u03b4 of the dividing line.1)Sort points in the 2\u03b4-strip in ascending order of the y-coordinate.\u03b4\u03b4y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8\nNote:  We only need to consider points within \u03b4 of the dividing line.1)Sort points in the 2\u03b4-strip in ascending order of the y-coordinate.2)For each point a, check the distances to its 7 subsequent points.\u03b4\u03b4\na1234567y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8\nNote:  We only need to consider points within \u03b4 of the dividing line.1)Sort points in the 2\u03b4-strip in ascending order of the y-coordinate.2)For each point a,", "mimetype": "text/plain", "start_char_idx": 4561, "end_char_idx": 6074, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0a89c82e-e0d6-459e-9155-1be2b62f1f9d": {"__data__": {"id_": "0a89c82e-e0d6-459e-9155-1be2b62f1f9d", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63ccce18-eac9-463d-bdff-3b2326e61c31", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "aac0ec80043ddf54a6758a5d30d82c6fd144d59284703e9186d5dd002b89152d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5608d51c-72c4-4783-968c-827c9fff8828", "node_type": "1", "metadata": {}, "hash": "af7384a71e014611ed17901be5ed5af21ab35ac0c9f1461baa33fcc430bc75eb", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)For each point a, check the distances to its 7 subsequent points.\u03b4\u03b4\na1234567y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8\nNote:  We only need to consider points within \u03b4 of the dividing line.1)Sort points in the 2\u03b4-strip in ascending order of the y-coordinate.2)For each point a, check the distances to its 7 subsequent points.3)Output the closest pair found in step 2.\u03b4\u03b4\na1234567y-axis\nx-axis\nZhiyi HuangCOMP3251Closest pair with one point on each side\n8\nNote:  We only need to consider points within \u03b4 of the dividing line.1)Sort points in the 2\u03b4-strip in ascending order of the y-coordinate.2)For each point a, check the distances to its 7 subsequent points.3)Output the closest pair found in step 2.\u03b4\u03b4\na1234567y-axis\nx-axis\nRunning time: O(n log n)\nZhiyi HuangCOMP3251Why is it correct?\n9y axis\nx axis\u2022Let a and b be a pair of points with one point on each side such that their distance is \u2264 \u03b4, and a is lower than b in the y-coordinate.\n\u2022We will prove that b is among the 7 subsequent points of a in the sorted list, i.e., b \u2208 {1, 2, 3, 4, 5, 6, 7}. Then, the algorithm would have checked and remembered their distance in step 2.\u03b4\u03b4\na1234567\nZhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\n\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.", "mimetype": "text/plain", "start_char_idx": 5763, "end_char_idx": 7149, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5608d51c-72c4-4783-968c-827c9fff8828": {"__data__": {"id_": "5608d51c-72c4-4783-968c-827c9fff8828", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a89c82e-e0d6-459e-9155-1be2b62f1f9d", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "85356600981759ad462211d791b8a049f3f252b21cc92022d9f1633e24bd54eb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cdd33744-b8d7-4a84-a363-ea73aca9be2e", "node_type": "1", "metadata": {}, "hash": "eabfb24a2b5038c7b087f43730430844c54cf18c7af9d3a8e3b7fefb8e132060", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.\n10\nZhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\n\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.\n10\u03b4\u03b41)Consider any square of size \u03b4 \u2028on the left the dividing line\nZhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\n\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.\n10\u03b4\u03b41)Consider any square of size \u03b4 \u2028on the left the dividing line2)Divide the square into 4 \u2028sub-squares of size \u03b4/2\u03b4/2\u03b4/2\u03b4/2\u03b4/2\nZhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\n\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.\n10\u03b4\u03b41)Consider any square of size \u03b4 \u2028on the left the dividing line2)Divide the square into 4 \u2028sub-squares of size \u03b4/2\u03b4/2\u03b4/2\u03b4/2\u03b4/2\n3)Points in the same sub-square are at most                         apart.", "mimetype": "text/plain", "start_char_idx": 7100, "end_char_idx": 8181, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cdd33744-b8d7-4a84-a363-ea73aca9be2e": {"__data__": {"id_": "cdd33744-b8d7-4a84-a363-ea73aca9be2e", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5608d51c-72c4-4783-968c-827c9fff8828", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "b97fc83672a1e53677a1af99c0b86fe640658c9d60201dd4021143875d722e09", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "db1f6153-a92e-4ef3-9838-673493bd84cb", "node_type": "1", "metadata": {}, "hash": "c3a6aac49b9fa5e8f984b907f33f5c9a0902b86c69991f3cf6464104527f0d1c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.\n10\u03b4\u03b41)Consider any square of size \u03b4 \u2028on the left the dividing line2)Divide the square into 4 \u2028sub-squares of size \u03b4/2\u03b4/2\u03b4/2\u03b4/2\u03b4/2\n3)Points in the same sub-square are at most                         apart.\n\nZhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\n\u2022Why? Recall that \u03b4 = min (\u03b4L, \u03b4R). Thus, \u03b4 \u2264 \u03b4L.\n10\u03b4\u03b41)Consider any square of size \u03b4 \u2028on the left the dividing line2)Divide the square into 4 \u2028sub-squares of size \u03b4/2\u03b4/2\u03b4/2\u03b4/2\u03b4/24)Points on the left of the dividing line are at least \u03b4L apart. So there are \u2264 1 point in each sub-square, and \u2264 4 points in the square.\n3)Points in the same sub-square are at most                         apart.\n\nZhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\nObservation 2:  There are at most 4 points in any square of size \u03b4 on the right of the dividing line.", "mimetype": "text/plain", "start_char_idx": 7927, "end_char_idx": 8995, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "db1f6153-a92e-4ef3-9838-673493bd84cb": {"__data__": {"id_": "db1f6153-a92e-4ef3-9838-673493bd84cb", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cdd33744-b8d7-4a84-a363-ea73aca9be2e", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "3f57526b2e98d645bf9b9799af910f871604906a26a6179d315b495f4a390675", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8fa1043e-3974-43a4-9fd8-f11c79b56262", "node_type": "1", "metadata": {}, "hash": "5562302dcff516521ceef31526e94bbd8cc3ce793dd52d7176f049b0dd2f2146", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Why b must be in {1, 2, 3, 4, 5, 6, 7}?Observation 1:  There are at most 4 points in any square of size \u03b4 on the left of the dividing line.\nObservation 2:  There are at most 4 points in any square of size \u03b4 on the right of the dividing line. (Same argument)\n11\u03b4\u03b4a\u03b4b1)Recall that the distance between a and b is \u2264 \u03b4 and a is lower than b in the y-coordinate.2)b must be in the shaded area, which is comprised of two squares of size \u03b4.3)There are \u2264 4 points in each square, and thus \u2264 8 points in the shaded area.4)There are \u2264 7 points in the shaded area \u2028other than point a. So b must be one of \u20281, 2, 3, 4, 5, 6, 7.\nZhiyi HuangCOMP3251An O(n log2n) Time Divide and Conquer Algorithm for Closest Pair\n12\nDivide:      \n1)Sort the points by their x-coordinates.\n2)Draw a vertical line L so that n/2 points on each side.\nRecurse:   \n3)Find the closest pair on the left of L, let \u03b4L be the distance.\n4)Find the closest pair on the right of L, let \u03b4R be the distance.\nCombine:  \n5)Let \u03b4 = min (\u03b4L, \u03b4R). \n6)Let S be the set of points that are at most \u03b4 from L.\n7)Sort points in S in the y-coordinate and check the distance between each point and next 7 points. \n8)Return the closest pair among step 3, 4, and 7\nZhiyi HuangCOMP3251Running Time Analysis\u2022How to analyze T(n)?\n-Divide step takes O(n log n) time (bottleneck is sorting).\n-Recurse step take 2 T(n/2) time.\n-Combine step takes O(n log n) time (bottleneck is sorting).", "mimetype": "text/plain", "start_char_idx": 8735, "end_char_idx": 10174, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8fa1043e-3974-43a4-9fd8-f11c79b56262": {"__data__": {"id_": "8fa1043e-3974-43a4-9fd8-f11c79b56262", "embedding": null, "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "f91dce28-9d1b-41cd-98a6-8aee5b85070a", "node_type": "4", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "59914834510bfb76506a8af0c26786098443c7822d9b2eeb482d89b7802c3490", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "db1f6153-a92e-4ef3-9838-673493bd84cb", "node_type": "1", "metadata": {"file_name": "S06 Closest Pair_processed.txt", "source_file": "S06 Closest Pair", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S06 Closest Pair_processed.txt"}, "hash": "44b5fc7d6703b6356cc5389a39d81478e517a0492ac35fbbe7b80678fae834c7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "8)Return the closest pair among step 3, 4, and 7\nZhiyi HuangCOMP3251Running Time Analysis\u2022How to analyze T(n)?\n-Divide step takes O(n log n) time (bottleneck is sorting).\n-Recurse step take 2 T(n/2) time.\n-Combine step takes O(n log n) time (bottleneck is sorting).\n\u2022T(n) = 2 T(n/2) + O(n log n) = O(n log2 n) \n-Intuition: \n\u2022If T(n) = 2 T(n/2) + O(n), then T(n) = O(n log n).\n\u2022The extra log factor in the recurrence relation becomes an extra log factor in the \ufb01nal answer.\n-Note that we cannot directly use the Master theorem here.\n-We can prove it either by repeatedly expanding T(.) using the recurrence relation, or by mathematical induction.13\nZhiyi HuangCOMP3251Optional Reading\u2022We can actually implement the same algorithm in O(n log n) time, with some extra e\ufb00orts\n\u2022See, e.g., the slides below:\u2028https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap15d.pdf\n\u2022YouTube video by Tim Roughgarden:\u2028https://www.youtube.com/watch?v=jAigdwcATNw\n\u2022There is a ton of other resources available online\n14", "mimetype": "text/plain", "start_char_idx": 9909, "end_char_idx": 10905, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "86261f56-8db9-443b-9712-026895ffacb5": {"__data__": {"id_": "86261f56-8db9-443b-9712-026895ffacb5", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5274178b-3b60-4127-bbe7-dc3f26fdf4f4", "node_type": "1", "metadata": {}, "hash": "86779ef665beb376f0c10445a0a644a013f3fff4f5116d29f8a7b1879270c636", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 7: Depth-First Search\n(Chapter 3)\nZhiyi HuangCOMP3251GraphsSet of objects with pairwise connections.\n212345Edge: for connectionVertex: for object\nZhiyi HuangCOMP3251An example: \u2028Facebook accounts connected by friendships\n3\n\nZhiyi HuangCOMP3251Another example:\nCities connected by highways\n4\n\nZhiyi HuangCOMP3251Directed GraphsIn a directed graph, every edge has a direction. Each edge is represented by an ordered pair (u, v), meaning that the edge is from vertex u to vertex v.\n512345\nZhiyi HuangCOMP3251Directed GraphsIn a directed graph, every edge has a direction. Each edge is represented by an ordered pair (u, v), meaning that the edge is from vertex u to vertex v.We let V denote the set of vertices, and E the set of edges. \n512345\nZhiyi HuangCOMP3251Directed GraphsIn a directed graph, every edge has a direction. Each edge is represented by an ordered pair (u, v), meaning that the edge is from vertex u to vertex v.We let V denote the set of vertices, and E the set of edges. Examples:  Directed G = (V, E) where V = {1, 2, 3, 4, 5} and \u2028E = {(1,2), (2,4), (4,3), (4,5), (3,1)}.\n512345\nZhiyi HuangCOMP3251Directed GraphsIn a directed graph, every edge has a direction. Each edge is represented by an ordered pair (u, v), meaning that the edge is from vertex u to vertex v.We let V denote the set of vertices, and E the set of edges.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1361, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5274178b-3b60-4127-bbe7-dc3f26fdf4f4": {"__data__": {"id_": "5274178b-3b60-4127-bbe7-dc3f26fdf4f4", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "86261f56-8db9-443b-9712-026895ffacb5", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "5eca313df995193914d520e6945f4e166eab8306aa28ff01083f00e1c465d664", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "56bc4c0b-d617-40f4-8448-daf36bfd4a5e", "node_type": "1", "metadata": {}, "hash": "f4ac5d5a80b57847c0d9c2bd323e0be2899e3d2d51ddbdf34197555bbd673f84", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "512345\nZhiyi HuangCOMP3251Directed GraphsIn a directed graph, every edge has a direction. Each edge is represented by an ordered pair (u, v), meaning that the edge is from vertex u to vertex v.We let V denote the set of vertices, and E the set of edges. Examples:  Directed G = (V, E) where V = {1, 2, 3, 4, 5} and \u2028E = {(1,2), (2,4), (4,3), (4,5), (3,1)}.Fact:  In any directed graphs, 0 \u2264 |E| \u2264 |V| (|V| - 1) = O(|V|2).\n512345\nZhiyi HuangCOMP3251Undirected GraphsIn an undirected graph, the edges have no directions; we can go through the edge in both direction.  \n612345\nZhiyi HuangCOMP3251Undirected GraphsIn an undirected graph, the edges have no directions; we can go through the edge in both direction.  In fact, an undirected graph is just a special case of directed graph, in which for every edge (u, v), we also have edge (v, u).\n612345\nZhiyi HuangCOMP3251Undirected GraphsIn an undirected graph, the edges have no directions; we can go through the edge in both direction.  In fact, an undirected graph is just a special case of directed graph, in which for every edge (u, v), we also have edge (v, u).Examples:  G = (V, E) where V = {1, 2, 3, 4, 5} and E = {(1,2), (2,1), (2,4), (4,2), (3,4), (4,3), (4,5), (5,4)}.\n612345\nZhiyi HuangCOMP3251Undirected GraphsIn an undirected graph, the edges have no directions; we can go through the edge in both direction.", "mimetype": "text/plain", "start_char_idx": 1108, "end_char_idx": 2476, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "56bc4c0b-d617-40f4-8448-daf36bfd4a5e": {"__data__": {"id_": "56bc4c0b-d617-40f4-8448-daf36bfd4a5e", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5274178b-3b60-4127-bbe7-dc3f26fdf4f4", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "a81ffbae52379170e9a8063900ee97a3a8adc30f13c7abb06b1d37573187bece", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "aaf593b5-2f7d-4b62-a146-4d8d2a131b53", "node_type": "1", "metadata": {}, "hash": "2a6812f0945c30698513c63864ecdb88ff8dbf8923122e060869d7e2e6718250", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "612345\nZhiyi HuangCOMP3251Undirected GraphsIn an undirected graph, the edges have no directions; we can go through the edge in both direction.  In fact, an undirected graph is just a special case of directed graph, in which for every edge (u, v), we also have edge (v, u).Examples:  G = (V, E) where V = {1, 2, 3, 4, 5} and E = {(1,2), (2,1), (2,4), (4,2), (3,4), (4,3), (4,5), (5,4)}.Or, we can simply use E = { {1,2}, {2,4}, {3,4}, {4,5} }.\n612345\nZhiyi HuangCOMP3251Representation of Graphs:\u2028Adjacency Matrix\n7\nThe adjacency matrix A of a (directed) graph is a |V| \u2a09 |V| matrix:\n12345\nZhiyi HuangCOMP3251Representation of Graphs:\u2028Adjacency Matrix\n7\nThe adjacency matrix A of a (directed) graph is a |V| \u2a09 |V| matrix:1234510100020001031000040010150000012345\nZhiyi HuangCOMP3251Representation of Graphs:\u2028Adjacency Matrix\n7\nThe adjacency matrix A of a (directed) graph is a |V| \u2a09 |V| matrix:1234510100020001031000040010150000012345\nSpace: O(|V|2)\nZhiyi HuangCOMP3251Representation of Graphs:\u2028Adjacency ListEvery vertex u is associated with a linked list Adj[u], which contains all the vertices adjacent to u, i.e., all the vertices that can be reached directly from u, or more precisely, all the vertices v such that edge (u,v) is in the graph.", "mimetype": "text/plain", "start_char_idx": 2334, "end_char_idx": 3578, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "aaf593b5-2f7d-4b62-a146-4d8d2a131b53": {"__data__": {"id_": "aaf593b5-2f7d-4b62-a146-4d8d2a131b53", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "56bc4c0b-d617-40f4-8448-daf36bfd4a5e", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "63cf14b6c278f9a8f55134f8896ade9e37d9e93438bd43b54138e2d8c70413d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36b98408-ac01-4be5-be06-b75aa79c836f", "node_type": "1", "metadata": {}, "hash": "86cbb786b3f1be49cb1501a9bc90f0b28aa9e20dd31380394973f270da9e1042", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "8123451234524135/////\nZhiyi HuangCOMP3251Representation of Graphs:\u2028Adjacency ListEvery vertex u is associated with a linked list Adj[u], which contains all the vertices adjacent to u, i.e., all the vertices that can be reached directly from u, or more precisely, all the vertices v such that edge (u,v) is in the graph.\n8123451234524135/////\nSpace: O(|V| + |E|)\nZhiyi HuangCOMP3251ReachabilityIntuitively, for any vertices u and v, we say that v is reachable from u if there is a sequence of edges that lead us from u to v.\n9u\nv\nZhiyi HuangCOMP3251ReachabilityFormally, for any vertices u and v, we say that v is reachable from u if either there is an edge (u, v), or there is a vertex x, such that x is reachable from u, and (x, v) is an edge.\n10uvuxv\nRest of the Lecture: Depth-First Search (DFS)\u2022DFS in Undirected Graphs\n\u2022DFS in Directed Graphs\n\u2022Applications of DFS\nZhiyi HuangCOMP3251Reachability as a Computational Problem\n12\nWhat parts of the graph are reachable from a given vertex s, \u2028assuming that we are given the adjacency list.\n12345\nZhiyi HuangCOMP3251Reachability as a Computational ProblemBasic exploration step:  When reaching some vertex u, pick one vertex v in its adjacent list (and thus there is edge (u, v)) and (recursively) continue our exploration from v.\n12\nWhat parts of the graph are reachable from a given vertex s, \u2028assuming that we are given the adjacency list.\n12345\nZhiyi HuangCOMP3251Reachability as a Computational ProblemBasic exploration step:  When reaching some vertex u, pick one vertex v in its adjacent list (and thus there is edge (u, v)) and (recursively) continue our exploration from v.Main di\ufb03culty:  Exploring the graph carelessly may lead us around in circle and, thus, overlook some reachable vertices.", "mimetype": "text/plain", "start_char_idx": 3579, "end_char_idx": 5330, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "36b98408-ac01-4be5-be06-b75aa79c836f": {"__data__": {"id_": "36b98408-ac01-4be5-be06-b75aa79c836f", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "aaf593b5-2f7d-4b62-a146-4d8d2a131b53", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "3ac3a347d0c0c641617ab2a4f815596d66c9b8bf369b9290e75062940cbcff6f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b190dff2-bf42-49cd-b8b7-9bb16fcfb102", "node_type": "1", "metadata": {}, "hash": "3dcb20db514c5e0de2ecb0c1a757d67fb2cfa396710b1b53dff786d57b19e797", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "12345\nZhiyi HuangCOMP3251Reachability as a Computational ProblemBasic exploration step:  When reaching some vertex u, pick one vertex v in its adjacent list (and thus there is edge (u, v)) and (recursively) continue our exploration from v.Main di\ufb03culty:  Exploring the graph carelessly may lead us around in circle and, thus, overlook some reachable vertices.\n12\nWhat parts of the graph are reachable from a given vertex s, \u2028assuming that we are given the adjacency list.\n12345\nZhiyi HuangCOMP3251Reachability as a Computational ProblemBasic exploration step:  When reaching some vertex u, pick one vertex v in its adjacent list (and thus there is edge (u, v)) and (recursively) continue our exploration from v.Main di\ufb03culty:  Exploring the graph carelessly may lead us around in circle and, thus, overlook some reachable vertices.\n12\nWhat parts of the graph are reachable from a given vertex s, \u2028assuming that we are given the adjacency list.\n12345\nZhiyi HuangCOMP3251Reachability as a Computational ProblemBasic exploration step:  When reaching some vertex u, pick one vertex v in its adjacent list (and thus there is edge (u, v)) and (recursively) continue our exploration from v.Main di\ufb03culty:  Exploring the graph carelessly may lead us around in circle and, thus, overlook some reachable vertices.Our solution:  We mark a vertex the \u2028\ufb01rst time we reach it, and we only \u2028explore vertex that has no mark. \u2028When stuck, we backtrack.12\nWhat parts of the graph are reachable from a given vertex s, \u2028assuming that we are given the adjacency list.", "mimetype": "text/plain", "start_char_idx": 4971, "end_char_idx": 6517, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b190dff2-bf42-49cd-b8b7-9bb16fcfb102": {"__data__": {"id_": "b190dff2-bf42-49cd-b8b7-9bb16fcfb102", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36b98408-ac01-4be5-be06-b75aa79c836f", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "3e10779942a7f7fbec6b4036911e8788b3848268d3168a6626d808825041968b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3dff4fff-749e-41ea-9cf0-8b212c543856", "node_type": "1", "metadata": {}, "hash": "2d289bae663223333dd6a51d2a9820dc2bdf6258af3b8a718507540fbd6efa3f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "When stuck, we backtrack.12\nWhat parts of the graph are reachable from a given vertex s, \u2028assuming that we are given the adjacency list.\n12345\nZhiyi HuangCOMP3251Depth-First Search (in Undirected Graphs)The implementation of this simple idea is called Depth-First Search (DFS):\n13\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}\nZhiyi HuangCOMP3251Depth-First Search (in Undirected Graphs)The implementation of this simple idea is called Depth-First Search (DFS):\n13\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}\nExplore the portion of the graph reachable from vertex v.\nZhiyi HuangCOMP3251Depth-First Search (in Undirected Graphs)The implementation of this simple idea is called Depth-First Search (DFS):\n13\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}\nprocedure dfs(G){     for each v in V:        visited(v) = false;    for each v in V:        if not visited(v):             explore(v);}\nExplore the portion of the graph reachable from vertex v.\nRepeatedly call the explore procedure to visit all vertices.\nZhiyi HuangCOMP3251Sample Run\n14abcdesInitially, all vertices are unvisited.\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}\nZhiyi HuangCOMP3251Sample Run\n15abcdesColored green means visited(s) = true\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s)\nZhiyi HuangCOMP3251Sample Run\n16abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v,", "mimetype": "text/plain", "start_char_idx": 6381, "end_char_idx": 8149, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3dff4fff-749e-41ea-9cf0-8b212c543856": {"__data__": {"id_": "3dff4fff-749e-41ea-9cf0-8b212c543856", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b190dff2-bf42-49cd-b8b7-9bb16fcfb102", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "998371a83d67bcc86b74bb3f8c16aa751590f5bcd69b2392e46e55675154d899", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eaaec151-1d0f-4f66-bfef-f9439f8be60b", "node_type": "1", "metadata": {}, "hash": "1e8aab705425ee557cdc22aa2e7dee3a870ca80ff3de77a92b61a2e607c0ed83", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "}\nZhiyi HuangCOMP3251Sample Run\n15abcdesColored green means visited(s) = true\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s)\nZhiyi HuangCOMP3251Sample Run\n16abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)\nZhiyi HuangCOMP3251Sample Run\n17abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)   \u21b3explore(a)\nZhiyi HuangCOMP3251Sample Run\n18abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)   \u21b3explore(a)     \u21b3explore(d)\nZhiyi HuangCOMP3251Sample Run\n19abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)   \u21b3explore(a)     \u21b3explore(d)       \u21b3explore(e)\nZhiyi HuangCOMP3251Sample Run\n20abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}visited(s) = true so we\u2028will not explore(s) againexplore(s) \u21b3explore(c)   \u21b3explore(a)     \u21b3explore(d)       \u21b3explore(e)\nZhiyi HuangCOMP3251Sample Run\n21abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v,", "mimetype": "text/plain", "start_char_idx": 7831, "end_char_idx": 9273, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "eaaec151-1d0f-4f66-bfef-f9439f8be60b": {"__data__": {"id_": "eaaec151-1d0f-4f66-bfef-f9439f8be60b", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3dff4fff-749e-41ea-9cf0-8b212c543856", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "fc1fd49c3ad1835ee02f67248126b51dad83354b087970fb66630b32aacf98e6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dd4ce108-ec97-4048-8773-aea24d74b060", "node_type": "1", "metadata": {}, "hash": "5c64425a2a2054614d138d8863d1baaec784a3a07611c3e7960ad1a9c6e9a8e6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "u) in E:        if not visited(u):             explore(u);}visited(s) = true so we\u2028will not explore(s) againexplore(s) \u21b3explore(c)   \u21b3explore(a)     \u21b3explore(d)       \u21b3explore(e)\nZhiyi HuangCOMP3251Sample Run\n21abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}Colored blue means we have \u2028\ufb01nished and returned from explore(e).explore(s) \u21b3explore(c)   \u21b3explore(a)     \u21b3explore(d)\nZhiyi HuangCOMP3251Sample Run\n22abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)   \u21b3explore(a)\nZhiyi HuangCOMP3251Sample Run\n23abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)   \u21b3explore(a)     \u21b3explore(b)\nZhiyi HuangCOMP3251Sample Run\n24abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)   \u21b3explore(a)\nZhiyi HuangCOMP3251Sample Run\n25abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)\nZhiyi HuangCOMP3251Sample Run\n26abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);", "mimetype": "text/plain", "start_char_idx": 8990, "end_char_idx": 10420, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "dd4ce108-ec97-4048-8773-aea24d74b060": {"__data__": {"id_": "dd4ce108-ec97-4048-8773-aea24d74b060", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eaaec151-1d0f-4f66-bfef-f9439f8be60b", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "6a0ea099b5133bf2454f66bc4f1888791feb117ce83d7ea0150c160fd1249abb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ed00e8d4-7f7a-478c-aa80-352b4ea4b076", "node_type": "1", "metadata": {}, "hash": "2f633ad6da4e4e9119646fc1ecaae7b04ed096667f4574af6f0da65ce1d90183", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s) \u21b3explore(c)\nZhiyi HuangCOMP3251Sample Run\n26abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}explore(s)\nZhiyi HuangCOMP3251Sample Run\n27abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}\nZhiyi HuangCOMP3251Sample Run\n27abcdes\nprocedure explore(v){     visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);}\nRunning time:  O(|V|+|E|) time, as we just scan through the adjacent list once, and the size of the list is O(|V|+|E|).\nZhiyi HuangCOMP3251Correctness of DFSWe want to show that all vertices that are reachable from s are discovered by DFS.\n28Proof by contradiction: \u2022Suppose c is reachable from s, but is not discovered by DFS.\n\u2022Let b be the \ufb01rst vertex on the path from s to c that is not discovered by DFS.\n\u2022That means its predecessor on the path, a, is discovered by DFS, and b is on the adjacent list of a.\n\u2022Then, b will be explored when DFS processes a, i.e., \u2028b will be discovered by DFS, a contradiction.sabc\nZhiyi HuangCOMP3251Classi\ufb01cation of EdgesThe edges can be classi\ufb01ed into two types:\n\u2022\u201cCritical\u201d edges that lead us to the discovery of new vertices.\n\u2022Back edges that lead us back to old, visited vertices.\nNote that the set of critical edges form a tree, which we call the DFS tree. So we also refer to \u201ccritical\u201d edges as tree edges.", "mimetype": "text/plain", "start_char_idx": 10157, "end_char_idx": 11711, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ed00e8d4-7f7a-478c-aa80-352b4ea4b076": {"__data__": {"id_": "ed00e8d4-7f7a-478c-aa80-352b4ea4b076", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dd4ce108-ec97-4048-8773-aea24d74b060", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "7ceb079af425d6dd49ba0726a2060c289cae43494b8f01eb469e3a2be706d20b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b8941e0b-ef8c-4a4d-b6b2-18211a941b7c", "node_type": "1", "metadata": {}, "hash": "caac815256b4f740a8725056b65d704fdfba4b1d74058717aaee1c4d8c444e11", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Back edges that lead us back to old, visited vertices.\nNote that the set of critical edges form a tree, which we call the DFS tree. So we also refer to \u201ccritical\u201d edges as tree edges.\n29abcdesabcdes\n\nZhiyi HuangCOMP3251Relation Among Vertices\n30Root of the DFS treeThe \ufb01rst vertex that the algorithm explores, i.e., s.u is the parent of v, \u2028and v is a child of u\n(u, v) is a tree edge, and v is discovered from u.u is an ancestor of v, \u2028and v is a descendent of u.\nEither 1) u is a parent of v, or \u20282) u is an ancestor of the parent of v.\nabcdes\nZhiyi HuangCOMP3251Relation Among Vertices\n30Root of the DFS treeThe \ufb01rst vertex that the algorithm explores, i.e., s.u is the parent of v, \u2028and v is a child of u\n(u, v) is a tree edge, and v is discovered from u.u is an ancestor of v, \u2028and v is a descendent of u.\nEither 1) u is a parent of v, or \u20282) u is an ancestor of the parent of v.\nabcdes\nFact:  If u is an ancestor of v, then there is a tree-path from u to v.\nZhiyi HuangCOMP3251An Extension of DFSWe can get more information by doing some simple extra steps:\n1)a pre-order number pre[v] (moment of \ufb01rst discovery);\n2)a post-order number post[v] (moment of \ufb01nal department).", "mimetype": "text/plain", "start_char_idx": 11527, "end_char_idx": 12706, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b8941e0b-ef8c-4a4d-b6b2-18211a941b7c": {"__data__": {"id_": "b8941e0b-ef8c-4a4d-b6b2-18211a941b7c", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ed00e8d4-7f7a-478c-aa80-352b4ea4b076", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "4d1842b77cf5e60600f5d998d0c20d5437bad7bdf7c7bf414558e0b8eac05d7f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "538ba89e-6235-46f3-abad-c0b2fb78697a", "node_type": "1", "metadata": {}, "hash": "612e438a7f716258c54c45bf8740ee3321ce8c1ba7db29f9dda50272656f9c98", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "31\nprocedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;}\ninitialize clock = 1procedure dfs(G){     for each v in V:        visited(v) = false;    for each v in V:        if not visited(v):             explore(v);}\nZhiyi HuangCOMP3251Sample Run\n32\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;-/--/--/--/--/-Initially, all vertices are \u2028unvisited, and clock = 1.\nZhiyi HuangCOMP3251Sample Run\n33\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/--/--/--/--/-clock = 2\nZhiyi HuangCOMP3251Sample Run\n34\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/--/--/--/-clock = 3\nZhiyi HuangCOMP3251Sample Run\n35\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;", "mimetype": "text/plain", "start_char_idx": 12707, "end_char_idx": 14136, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "538ba89e-6235-46f3-abad-c0b2fb78697a": {"__data__": {"id_": "538ba89e-6235-46f3-abad-c0b2fb78697a", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b8941e0b-ef8c-4a4d-b6b2-18211a941b7c", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "662a00c5b3a1156f6442a19a278190c3d34ac63785eb2e6afaacf36404a0c248", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e317f44e-ef91-4fbd-aeba-6f435d81be6f", "node_type": "1", "metadata": {}, "hash": "6275de28ac02c9947684dd677002a1ab9ed33d88d0b8e2c830cb3a6a1f657581", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "post[v] = clock;    clock++;1/-2/--/--/--/-clock = 3\nZhiyi HuangCOMP3251Sample Run\n35\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/--/-3/--/-clock = 4\nZhiyi HuangCOMP3251Sample Run\n36\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/-4/-3/--/-clock = 5\nZhiyi HuangCOMP3251Sample Run\n37\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/-4/53/--/-clock = 6\nZhiyi HuangCOMP3251Sample Run\n38\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/-4/53/-6/-clock = 7\nZhiyi HuangCOMP3251Sample Run\n39\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;", "mimetype": "text/plain", "start_char_idx": 13843, "end_char_idx": 15196, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e317f44e-ef91-4fbd-aeba-6f435d81be6f": {"__data__": {"id_": "e317f44e-ef91-4fbd-aeba-6f435d81be6f", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "538ba89e-6235-46f3-abad-c0b2fb78697a", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "efc37690201c91331336414cc9947840a1893583181a49a2af209281f959432d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fb231ae5-71cb-4f0b-895c-7b8ddc5b269e", "node_type": "1", "metadata": {}, "hash": "257e4a05599b374cda2d55b96d02aa05ee568b9d255478e12e92e055acc5fc9e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "post[v] = clock;    clock++;1/-2/-4/53/-6/-clock = 7\nZhiyi HuangCOMP3251Sample Run\n39\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/-4/53/-6/7clock = 8\nZhiyi HuangCOMP3251Sample Run\n40\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/-4/53/86/7clock = 9\nZhiyi HuangCOMP3251Sample Run\n41\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/-2/94/53/86/7clock = 10\nZhiyi HuangCOMP3251Sample Run\n42\ninitialize clock = 1procedure explore(v) {    pre[v] = clock;    clock++;    visited(v) = true;    for each edge (v, u) in E:        if not visited(u):             explore(u);    post[v] = clock;    clock++;1/102/94/53/86/7\nRest of the Lecture: \u2028Depth-First Search (DFS)\u2022DFS in Undirected Graphs\n\u2022DFS in Directed Graphs\n\u2022Applications of DFS\nZhiyi HuangCOMP3251Depth-\ufb01rst search of a directed graph can be run verbatim on directed graphs, taking care to traverse edges only in their prescribed directions.", "mimetype": "text/plain", "start_char_idx": 14903, "end_char_idx": 16289, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fb231ae5-71cb-4f0b-895c-7b8ddc5b269e": {"__data__": {"id_": "fb231ae5-71cb-4f0b-895c-7b8ddc5b269e", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e317f44e-ef91-4fbd-aeba-6f435d81be6f", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "1f0e7829729f3719bb7d1858a94224c8c704b0d4161d58d067621976564412a2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c8edfb4f-dc0f-460e-a66d-f679b60a038c", "node_type": "1", "metadata": {}, "hash": "73c3c132c09ecc015bb181402bdd64017f0a93f3d0dcaec6a67df9afe97f1da5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "post[v] = clock;    clock++;1/102/94/53/86/7\nRest of the Lecture: \u2028Depth-First Search (DFS)\u2022DFS in Undirected Graphs\n\u2022DFS in Directed Graphs\n\u2022Applications of DFS\nZhiyi HuangCOMP3251Depth-\ufb01rst search of a directed graph can be run verbatim on directed graphs, taking care to traverse edges only in their prescribed directions.DFS in Directed Graphs\n44abcefdghefbha\ngcd1/162/113/104/75/68/912/1513/14\nZhiyi HuangCOMP3251Fact:  \n1)If u is an ancestor of v then the v\u2019s lifespan [pre[v], post[v]] is contained in the u\u2019s lifespan of [pre[u], post[u]]. \n2)If u and v have no ancestor-descendant relation, then [pre[v],post[v]] and [pre[u],post[u]] are disjoint.DFS in Directed Graphs\n45abcefdghefbha\ngcd1/162/113/104/75/68/912/1513/14\nZhiyi HuangCOMP3251Tree edges are de\ufb01ned the same as in undirected graphs. Forward edges lead from a node to a non-child descendent in the DFS tree.\nBack edges lead to an ancestor in the DFS.\nCross edges lead to a node that has already been explored.More types of edges in directed DFS\n46abcefdghefbha\ngcd1/162/113/104/75/68/912/1513/14\nRest of the Lecture: \u2028Depth-First Search (DFS)\u2022DFS in Undirected Graphs\n\u2022DFS in Directed Graphs\n\u2022Applications of DFS\n-Detecting Cycles \n-Topological Ordering\n-Strongly Connected Components \nZhiyi HuangCOMP3251Cycles and Directed Acyclic GraphsA cycle in a directed graph is a sequence of edges\t\n(a,b), (b,c), (c,d),\u2026, (x,a)\nA directed acyclic graph (DAG) is a directed graph that does not contain any cycle.", "mimetype": "text/plain", "start_char_idx": 15964, "end_char_idx": 17438, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c8edfb4f-dc0f-460e-a66d-f679b60a038c": {"__data__": {"id_": "c8edfb4f-dc0f-460e-a66d-f679b60a038c", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb231ae5-71cb-4f0b-895c-7b8ddc5b269e", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "e1326f0a62e0bae415de83345569e6741989d9b913bd03ea01a89437bb90e49d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e2e496b9-c670-468f-b11c-4669d3d280e1", "node_type": "1", "metadata": {}, "hash": "c34b19985c17b9b7594982bc477769c8f99f3df33da7bca5843ed5a08850aa97", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "48\nEnd point of an edge is the starting point of the next edge\nEnd point of last edge is the starting point of \ufb01rst edge12345\nZhiyi HuangCOMP3251DFS and Cycles in GraphsFact:  A directed graph G has a cycle if and only if its DFS has a back edge.\nReasons: \u2022If there is a back edge (v, u):\n-u is an ancestor of v, so there is a tree-path from u to v.\n-The tree-path and the back edge (v, u) forms a cycle.\n\u2022If G has a cycle:\n-Let v0 \u2192 v1 \u2192 \u2026 \u2192 vk \u2192 v0 be the smallest cycle, and suppose that DFS explores v0 \ufb01rst. \n-Then, vk is a descendant of v0, and (vk, v0) is a back edge.49\nZhiyi HuangCOMP3251a)Computer programming \nb)Introduction to data structures and algorithms\nc)Design and analysis of algorithms \nd)Arti\ufb01cial intelligence\ne)Introduction to theory of computation\nf)Advanced algorithm analysisApplications of DFS: Detecting Cycles in Graphs\n50abcdefwe want to avoid \u2028cycles like thisSuppose we are designing pre-requisite requirements of the following courses for a new CS program:We can run a DFS to detect cycles in the pre-requisite graph.\nZhiyi HuangCOMP3251Applications of DFS: \u2028Topological Ordering for DAGsSuppose we want to \ufb01nish a set of jobs sequentially subject to dependency of jobs: e.g., job b must be completed before job a.\n51caebdf\nfcebadMathematically, this is the same as \ufb01nding an ordering of the vertices on a line such that all edges goes from left to right.\nZhiyi HuangCOMP3251Applications of DFS: \u2028Topological Ordering for DAGsSuppose we want to \ufb01nish a set of jobs sequentially subject to dependency of jobs: e.g., job b must be completed before job a.", "mimetype": "text/plain", "start_char_idx": 17439, "end_char_idx": 19024, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e2e496b9-c670-468f-b11c-4669d3d280e1": {"__data__": {"id_": "e2e496b9-c670-468f-b11c-4669d3d280e1", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c8edfb4f-dc0f-460e-a66d-f679b60a038c", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "016b7dee60c7daa32d06c689adba5ef86edc4e8f1b42ae21c47fdadebcc2b05d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fff063f9-a903-43f8-b895-68f1d9909030", "node_type": "1", "metadata": {}, "hash": "29f0dac85f7b8fe7516eb98ce0d85b1fb65ca357679017efe31ce3c92526760f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "51caebdf\nfcebadMathematically, this is the same as \ufb01nding an ordering of the vertices on a line such that all edges goes from left to right.\nZhiyi HuangCOMP3251Applications of DFS: \u2028Topological Ordering for DAGsSuppose we want to \ufb01nish a set of jobs sequentially subject to dependency of jobs: e.g., job b must be completed before job a.\n52caebdf1/1210/113/84/56/72/9\nfcebad1/1210/112/93/86/74/5Mathematically, this is the same as \ufb01nding an ordering of the vertices on a line such that all edges goes from left to right.\nObserve that post[v]'s are listed in descending order.\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithm\n53caebdfFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n54caebdf6\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.", "mimetype": "text/plain", "start_char_idx": 18687, "end_char_idx": 20410, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fff063f9-a903-43f8-b895-68f1d9909030": {"__data__": {"id_": "fff063f9-a903-43f8-b895-68f1d9909030", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e2e496b9-c670-468f-b11c-4669d3d280e1", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "39e2fc7777a4d690e9f3c8dd8203237f34ee748320ad700aa6d2c7406a7cac52", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5688728-04e5-4639-b4e5-4cf7a1b818e6", "node_type": "1", "metadata": {}, "hash": "a43197ad36147a33577edabe97894f005c638c349875deda9794bb8671aa1868", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Remove this vertex and repeat\u2026\n54caebdf6\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n55caebdf65\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n56caebdf654\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n57caebdf6543\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n58caebdf65432\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.", "mimetype": "text/plain", "start_char_idx": 20014, "end_char_idx": 22008, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c5688728-04e5-4639-b4e5-4cf7a1b818e6": {"__data__": {"id_": "c5688728-04e5-4639-b4e5-4cf7a1b818e6", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fff063f9-a903-43f8-b895-68f1d9909030", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "29909c4a91ac13424153dde7f27b6b767af5f75ed15e740919b5acd292eb0a53", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27dd9c46-7b87-42ff-9ebe-c3553d1b8f57", "node_type": "1", "metadata": {}, "hash": "51eb883b817c302d7d6f75820806602b78915f2192902e0749d9bd83619e84ee", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Remove this vertex and repeat\u2026\n58caebdf65432\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n59caebdf654321\nZhiyi HuangCOMP3251Why topological ordering exists and straightforward algorithmFor any DAG, there exists a vertex with no outgoing edges\nWhy? \n-Keep exploring the DAG along the directed edges. Since there is no directed cycle, this has to stop at some vertex, which must have no outgoing edges.\n-This will be the last vertex in the topological ordering.\n-Remove this vertex and repeat\u2026\n59caebdf654321\nRunning time: \u2028O( |V|2 )\nZhiyi HuangCOMP3251Applications of DFS: Topological Ordering\n60\nZhiyi HuangCOMP3251Applications of DFS: Topological OrderingObservation:  After a DFS, if there is an edge (u, v) such that post[u] < post[v], then this edge must be a back edge.\u2028\n60\nZhiyi HuangCOMP3251Applications of DFS: Topological OrderingObservation:  After a DFS, if there is an edge (u, v) such that post[u] < post[v], then this edge must be a back edge.\u2028Why?  There are three potential relations between u and v: -v is an ancestor of u, in which case (u, v) is a back edge.\n-u is an ancestor of v, in which case the DFS would call explore(v) when it processes u. Therefore, the DFS departs v before it departs u, which contradicts post[u] < post[v].\n-There is no ancestor-descendent relation between u and v. Then, by our earlier observation [pre[u], post[u]] and [pre[v], post[v]] are disjoint.", "mimetype": "text/plain", "start_char_idx": 21608, "end_char_idx": 23350, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "27dd9c46-7b87-42ff-9ebe-c3553d1b8f57": {"__data__": {"id_": "27dd9c46-7b87-42ff-9ebe-c3553d1b8f57", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5688728-04e5-4639-b4e5-4cf7a1b818e6", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "e30ab161914405093be179d515bd3780e8481db5255d30a79567e8f6949b6526", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3f4bc013-e0f3-4f82-9eed-699ddcf0b96d", "node_type": "1", "metadata": {}, "hash": "4d6f5730d080b0f05c910cdcbd5229387e06fd0a6faaf8c38aa7165a85954318", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-u is an ancestor of v, in which case the DFS would call explore(v) when it processes u. Therefore, the DFS departs v before it departs u, which contradicts post[u] < post[v].\n-There is no ancestor-descendent relation between u and v. Then, by our earlier observation [pre[u], post[u]] and [pre[v], post[v]] are disjoint. Thus, post[u] < pre[v], i.e., the DFS departs u before it explores v, which is impossible as the DFS would check edge (u, v) when it processes u.60\nZhiyi HuangCOMP3251Applications of DFS: Topological Ordering\n61\nZhiyi HuangCOMP3251Applications of DFS: Topological OrderingObservation:  After a DFS, if there is an edge (u, v) such that post[u] < post[v], then this edge must be a back edge.\u2028\n61\nZhiyi HuangCOMP3251Applications of DFS: Topological OrderingObservation:  After a DFS, if there is an edge (u, v) such that post[u] < post[v], then this edge must be a back edge.\u2028Fact:  In a DAG, every edge leads to a vertex with a lower post number (because there is no cycle, and thus no back edge).\u2028\n61\nZhiyi HuangCOMP3251Applications of DFS: Topological OrderingObservation:  After a DFS, if there is an edge (u, v) such that post[u] < post[v], then this edge must be a back edge.\u2028Fact:  In a DAG, every edge leads to a vertex with a lower post number (because there is no cycle, and thus no back edge).\u2028Our algorithm for topological sort: 1)Run a DFS with pre-/post-ordering numbers.\n2)List vertices in descending order of the post-ordering numbers.", "mimetype": "text/plain", "start_char_idx": 23029, "end_char_idx": 24500, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3f4bc013-e0f3-4f82-9eed-699ddcf0b96d": {"__data__": {"id_": "3f4bc013-e0f3-4f82-9eed-699ddcf0b96d", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27dd9c46-7b87-42ff-9ebe-c3553d1b8f57", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "051b8ae13a5254fb36f9675279d830796137f023af5a4c9c3edfbd49b6c82017", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "99d64770-9a8c-4e62-9d51-c6f13e3bac50", "node_type": "1", "metadata": {}, "hash": "c10e364e42269fcee2a2a668f308e69360996a155d1bbce5ef6436cc8884383f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Fact:  In a DAG, every edge leads to a vertex with a lower post number (because there is no cycle, and thus no back edge).\u2028Our algorithm for topological sort: 1)Run a DFS with pre-/post-ordering numbers.\n2)List vertices in descending order of the post-ordering numbers.\nThen, all edges are from left to right and thus the vertices are topologically sorted.61\nZhiyi HuangCOMP3251An example\n62caebdf1/1210/113/84/56/72/9\nfcebad1/1210/112/93/86/74/5Pre-/post-ordering\u2028numbers of an \u2028DFS starting from bTopological sorted ordering:\nZhiyi HuangCOMP3251Running time analysisA straightforward analysis:-DFS with pre-/post-ordering takes O(|V| + |E|) time.-Sorting the vertices according to post-ordering numbers takes O(|V| log |V|) time. -So the algorithm runs in O(|V| log |V| + |E|) time.Correct?\n63\nZhiyi HuangCOMP3251Running time analysisA straightforward analysis:-DFS with pre-/post-ordering takes O(|V| + |E|) time.-Sorting the vertices according to post-ordering numbers takes O(|V| log |V|) time. -So the algorithm runs in O(|V| log |V| + |E|) time.Correct?-It\u2019s a correct upper bound, \u2028but we can actually show that it runs in O(|V| + |E|) time.\n63\nZhiyi HuangCOMP3251Running time analysisA straightforward analysis:-DFS with pre-/post-ordering takes O(|V| + |E|) time.-Sorting the vertices according to post-ordering numbers takes O(|V| log |V|) time.", "mimetype": "text/plain", "start_char_idx": 24231, "end_char_idx": 25587, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "99d64770-9a8c-4e62-9d51-c6f13e3bac50": {"__data__": {"id_": "99d64770-9a8c-4e62-9d51-c6f13e3bac50", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3f4bc013-e0f3-4f82-9eed-699ddcf0b96d", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "31afe359ce44d52d0edca09e8b504e9e4dc3d29e9f2cd88be17e425246c1f0fb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "057b7ebb-3d9a-40f5-8cfd-5c58336cfba3", "node_type": "1", "metadata": {}, "hash": "b7af589cbf18e48de32432dbe4f91cf44481b369e8a9a860540e8987120a93d1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "63\nZhiyi HuangCOMP3251Running time analysisA straightforward analysis:-DFS with pre-/post-ordering takes O(|V| + |E|) time.-Sorting the vertices according to post-ordering numbers takes O(|V| log |V|) time. -So the algorithm runs in O(|V| log |V| + |E|) time.Correct?-It\u2019s a correct upper bound, \u2028but we can actually show that it runs in O(|V| + |E|) time.-Recall that post-ordering numbers are the time that the algorithm departs a vertex.\n63\nZhiyi HuangCOMP3251Running time analysisA straightforward analysis:-DFS with pre-/post-ordering takes O(|V| + |E|) time.-Sorting the vertices according to post-ordering numbers takes O(|V| log |V|) time. -So the algorithm runs in O(|V| log |V| + |E|) time.Correct?-It\u2019s a correct upper bound, \u2028but we can actually show that it runs in O(|V| + |E|) time.-Recall that post-ordering numbers are the time that the algorithm departs a vertex.-The \ufb01rst time that the algorithm departs a vertex, that is the last vertex in the topological ordering; the second time it departs a vertex, that is the second last vertex, etc.63\nRest of the Lecture: \u2028Depth-First Search (DFS)\u2022DFS in Undirected Graphs\n\u2022DFS in Directed Graphs\n\u2022Applications of DFS\n-Detecting Cycles \n-Topological Ordering\n-Strongly Connected Components \nZhiyi HuangCOMP3251We say that an undirected graph is connected if for any two vertices u and v, there is at least one path connecting them.", "mimetype": "text/plain", "start_char_idx": 25381, "end_char_idx": 26773, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "057b7ebb-3d9a-40f5-8cfd-5c58336cfba3": {"__data__": {"id_": "057b7ebb-3d9a-40f5-8cfd-5c58336cfba3", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99d64770-9a8c-4e62-9d51-c6f13e3bac50", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "a14c3d05b3f1faa3c649c54285cd9bf2d8ac24d5125582f0ac3c351d4ccf557b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "88e76fd9-49d8-455b-a97a-d4a118f89b17", "node_type": "1", "metadata": {}, "hash": "ee711c696aba0ce1b40b643c056b16a7e2e48a851e288132bf5707b90be36daf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Examples:Connected Components (CCs)\n65\nThis graph is not connected; it has\ntwo connected components.12345678\n12345A connected graph\nZhiyi HuangCOMP3251Finding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.665123467891011\nZhiyi HuangCOMP3251Finding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.675123467891011DFS from 1\nZhiyi HuangCOMP3251\nFinding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.685123467891011DFS from 1\nZhiyi HuangCOMP3251\nFinding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.695123467891011DFS from 5\nZhiyi HuangCOMP3251\nFinding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s.", "mimetype": "text/plain", "start_char_idx": 26774, "end_char_idx": 28346, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "88e76fd9-49d8-455b-a97a-d4a118f89b17": {"__data__": {"id_": "88e76fd9-49d8-455b-a97a-d4a118f89b17", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "057b7ebb-3d9a-40f5-8cfd-5c58336cfba3", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "6bc118904f7af2de1f3ca9178b7e271ce0eb11f80be50594f5564bf05a1498d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ce45ddd1-6ad8-473d-9854-cbcbbd5cf819", "node_type": "1", "metadata": {}, "hash": "4c5a1985758bf42f99df8b2cf2c14b33603eb7d04cb083f35a6242a5daf0349e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)If there is un-explored vertex, repeat the process, until all vertices are visited.695123467891011DFS from 5\nZhiyi HuangCOMP3251\nFinding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.705123467891011DFS from 5\nZhiyi HuangCOMP3251\nFinding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.715123467891011DFS from 9\nZhiyi HuangCOMP3251\nFinding CCs for undirected graphs\nWe can use DFS:  \n1)pick a vertex s, and explore it to \u201ccapture\u201d all the vertices reachable from s; this set of vertices is a SCC that contains s. \n2)If there is un-explored vertex, repeat the process, until all vertices are visited.725123467891011DFS from 9\nZhiyi HuangCOMP3251\nStrongly Connected Components (SCCs)For directed graphs, de\ufb01ning connectivity is much more subtle.\nExamples:\n7312341234Is this directed graph connected? No.  While visually the graph is in \u2028one piece, we cannot, for example, \u2028reach 4 from 1, 2, or 3.Is this directed graph connected? Yes.  We can reach any vertex from\u2028any other vertex.", "mimetype": "text/plain", "start_char_idx": 28035, "end_char_idx": 29441, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ce45ddd1-6ad8-473d-9854-cbcbbd5cf819": {"__data__": {"id_": "ce45ddd1-6ad8-473d-9854-cbcbbd5cf819", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "88e76fd9-49d8-455b-a97a-d4a118f89b17", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "ef08251c2a580a18d585aa233d477f93ba7f358de3c101b23c1428f16c280d2d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d895da4a-0700-4d40-b739-4de1757e446a", "node_type": "1", "metadata": {}, "hash": "65e9999838faa14c8184c67702cf97b4aa0b1b464690a376163c321353e3694d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Examples:\n7312341234Is this directed graph connected? No.  While visually the graph is in \u2028one piece, we cannot, for example, \u2028reach 4 from 1, 2, or 3.Is this directed graph connected? Yes.  We can reach any vertex from\u2028any other vertex.\nZhiyi HuangCOMP3251Strongly Connected Components (SCCs)De\ufb01nition:  Two vertices a, b are strongly connected if there is a directed path from a to b, and a directed path from b to a.\nExamples:\n74\nEven though there is a directed\npath from a to b, a and b are not \u2028strongly connectedacdb\u2026\na and b are strongly connected\nbecause there is a directed path from a to b, and another directed\npath from b to a.acdb\u2026ghfe\u2026\nZhiyi HuangCOMP3251Strongly Connected Components (SCCs)De\ufb01nition:  Consider any directed graph G = (V, E).  A subset C of vertices is a strongly connected component of G if C is the maximal subset of vertices such that for any two vertices in C, they are strongly connected.\nExample:\n751239811107645\nZhiyi HuangCOMP3251\nStrongly Connected Components (SCCs)De\ufb01nition:  Consider any directed graph G = (V, E).  A subset C of vertices is a strongly connected component of G if C is the maximal subset of vertices such that for any two vertices in C, they are strongly connected.\nExample:\n751239811107645\n4 SCCs in this graph\nZhiyi HuangCOMP3251\nStrongly Connected Components (SCCs)De\ufb01nition:  Consider any directed graph G = (V, E).  A subset C of vertices is a strongly connected component of G if C is the maximal subset of vertices such that for any two vertices in C, they are strongly connected.\nExample:\n751239811107645\n4 SCCs in this graph\nNote:  4, 5, and 7 are not a SCC because we could add 6 and still every two vertices are strongly connected.", "mimetype": "text/plain", "start_char_idx": 29204, "end_char_idx": 30906, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d895da4a-0700-4d40-b739-4de1757e446a": {"__data__": {"id_": "d895da4a-0700-4d40-b739-4de1757e446a", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ce45ddd1-6ad8-473d-9854-cbcbbd5cf819", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "7e7b8b1a57ed4c08311c2550c7aca995c322ca847b0cb43bdd3a5655049ebd87", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f07308ea-b65f-41eb-a5a8-d2fad64f33be", "node_type": "1", "metadata": {}, "hash": "0e2ee95307ce99ae587f10a4b01861fe64369f8e95973c3c86d40e496d9f702e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A subset C of vertices is a strongly connected component of G if C is the maximal subset of vertices such that for any two vertices in C, they are strongly connected.\nExample:\n751239811107645\n4 SCCs in this graph\nNote:  4, 5, and 7 are not a SCC because we could add 6 and still every two vertices are strongly connected.\nZhiyi HuangCOMP3251Some Facts about SCCsProof:\n76abc\nFact 1:  If vertices a and b are strongly connected, and b and c are strongly connected, then a and c are strongly connected.\nZhiyi HuangCOMP3251Some Facts about SCCsProof:\u2022Since a and b are strongly connected, there is a directed path from a to b.\n76abc\nFact 1:  If vertices a and b are strongly connected, and b and c are strongly connected, then a and c are strongly connected.\nZhiyi HuangCOMP3251Some Facts about SCCsProof:\u2022Since a and b are strongly connected, there is a directed path from a to b.\u2022Likewise, there is a directed path from b to c.\n76abc\nFact 1:  If vertices a and b are strongly connected, and b and c are strongly connected, then a and c are strongly connected.\nZhiyi HuangCOMP3251Some Facts about SCCsProof:\u2022Since a and b are strongly connected, there is a directed path from a to b.\u2022Likewise, there is a directed path from b to c.\u2022Combining the two paths, we get a directed path from a to c.\n76abc\nFact 1:  If vertices a and b are strongly connected, and b and c are strongly connected, then a and c are strongly connected.\nZhiyi HuangCOMP3251Some Facts about SCCsProof:\u2022Since a and b are strongly connected, there is a directed path from a to b.\u2022Likewise, there is a directed path from b to c.\u2022Combining the two paths, we get a directed path from a to c.\u2022For the same reason, we also get a directed path from c to a.", "mimetype": "text/plain", "start_char_idx": 30585, "end_char_idx": 32301, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f07308ea-b65f-41eb-a5a8-d2fad64f33be": {"__data__": {"id_": "f07308ea-b65f-41eb-a5a8-d2fad64f33be", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d895da4a-0700-4d40-b739-4de1757e446a", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "abae58efd0408edec86de451f9c4493cf22a5b91d782c15cb90621f0b310ee44", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e5fe8c28-7b66-447e-ab5b-fe35687b372b", "node_type": "1", "metadata": {}, "hash": "2d443193313e7101ae3af81c852ba1cea4e2cbde0d2e0d12fea22aaec840d09c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Some Facts about SCCsProof:\u2022Since a and b are strongly connected, there is a directed path from a to b.\u2022Likewise, there is a directed path from b to c.\u2022Combining the two paths, we get a directed path from a to c.\u2022For the same reason, we also get a directed path from c to a.\n76abc\nFact 1:  If vertices a and b are strongly connected, and b and c are strongly connected, then a and c are strongly connected.\nZhiyi HuangCOMP3251Some Facts about SCCs\nProof of a):  \n\u2022It su\ufb03ces to show that for any vertex v, v \u2208 C1 \u222a C2 \u222a \u2026 \u222a Cm.\n\u2022This is equivalent to showing there is an SCC that contains v.\n-Start from a singleton set that contains only vertex v.\n-Repeatedly adding to this set some vertex that is strongly connected to v until we cannot enlarge the set any more. \n-The resulting set is an SSC containing v.77\nFact 2:  Let C1, C2, \u2026, Cm be all the SCCs of a directed graph \u2028G = (V, E).  Then,\n1)C1 \u222a C2 \u222a \u2026 \u222a Cm = V; and\n2)for any Ci \u2260 Cj, we have Ci \u2229 Cj = \u2205.\nZhiyi HuangCOMP3251Some Facts about SCCs\nProof of b):  \n\u2022Suppose for contradiction that there are Ci \u2260 Cj whose intersection is not empty, say, vertex a is in the intersection of Ci and Cj.\n\u2022Since Ci \u2260 Cj, there is a vertex that is not in the intersection, say, vertex b is in Ci but is not in Cj.\n\u2022Since a and b are strongly connected, by \u2028Fact 1, b is strongly connected to any \u2028vertex c in Cj.", "mimetype": "text/plain", "start_char_idx": 32008, "end_char_idx": 33385, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e5fe8c28-7b66-447e-ab5b-fe35687b372b": {"__data__": {"id_": "e5fe8c28-7b66-447e-ab5b-fe35687b372b", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f07308ea-b65f-41eb-a5a8-d2fad64f33be", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "971e95e53162bccdcd928d32daab42d091c405de004f8ff087177818787bd5b6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ae64c893-8820-4906-b899-00284645a751", "node_type": "1", "metadata": {}, "hash": "c1434d781166d7a4c6f217a68fe1cefc512d15f380cdf9833975b01e83c81b8d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Since Ci \u2260 Cj, there is a vertex that is not in the intersection, say, vertex b is in Ci but is not in Cj.\n\u2022Since a and b are strongly connected, by \u2028Fact 1, b is strongly connected to any \u2028vertex c in Cj. So adding b to to Cj gives \u2028a larger strongly connected set, a contradiction.78\nFact 2:  Let C1, C2, \u2026, Cm be all the SCCs of a directed graph \u2028G = (V, E).  Then,\n1)C1 \u222a C2 \u222a \u2026 \u222a Cm = V; and\n2)for any Ci \u2260 Cj, we have Ci \u2229 Cj = \u2205.\nCiCjabc\nZhiyi HuangCOMP3251Some Facts about SCCs\n79\nFact 2:  Let C1, C2, \u2026, Cm be all the SCCs of a directed graph \u2028G = (V, E).  Then,\n1)C1 \u222a C2 \u222a \u2026 \u222a Cm = V; and\n2)for any Ci \u2260 Cj, we have Ci \u2229 Cj = \u2205.\nCorollary:  The set of all SSCs of G = (V, E) forms a partition of the vertex set V.\n\nZhiyi HuangCOMP3251\nSCC1\nSCC2\nSCC3\nSCC4Using DFS to Find SCCs: 1st AttemptSince DFS is so successful for \ufb01nding SCC for undirected graph, it is natural to try DFS to \ufb01nd SCC for directed graph.\n801239811107645\nZhiyi HuangCOMP3251\nSCC1\nSCC2\nSCC3\nSCC4Using DFS to Find SCCs: 1st Attempt\n811239811107645\nexplore(10) \ufb01nds exactly the 4th SCC. \u2028Seems good so far.", "mimetype": "text/plain", "start_char_idx": 33179, "end_char_idx": 34264, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ae64c893-8820-4906-b899-00284645a751": {"__data__": {"id_": "ae64c893-8820-4906-b899-00284645a751", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e5fe8c28-7b66-447e-ab5b-fe35687b372b", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "ac4856ba5ff5f782737acab54450431003e127a42181740f3c278b9ec6c06bf0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "81a96d25-465a-4671-9601-a2a124466295", "node_type": "1", "metadata": {}, "hash": "117a9a9da9a439a02bcb4ddc232a06193b1eae856425ad00e9d58f4710948ea5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "801239811107645\nZhiyi HuangCOMP3251\nSCC1\nSCC2\nSCC3\nSCC4Using DFS to Find SCCs: 1st Attempt\n811239811107645\nexplore(10) \ufb01nds exactly the 4th SCC. \u2028Seems good so far.\nZhiyi HuangCOMP3251\nSCC1\nSCC2\nSCC3\nSCC4Using DFS to Find SCCs: 1st Attempt\n811239811107645\nexplore(10) \ufb01nds exactly the 4th SCC. \u2028Seems good so far.\n911\nZhiyi HuangCOMP3251\nSCC1\nSCC2\nSCC3\nSCC4Using DFS to Find SCCs: 1st Attempt\n821239811107645\nexplore(5) \ufb01nds both the 2nd SCC and the 4th SCC. \u2028We are in trouble!\nZhiyi HuangCOMP3251\nSCC1\nSCC2\nSCC3\nSCC4Using DFS to Find SCCs: 1st Attempt\n821239811107645\nexplore(5) \ufb01nds both the 2nd SCC and the 4th SCC. \u2028We are in trouble!\n91110764\nZhiyi HuangCOMP3251Lesson Learnt\u2022We need choose where to start carefully.\n\u2022But, what is so special about starting from 10 instead of 5?\n83\nSCC1\nSCC2\nSCC3\nSCC41239811107645\nZhiyi HuangCOMP3251Lesson LearntNote:  Any two vertices in a connected component are \u201ckind-of\u201d equivalent; if we can reach one of them, we can reach another.\n\u2022Shrink each strongly connected down to a single meta-vertex. \n\u2022Connect these meta-vertex by the remaining edges.\n84\nSCC1\nSCC2\nSCC3\nSCC41, 2, 34, 5, 6, 789, 10, 11\nZhiyi HuangCOMP3251Lesson LearntFact:  The resulting directed graph must be a DAG.", "mimetype": "text/plain", "start_char_idx": 34100, "end_char_idx": 35325, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "81a96d25-465a-4671-9601-a2a124466295": {"__data__": {"id_": "81a96d25-465a-4671-9601-a2a124466295", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ae64c893-8820-4906-b899-00284645a751", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "800a73ba868cd1c671d072abe2d926b988962517a94118234ad41227e19a1bf3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ef7e1911-8a48-4fa5-b0da-d67bf3c4929b", "node_type": "1", "metadata": {}, "hash": "5737ed517bcca99785fb34e73ffb4612a6591bd75d9c342cba4886b755d7b882", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Shrink each strongly connected down to a single meta-vertex. \n\u2022Connect these meta-vertex by the remaining edges.\n84\nSCC1\nSCC2\nSCC3\nSCC41, 2, 34, 5, 6, 789, 10, 11\nZhiyi HuangCOMP3251Lesson LearntFact:  The resulting directed graph must be a DAG.\n\u2022If there is a cycle, any two vertices in the SCCs in this cycle are strongly connected. \n\u2022So all these vertices should be in one single SCC.\n85\nSCC1\nSCC2\nSCC3\nSCC41, 2, 34, 5, 6, 789, 10, 11\nZhiyi HuangCOMP3251Lesson Learnt\u202210 is in SCC4 that does not have outgoing edges in the meta-graph. So starting from 10 reaches only vertices in SCC4.\n\u20225 is in SCC2 which has an outgoing edge in the meta-graph.\u2028So starting from 5 reaches all SCCs reachable from SCC2 in the meta-graph.\n86\nSCC1\nSCC2\nSCC3\nSCC41, 2, 34, 5, 6, 789, 10, 11\nZhiyi HuangCOMP3251Using DFS to Find SCCs: 2nd AttemptRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and \u2028run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.\n87\nDoes such an SCC always exist during each iteration? Yes. In each iteration, the meta-graph must be a DAG and thus it has a sink SCC without any outgoing edge.\nZhiyi HuangCOMP3251Sample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.", "mimetype": "text/plain", "start_char_idx": 35079, "end_char_idx": 36490, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ef7e1911-8a48-4fa5-b0da-d67bf3c4929b": {"__data__": {"id_": "ef7e1911-8a48-4fa5-b0da-d67bf3c4929b", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "81a96d25-465a-4671-9601-a2a124466295", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "06a029e19929f05294accba12b03c2be8b7264ad47a8a16a896ed61107954e6a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "50e96c4b-0f82-4d4c-9534-9bff8be68473", "node_type": "1", "metadata": {}, "hash": "0f466fb61afd0f78f53becf8c734891855ccf4f54efedd7db3a719b5b81a48c9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "87\nDoes such an SCC always exist during each iteration? Yes. In each iteration, the meta-graph must be a DAG and thus it has a sink SCC without any outgoing edge.\nZhiyi HuangCOMP3251Sample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.\n881239811107645\nZhiyi HuangCOMP3251Sample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.\n89\n1239811107645explore(10)\nZhiyi HuangCOMP3251\nSample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.\n90\n123\n98\n11\n107645\nexplore(10)\u2028explore(8)\nZhiyi HuangCOMP3251\nSample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.\n91\n123\n9\n8\n11\n107645\nexplore(10)\u2028explore(8)\u2028explore(5)\nZhiyi HuangCOMP3251\nSample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.", "mimetype": "text/plain", "start_char_idx": 36104, "end_char_idx": 37531, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "50e96c4b-0f82-4d4c-9534-9bff8be68473": {"__data__": {"id_": "50e96c4b-0f82-4d4c-9534-9bff8be68473", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ef7e1911-8a48-4fa5-b0da-d67bf3c4929b", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "eb013f20380ad8db9f6319a82fd99b23590e4e22841b423d8213bf8f576954e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0a55eedc-829f-46cd-b416-bd569cdf306f", "node_type": "1", "metadata": {}, "hash": "b993c59ed1660644e71eb42ba75ccdc6b450212bb7a615e9dbdc1ddff216647b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Remove all vertices in the SCC containing x.\n91\n123\n9\n8\n11\n107645\nexplore(10)\u2028explore(8)\u2028explore(5)\nZhiyi HuangCOMP3251\nSample RunRepeat until all vertices are visited:\n\u2022Pick a vertex x from an SCC without outgoing edge and run a DFS starting from x to \ufb01nd the SCC containing x.\n\u2022Remove all vertices in the SCC containing x.\n92\n123\n9\n8\n11\n10\n7\n6\n4\n5\nexplore(10)\u2028explore(8)\u2028explore(5)\u2028explore(1)\nZhiyi HuangCOMP3251But, how do we \ufb01nd a sink SCC?1)We will \ufb01rst explain how to \ufb01nd a vertex that is in some source SCC.\n2)Then, we explain how to \ufb01nd a vertex that is in some sink SCC using one extra trick.\n93\nZhiyi HuangCOMP3251But, how do we \ufb01nd a source SCC?1)Run a DFS of G with pre-/post-order numbers.\n2)Identify the vertex s that has been assigned the largest post-order number. Then, s must be in some source SCC of G.\nWhy?\n94\ns\nvThe SSC containing s. Suppose for contradiction that it is not a source, and there is an edge incident to it from a vertex v in some other SSC.\nZhiyi HuangCOMP3251But, how do we \ufb01nd a source SCC?\n95Consider [pre(s), post(s)] and [pre(v), post(v)].\u2028Recall from previous discussion that there are three possible relations between the intervals:\n1)v is an ancestor of s in the DFS tree;\u2028[pre[s], post[s]] is contained in [pre[v], post[v]].\n2)s is an ancestor of v in the DFS tree;\u2028[pre[v], post[v]] is contained in [pre[s], post[s]].\n3)u and v have no ancestor-descendant relation; \u2028[pre[v],post[v]] and [pre[u],post[u]] are disjoint.", "mimetype": "text/plain", "start_char_idx": 37206, "end_char_idx": 38671, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0a55eedc-829f-46cd-b416-bd569cdf306f": {"__data__": {"id_": "0a55eedc-829f-46cd-b416-bd569cdf306f", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "50e96c4b-0f82-4d4c-9534-9bff8be68473", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "7dbb3abec68d686345e49e483d73c218eac1bb20d5f4db57fe7751fbc0403a73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "db8faae0-3523-4ffb-89da-a4ccdfa8bdfc", "node_type": "1", "metadata": {}, "hash": "f72bdb43fe0a5e446a50a819b527a61a90acb57888ef744b67670850380df13d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)s is an ancestor of v in the DFS tree;\u2028[pre[v], post[v]] is contained in [pre[s], post[s]].\n3)u and v have no ancestor-descendant relation; \u2028[pre[v],post[v]] and [pre[u],post[u]] are disjoint.\ns\nv1)Run a DFS of G with pre-/post-order numbers.\n2)Identify the vertex s that has been assigned the largest post-order number. Then, s must be in some source SCC of G.\nWhy?\nZhiyi HuangCOMP3251But, how do we \ufb01nd a source SCC?\n961)v is an ancestor of s in the DFS tree;\u2028[pre[s], post[s]] is contained in [pre[v], post[v]].\nThis is impossible because post[s] > post[v] by our choice of s.\ns\nv1)Run a DFS of G with pre-/post-order numbers.\n2)Identify the vertex s that has been assigned the largest post-order number. Then, s must be in some source SCC of G.\nWhy?\nZhiyi HuangCOMP3251But, how do we \ufb01nd a source SCC?\n972)s is an ancestor of v in the DFS tree;\u2028[pre[v], post[v]] is contained in [pre[s], post[s]].\nIf this is the case, there is a directed path from s to v (in the DFS tree) and a directed path from v to s (by our assumption). So s and v must be in the same SCC, a contradiction.\ns\nv1)Run a DFS of G with pre-/post-order numbers.\n2)Identify the vertex s that has been assigned the largest post-order number. Then, s must be in some source SCC of G.\nWhy?\nZhiyi HuangCOMP3251But, how do we \ufb01nd a source SCC?\n983)s and v have no ancestor-descendant relation; \u2028[pre[v], post[v]] and [pre[s], post[s]] are disjoint.", "mimetype": "text/plain", "start_char_idx": 38477, "end_char_idx": 39893, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "db8faae0-3523-4ffb-89da-a4ccdfa8bdfc": {"__data__": {"id_": "db8faae0-3523-4ffb-89da-a4ccdfa8bdfc", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0a55eedc-829f-46cd-b416-bd569cdf306f", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "539ca43124560495551dfaa999b86e515bf01c18ad19d315340ceefef5ecfa4a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29b165c2-183c-4807-92d0-49b9e848e72d", "node_type": "1", "metadata": {}, "hash": "52937f8245a7b8b32f8a05aa23cf633805b85dc5a7fefcc0feef4f3ff0910501", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "s\nv1)Run a DFS of G with pre-/post-order numbers.\n2)Identify the vertex s that has been assigned the largest post-order number. Then, s must be in some source SCC of G.\nWhy?\nZhiyi HuangCOMP3251But, how do we \ufb01nd a source SCC?\n983)s and v have no ancestor-descendant relation; \u2028[pre[v], post[v]] and [pre[s], post[s]] are disjoint.\nThen, by post[s] > post[v], we get that\npre[v] < post[v] < pre[s] < post[s] pre[v] < pre[s] means that when DFS calls explore(v), s is not visited yet. Since there is a directed path from v to s, DFS would have called explore(s) before exiting explore(v). \u2028So post[s] < post[v], a contradiction.\ns\nv1)Run a DFS of G with pre-/post-order numbers.\n2)Identify the vertex s that has been assigned the largest post-order number. Then, s must be in some source SCC of G.\nWhy?\nZhiyi HuangCOMP3251Finding a sink SCCIdea:  Reverse the direction of every edge in G to get GR. \n1)G and GR have the same set of SCCs\n2)A sink SCC in G is a source SCC in GR, and vice versa.\n99\nSCC1SCC3SCC2SCC4G\nSCC1SCC3SCC2SCC4GR\nsource SCC in GR\nsink SCC in G\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n10012\n39811107645G\n12\n39811107645GR\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;\n3)Pick the vertex x with the largest post[x] in the DFS;", "mimetype": "text/plain", "start_char_idx": 39563, "end_char_idx": 40915, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "29b165c2-183c-4807-92d0-49b9e848e72d": {"__data__": {"id_": "29b165c2-183c-4807-92d0-49b9e848e72d", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "db8faae0-3523-4ffb-89da-a4ccdfa8bdfc", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "28152246ded26589ce7a599bb543b4cad82e47989530dbf1b1c16da54e63d47b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6bb88a23-fc78-439c-aec5-7d03bfae2563", "node_type": "1", "metadata": {}, "hash": "ea9f7b5df83dddad2c952768122c3497c1fb94384b1c508a71899d59f2af24a5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "10012\n39811107645G\n12\n39811107645GR\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;\n3)Pick the vertex x with the largest post[x] in the DFS;\n10112\n39811107645G\n12\n39811107645GR\nZhiyi HuangCOMP3251\nAn E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;\n3)Pick the vertex x with the largest post[x] in the DFS;\n4)explore(x) in G;\n10212\n39811107645G\n12\n39811107645GR\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;\n3)Pick the vertex x with the largest post[x] in the DFS;\n4)explore(x) in G;\n5)Remove all visited vertex;\n10312\n38\n7645G\n12\n38\n7645GR\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;\n3)Pick the vertex x with the largest post[x] in the DFS;\n4)explore(x) in G;\n5)Remove all visited vertex;\n6)Pick the vertex y with the largest post[y] among the remaining vertices;\u2028(y must be at the source SCC of the remaining GR)\n7)Repeat\u202610412\n38\n7645G\n12\n38\n7645GR\nZhiyi HuangCOMP3251\nAn E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;", "mimetype": "text/plain", "start_char_idx": 40698, "end_char_idx": 41965, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6bb88a23-fc78-439c-aec5-7d03bfae2563": {"__data__": {"id_": "6bb88a23-fc78-439c-aec5-7d03bfae2563", "embedding": null, "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "cc0dc2ad-a43f-4398-8bdf-a2ed93d80e74", "node_type": "4", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "046a3974173458c9d120e7d9d8cc506a91c6baa3f41ff6e3525b54a8f62a6489", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29b165c2-183c-4807-92d0-49b9e848e72d", "node_type": "1", "metadata": {"file_name": "S07 Depth-First Search_processed.txt", "source_file": "S07 Depth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S07 Depth-First Search_processed.txt"}, "hash": "b170b26d6fc5cdcccbfc91aec4aea2b4fb478ce46828626d6463b148d6d6c1a1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "6)Pick the vertex y with the largest post[y] among the remaining vertices;\u2028(y must be at the source SCC of the remaining GR)\n7)Repeat\u202610412\n38\n7645G\n12\n38\n7645GR\nZhiyi HuangCOMP3251\nAn E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Run a DFS on GR to \ufb01nd post[v] for every vertex v;\n3)Pick the vertex x with the largest post[x] in the DFS;\n4)explore(x) in G;\n5)Remove all visited vertex;\n6)Pick the vertex y with the largest post[y] among the remaining vertices;\u2028(y must be at the source SCC of the remaining GR)\n7)Repeat\u202610512\n38\n7645G\n12\n38\n7645GR\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Call DFS(GR) to compute the post[u] for every vertex u;\n3)Call DFS(G); when we pick a new starting vertex, we choose a vertex v with the largest post[v] among the unvisited vertices;\n4)Each depth-\ufb01rst search tree computed in step 3) covers a strongly-connected component.\n106\nZhiyi HuangCOMP3251An E\ufb03cient Algorithm for Finding SCCs1)Construct GR;\n2)Call DFS(GR) to compute the post[u] for every vertex u;\n3)Call DFS(G); when we pick a new starting vertex, we choose a vertex v with the largest post[v] among the unvisited vertices;\n4)Each depth-\ufb01rst search tree computed in step 3) covers a strongly-connected component.\n106\nRunning time:  O(|V| + |E|)", "mimetype": "text/plain", "start_char_idx": 41678, "end_char_idx": 42960, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b627187c-2e8c-43cd-bd20-9176bd46ceaf": {"__data__": {"id_": "b627187c-2e8c-43cd-bd20-9176bd46ceaf", "embedding": null, "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "391b810d-540a-40be-914e-9a31306607cf", "node_type": "4", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "300430d5-652e-43b5-8bbb-de8a4445d3d3", "node_type": "1", "metadata": {}, "hash": "1ec7984f9823e3c18164e13313319e8aa35cab6ae4f0380f36aa9113c87b96cd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 8: Breadth-First Search\n(Chapter 4.1 and 4.2)\nZhiyi HuangCOMP3251Some De\ufb01nitionsA path is a sequence of edges in which the end vertex of an edge equals the start vertex of the following edge.\n2abcdA path from a to dabcdNot a path from a to d,\u2028the directions of the\u2028edges are not correct\nZhiyi HuangCOMP3251Some De\ufb01nitionsA path is a sequence of edges in which the end vertex of an edge equals the start vertex of the following edge.\nThe length of a path is the number of edges in this path.\n3abcdA path from a to d\u2028that has length 3\nZhiyi HuangCOMP3251Some De\ufb01nitionsA path is a sequence of edges in which the end vertex of an edge equals the start vertex of the following edge.\nThe length of a path is the number of edges in this path.\nThe distance d(u, v) from u to v is the length of the shortest path (the one with the smallest length) from u to v. \n4uabvcde\nThere are three paths from u to v, and the shortest ones have length three. Thus, d(u,v) = 3.\nZhiyi HuangCOMP3251Single-Source Shortest Paths Problem\n5\nGiven an input directed graph G = (V, E) and a speci\ufb01c vertex \u2028s \u2208 V, \ufb01nd, for every vertex x \u2208 V, the distance from s to x.\nZhiyi HuangCOMP3251Single-Source Shortest Paths ProblemAssumption (for simplicity):  All vertices are reachable from s. Notations: \u2022For any vertex v, let dist(v) = d(s, v).\n\u2022For any k \u2265 0, let Lk be the set of vertices v with dist(v) = k.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1395, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "300430d5-652e-43b5-8bbb-de8a4445d3d3": {"__data__": {"id_": "300430d5-652e-43b5-8bbb-de8a4445d3d3", "embedding": null, "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "391b810d-540a-40be-914e-9a31306607cf", "node_type": "4", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b627187c-2e8c-43cd-bd20-9176bd46ceaf", "node_type": "1", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "a23c5d3c41fc0b321bbfa83a1cc630e118176ef1ccd52fa845acaac3e534ff85", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8e01e8d9-e932-4881-ae80-34c221ecab3b", "node_type": "1", "metadata": {}, "hash": "36c267b3e64c184ed5b66537d70c0913177f3e68729344e374a89e8214e21e17", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022For any k \u2265 0, let Lk be the set of vertices v with dist(v) = k.\n\u2022Let adj(Lk) be the set of vertices that are adjacent to some vertices in Lk, i.e.,\nadj(Lk) = { u : (v, u) \u2208 E for some v \u2208 Lk }\n\u2022In essence, our problem is to \ufb01nd Lk for all k \u2265 0.5\nGiven an input directed graph G = (V, E) and a speci\ufb01c vertex \u2028s \u2208 V, \ufb01nd, for every vertex x \u2208 V, the distance from s to x.\nZhiyi HuangCOMP3251A Simple Idea for Solving the Problem\u2022Initially, we set visited(v) = false for all vertices v. \u2028As soon as we know that v is in Li, we set visited(v) = true.\n6\nZhiyi HuangCOMP3251A Simple Idea for Solving the Problem\u2022Initially, we set visited(v) = false for all vertices v. \u2028As soon as we know that v is in Li, we set visited(v) = true.\u2022We already know L0, which is { s }, and visited(s) = true.\n6\nZhiyi HuangCOMP3251A Simple Idea for Solving the Problem\u2022Initially, we set visited(v) = false for all vertices v. \u2028As soon as we know that v is in Li, we set visited(v) = true.\u2022We already know L0, which is { s }, and visited(s) = true.\u2022We know that L1 is a subset of adj(L0), and in general for any \u2028k \u2265 0, Lk+1 is a subset of adj(Lk).", "mimetype": "text/plain", "start_char_idx": 1330, "end_char_idx": 2456, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8e01e8d9-e932-4881-ae80-34c221ecab3b": {"__data__": {"id_": "8e01e8d9-e932-4881-ae80-34c221ecab3b", "embedding": null, "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "391b810d-540a-40be-914e-9a31306607cf", "node_type": "4", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "300430d5-652e-43b5-8bbb-de8a4445d3d3", "node_type": "1", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "fe40cd783a14dc288ffb8717a764221959ef724ecb40343b3c3f1a3fca2613ef", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c60307c-59f8-47be-8d55-ac3a11d55743", "node_type": "1", "metadata": {}, "hash": "7ce7afa0b2245dd081744717bff71c60e93097d5eff7d98594f31ce2508a4d99", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "6\nZhiyi HuangCOMP3251A Simple Idea for Solving the Problem\u2022Initially, we set visited(v) = false for all vertices v. \u2028As soon as we know that v is in Li, we set visited(v) = true.\u2022We already know L0, which is { s }, and visited(s) = true.\u2022We know that L1 is a subset of adj(L0), and in general for any \u2028k \u2265 0, Lk+1 is a subset of adj(Lk). \u2022Key question:  Given Lk, how can we \ufb01nd Lk+1 from adj(Lk)?\n6\nZhiyi HuangCOMP3251A Simple Idea for Solving the Problem\u2022Initially, we set visited(v) = false for all vertices v. \u2028As soon as we know that v is in Li, we set visited(v) = true.\u2022We already know L0, which is { s }, and visited(s) = true.\u2022We know that L1 is a subset of adj(L0), and in general for any \u2028k \u2265 0, Lk+1 is a subset of adj(Lk). \u2022Key question:  Given Lk, how can we \ufb01nd Lk+1 from adj(Lk)?\u2022Observation:  Suppose we have determined L0, L1, \u2026 , Lk, but not Lk+1, Lk+2, \u2026 Then, for any v in adj(Lk),  \n-if visited(v) = true, then v is in Li for some i \u2264 k;\n-if visited(v) = false, then v is in Lk+1.6\nZhiyi HuangCOMP3251A Simple Idea for Solving the Problem\u2022Initially, we set visited(v) = false for all vertices v. \u2028As soon as we know that v is in Li, we set visited(v) = true.\u2022We already know L0, which is { s }, and visited(s) = true.\u2022We know that L1 is a subset of adj(L0), and in general for any \u2028k \u2265 0, Lk+1 is a subset of adj(Lk).", "mimetype": "text/plain", "start_char_idx": 2458, "end_char_idx": 3797, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0c60307c-59f8-47be-8d55-ac3a11d55743": {"__data__": {"id_": "0c60307c-59f8-47be-8d55-ac3a11d55743", "embedding": null, "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "391b810d-540a-40be-914e-9a31306607cf", "node_type": "4", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8e01e8d9-e932-4881-ae80-34c221ecab3b", "node_type": "1", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "d8afef300c789a5fc9ece22feca9bc1aa311223ae887ff02cc6912a62039c5e7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bd5723d0-7e3b-4025-82b0-715571310a83", "node_type": "1", "metadata": {}, "hash": "235e7d57c89cc705d26480adb483e524ff455379cfe89f6e4de833375b63d308", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022Key question:  Given Lk, how can we \ufb01nd Lk+1 from adj(Lk)?\u2022Observation:  Suppose we have determined L0, L1, \u2026 , Lk, but not Lk+1, Lk+2, \u2026 Then, for any v in adj(Lk),  \n-if visited(v) = true, then v is in Li for some i \u2264 k;\n-if visited(v) = false, then v is in Lk+1.\u2022Hence, given L0, we can \ufb01nd L1 by picking vertices v in adj(L0) with visited(v) = false; and then similarly \ufb01nd L2, L3 \u2026 6\nZhiyi HuangCOMP3251Breadth-First Search (BFS)Breadth-First Search implements the idea directly. Breadth-\ufb01rst means to expand the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier (just like water-front), i.e., the algorithm discovers all vertices in Lk before discovering any vertices Lk+1.\n7abcg\nfdehsource s is vertex a\nfrontier, with \u2028s-distance 0.\nZhiyi HuangCOMP3251\nBreadth-First Search (BFS)Breadth-First Search implements the idea directly. Breadth-\ufb01rst means to expand the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier (just like water-front), i.e., the algorithm discovers all vertices in Lk before discovering any vertices Lk+1.\n8abcg\nfdehsource s is vertex a\nAll nodes next to a form a new frontier with s-distance 1.\nZhiyi HuangCOMP3251\nBreadth-First Search (BFS)Breadth-First Search implements the idea directly. Breadth-\ufb01rst means to expand the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier (just like water-front), i.e., the algorithm discovers all vertices in Lk before discovering any vertices Lk+1.", "mimetype": "text/plain", "start_char_idx": 3798, "end_char_idx": 5360, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bd5723d0-7e3b-4025-82b0-715571310a83": {"__data__": {"id_": "bd5723d0-7e3b-4025-82b0-715571310a83", "embedding": null, "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "391b810d-540a-40be-914e-9a31306607cf", "node_type": "4", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c60307c-59f8-47be-8d55-ac3a11d55743", "node_type": "1", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "2b4674b8850440a560dc292f7ad8862621651bf752452544d480609ee0d5190f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5a2fcac5-4080-4970-a51e-c353607580fa", "node_type": "1", "metadata": {}, "hash": "ae8c5985231de5e4fb6fe00716b1e3893f5132100dbc409c866887ab10f24da5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251\nBreadth-First Search (BFS)Breadth-First Search implements the idea directly. Breadth-\ufb01rst means to expand the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier (just like water-front), i.e., the algorithm discovers all vertices in Lk before discovering any vertices Lk+1.\n9abcg\nfdehsource s is vertex a\nAll undiscovered\nvertices next to a\ns-distance 1 vertex form a new frontier with s-distance 2.\nZhiyi HuangCOMP3251\nBreadth-First Search (BFS)Breadth-First Search implements the idea directly. Breadth-\ufb01rst means to expand the frontier between discovered and undiscovered vertices uniformly across the breadth of the frontier (just like water-front), i.e., the algorithm discovers all vertices in Lk before discovering any vertices Lk+1.\n10abcg\nfdehsource s is vertex a\nAll undiscovered\nvertices next to a\ns-distance 2 vertex form a new frontier with s-distance 3.\nZhiyi HuangCOMP3251Breadth-First Search (BFS)\n11\n\nZhiyi HuangCOMP3251Time Complexity of BFS1)Every vertex will be put in some L[i] exactly once and be checked once. This takes O(|V|) step .\n2)When we explore a vertex, we explore all its adjacency edges once. This takes O(|E|) steps.\nIn sum, the time complexity of BFS is O(|V| + |E|).\n12\nZhiyi HuangCOMP3251Implementation in the Textbook\nNote:  The two implementations are essentially the same.\nExercise:  Give an implementation of DFS similar to the above, using a stack instead of a queue.131)initialize dist(s) = 0 and dist(u) = \u221e for all other u \u2208 V.\n2)initialize queue Q = [s] (a queue containing just s).\n3)while Q is not empty : \n4)    u = eject(Q).", "mimetype": "text/plain", "start_char_idx": 5020, "end_char_idx": 6662, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5a2fcac5-4080-4970-a51e-c353607580fa": {"__data__": {"id_": "5a2fcac5-4080-4970-a51e-c353607580fa", "embedding": null, "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "391b810d-540a-40be-914e-9a31306607cf", "node_type": "4", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "1ebbf03371380f2c16711afbb45e71b082faed8d19956fd717dd36fcfa410c9e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bd5723d0-7e3b-4025-82b0-715571310a83", "node_type": "1", "metadata": {"file_name": "S08 Breadth-First Search_processed.txt", "source_file": "S08 Breadth-First Search", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S08 Breadth-First Search_processed.txt"}, "hash": "a7e40029e36731f0ee1ca8833953d22734f4c632e33b7651c2d777b8e4de7382", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Exercise:  Give an implementation of DFS similar to the above, using a stack instead of a queue.131)initialize dist(s) = 0 and dist(u) = \u221e for all other u \u2208 V.\n2)initialize queue Q = [s] (a queue containing just s).\n3)while Q is not empty : \n4)    u = eject(Q).\n5)    for all edges (u, v) \u2208 E : \n6)        if dist(v) = \u221e : \n7)            inject(Q, v).\n8)            dist(v) = dist(u) + 1.\nZhiyi HuangCOMP3251Retrieving the Shortest PathIn our discussion, we only focused on how to determine dist(u).\nCan we also retrieve the shortest path?\n\u2022This is easy!\n-For each vertex v, let the algorithm remember prev[v], the vertex immediately precedes v in shortest path.\n-To do that, each time that the algorithm discovers a new vertex v through an edge (u, v), let prev[v] = u.\n14\nDFS vs. BFS\nZhiyi HuangCOMP3251Why two di\ufb00erent search algorithms?\n1.When BFS encounters a non-tree edge, it is not easy to check whether it is a back edge.\n2.The \u201cpost-ordering\u201d numbers in BFS are not meaningful.\n3.Same as above.\n4.DFS focuses on going deep instead of using the shortest path.16\nDFS\nBFS\nDetecting cycles\u2714\u27181\nTopological ordering\u2714\u27182\nFinding CCs\u2714\u2714\nFinding SCCs\u2714\u27183\nShortest path problem\u27184\u2714", "mimetype": "text/plain", "start_char_idx": 6401, "end_char_idx": 7578, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "055df13a-4c8a-45ce-afc0-b417230667e8": {"__data__": {"id_": "055df13a-4c8a-45ce-afc0-b417230667e8", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "60e7ace1-cc7b-4fe4-a05d-3a0c569afcbb", "node_type": "1", "metadata": {}, "hash": "077657117a9452e06aa0a5b75429fbde66da81e9c98441889c20a9e867df5ded", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 9: Dijkstra Algorithm\n(Chapter 4.3, 4.4, and 4.5)\nZhiyi HuangCOMP3251Edges with LengthsWe now consider weighted graph, i.e., every edge (u,v) is associated with a length L(u,v).\n2sbcdefgt9231415530442018261116619\nZhiyi HuangCOMP3251Single-Source Shortest Paths Problem \u2028(for Weighted Graphs)De\ufb01nition:  length of a path P is equal to the sum of the length of the edges on P.\n3\nGiven a weighted directed graph and a source vertex s \u2208 V, \ufb01nd, for every vertex v \u2208 V, the length of the shortest path from the source s to v.\nZhiyi HuangCOMP3251An Example\n4sbcdefgt9231415530442018261116619sbcdefgt9231415530442018261116619\nZhiyi HuangCOMP3251An Example\n5sbcdefgt\n9\n231415\n5\n30\n44\n20182\n61116\n6\n19\nNote that this is a tree, and for any vertex v, the tree path from \u2028s to v is the shortest path s to v. Such a tree is called the Shortest Path Tree (SPT).\nZhiyi HuangCOMP3251The BFS tree is a Shortest Path Tree\u2022If all edges have length 1, then BFS solves the shortest path problem and the BFS tree coincides with the SPT tree.\n\u2022An alternative view of BFS:\n-Starting from the smallest subtree of BFS tree that contains only the starting vertex s.\n-Add vertices and the corresponding tree edges one by one in ascending order of their distance from s.\n6abcg\nfdeh\nZhiyi HuangCOMP3251\nGeneral Idea\u2022Starting from the smallest subtree of SPT that contains only s. \n\u2022Iteratively attached a \u201ccorrect\u201d edge to the subtree such that the larger tree is still a subtree of SPT.  \n\u2022When we include all vertices in the subtree, it is the SPT.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1538, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "60e7ace1-cc7b-4fe4-a05d-3a0c569afcbb": {"__data__": {"id_": "60e7ace1-cc7b-4fe4-a05d-3a0c569afcbb", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "055df13a-4c8a-45ce-afc0-b417230667e8", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "0c9d0d896c107dc5825555320006ca53f3c5383e9e5ae09dfc17bbc1eff3b792", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fe6ca578-7fd8-41f0-bc39-64840459f5a8", "node_type": "1", "metadata": {}, "hash": "5fc90f764528490ff324c7f2b09a755c573eb8207f80c127ca86558f694c4f14", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Add vertices and the corresponding tree edges one by one in ascending order of their distance from s.\n6abcg\nfdeh\nZhiyi HuangCOMP3251\nGeneral Idea\u2022Starting from the smallest subtree of SPT that contains only s. \n\u2022Iteratively attached a \u201ccorrect\u201d edge to the subtree such that the larger tree is still a subtree of SPT.  \n\u2022When we include all vertices in the subtree, it is the SPT.\n7suvT: a subtree of SPT\nGrow T by adding v, together with the edge (u, v) to T.A larger T which is still a subtree of SPT\nZhiyi HuangCOMP3251What is the correct vertex/edge?Let T be a subtree of the SPT. Here are a few de\ufb01nitions:\n-A T-path from s to v is a path from s to v that goes through only vertices in T.\n-The T-dist(v) is the length of shortest T-path from s to v. \n-Note that for any vertex v, T-dist(v) \u2265 dist(v), the length of the shortest path from s to v.\n-For every v \u2208 T, T-dist(u) = dist(u).\nExample:\n8\nsuv2410T-dist(v) = 24 + 10 = 34\nZhiyi HuangCOMP3251What is the correct vertex/edge?Observation:  A shortest T-path from s to v, must be consists of a shortest T-path from s to some vertex u \u2208 T and edge (u, v).\n\u2022To determine T-dist(v), we check all vertices u \u2208 T such that \u2028(u, v) \u2208 E, and the corresponding shortest T-path from s to u.\n\u2022Then, determine their total lengths and return the minimum. \nExample:\n9\nsuv2410ab16201918\nT-dist(a) + L(a,v) = 35,\u2028T-dist(u) + L(u,v) = 34,\u2028T-dist(b) + L(b,v) = 38,\u2028so T-dist(v) = 34.\nZhiyi HuangCOMP3251The Algorithm (Informal)\nWhat next? \u2022Why is the above algorithm correct?", "mimetype": "text/plain", "start_char_idx": 1157, "end_char_idx": 2673, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fe6ca578-7fd8-41f0-bc39-64840459f5a8": {"__data__": {"id_": "fe6ca578-7fd8-41f0-bc39-64840459f5a8", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "60e7ace1-cc7b-4fe4-a05d-3a0c569afcbb", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "bef045a6cdd3595f7753578d904ad656cbd7c1c897162efff8537a6d16695611", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8daed4df-7a98-4bd4-8eb4-a07adddb3220", "node_type": "1", "metadata": {}, "hash": "be5b684588e11ed1aa7e3cc358d369c31b2bf1429c637e72d4502647882d46f9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Example:\n9\nsuv2410ab16201918\nT-dist(a) + L(a,v) = 35,\u2028T-dist(u) + L(u,v) = 34,\u2028T-dist(b) + L(b,v) = 38,\u2028so T-dist(v) = 34.\nZhiyi HuangCOMP3251The Algorithm (Informal)\nWhat next? \u2022Why is the above algorithm correct?\n\u2022What is its running time?\n10\nStarting with T = { s } and repeatedly do the following to enlarge T until T includes all vertices:\n\u2022Find the vertex v \u2209 T with the smallest T-dist(v), add it to T;\n\u2022Update the T-dist(x) for all vertices x \u2209 T.\nZhiyi HuangCOMP3251Correctness\nSuppose: -T is a subtree of SPT.\n-v has the smallest T-dist among vertices that are not in T, the the path leaves T through a vertex u \u2208 T.\nWant to show: \n-This path from s to v is indeed the shortest path.11\nsuv2410\nZhiyi HuangCOMP3251Correctness (cont\u2019d)\n12\nsuv2410ab\nZhiyi HuangCOMP3251Correctness (cont\u2019d)\n12\nsuv2410\nBy our choice of v, for all x \u2209 T, T-dist(v) \u2264 T-dist(x)ab\nZhiyi HuangCOMP3251Correctness (cont\u2019d)\n12\nsuv2410\nBy our choice of v, for all x \u2209 T, T-dist(v) \u2264 T-dist(x)ab\nSince going through u is the shortest T-path from s to t, any alternative path from s to v must go through some vertex b \u2209 T, and T-dist(b) \u2265 T-dist(v).\nZhiyi HuangCOMP3251Correctness (cont\u2019d)\n12\nsuv2410\nBy our choice of v, for all x \u2209 T, T-dist(v) \u2264 T-dist(x)ab\nSince going through u is the shortest T-path from s to t, any alternative path from s to v must go through some vertex b \u2209 T, and T-dist(b) \u2265 T-dist(v).", "mimetype": "text/plain", "start_char_idx": 2459, "end_char_idx": 3851, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8daed4df-7a98-4bd4-8eb4-a07adddb3220": {"__data__": {"id_": "8daed4df-7a98-4bd4-8eb4-a07adddb3220", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fe6ca578-7fd8-41f0-bc39-64840459f5a8", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "d737edd9cbd852e2332542faf29e00772b5ff8cd799aa584734b394186de50c7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e512a84-524e-4377-8b16-b352890f4a7d", "node_type": "1", "metadata": {}, "hash": "f4c2ed878aa3784d823364f7a43df45e9fddc2de3b38664289b96a191cc373d3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness (cont\u2019d)\n12\nsuv2410\nBy our choice of v, for all x \u2209 T, T-dist(v) \u2264 T-dist(x)ab\nSince going through u is the shortest T-path from s to t, any alternative path from s to v must go through some vertex b \u2209 T, and T-dist(b) \u2265 T-dist(v).\nThe length of this part from b to v is positive. \u2028(all edges have positive length.)\nZhiyi HuangCOMP3251Correctness (cont\u2019d)Conclusion:  The length of any path P from s to v is no smaller than T-dist(v) because length(P) \u2265 T-dist(b) \u2265 T-dist(v). Hence, the T-path from s to v through u is the shortest path.", "mimetype": "text/plain", "start_char_idx": 3589, "end_char_idx": 4158, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0e512a84-524e-4377-8b16-b352890f4a7d": {"__data__": {"id_": "0e512a84-524e-4377-8b16-b352890f4a7d", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8daed4df-7a98-4bd4-8eb4-a07adddb3220", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "166596f0da9b5fc812c5559a24b4616554b30a86009c4cfd52408fa9a3b7b9bc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "49b5fa49-f2b2-4eaf-9fa4-9b87e954f9ce", "node_type": "1", "metadata": {}, "hash": "66519f79390fa588ce745e9f7652971159f1a65f6fd1d268302d59019ac428f8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The length of this part from b to v is positive. \u2028(all edges have positive length.)\nZhiyi HuangCOMP3251Correctness (cont\u2019d)Conclusion:  The length of any path P from s to v is no smaller than T-dist(v) because length(P) \u2265 T-dist(b) \u2265 T-dist(v). Hence, the T-path from s to v through u is the shortest path.\n13\nsuv2410ab\nZhiyi HuangCOMP3251\nSample Run\n14sab\ncde914152321853020\nT = { s }0Highlighted numbers \u2028denote the length of\u2028of the shortest path from s to a vertex\nZhiyi HuangCOMP3251\nSample Run\n15sab\ncde914152321853020\nT = { s }91415\u221e\u221e0Shaded numbers \u2028denote the current \u2028T-distance of a vertex\nZhiyi HuangCOMP3251\nSample Run\n16sab\ncde914152321853020\nT = { s, a }91415\u221e\u221e0Add the vertex v \u2209 T with the smallest T-dist\nZhiyi HuangCOMP3251\nSample Run\n17sab\ncde914152321853020\nT = { s, a }9111532\u221e0Update T-dist(x) for all x \u2209 T\nZhiyi HuangCOMP3251\nSample Run\n18sab\ncde914152321853020\nT = { s, a, d }9111532\u221e0\nZhiyi HuangCOMP3251\nSample Run\n19sab\ncde914152321853020\nT = { s, a, d }9111529410\nZhiyi HuangCOMP3251\nSample Run\n20sab\ncde914152321853020\nT = { s, a, d, e }9111529410\nZhiyi HuangCOMP3251\nSample Run\n21sab\ncde914152321853020\nT = { s, a, d, e }9111529350\nZhiyi HuangCOMP3251\nSample Run\n22sab\ncde914152321853020\nT = { s, a, d, e, b }9111529350\nZhiyi HuangCOMP3251\nSample Run\n23sab\ncde914152321853020\nT = { s, a, d, e, b, c }9111529350\nZhiyi HuangCOMP3251How to update T-dist(x)?", "mimetype": "text/plain", "start_char_idx": 3852, "end_char_idx": 5237, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "49b5fa49-f2b2-4eaf-9fa4-9b87e954f9ce": {"__data__": {"id_": "49b5fa49-f2b2-4eaf-9fa4-9b87e954f9ce", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e512a84-524e-4377-8b16-b352890f4a7d", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "97b88f2f4cda298c5db0fa6e9b386f41bb1ea8675cd7296c9eb77fbf262da136", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "be50dd89-e34a-4108-b84d-7b30aece13c0", "node_type": "1", "metadata": {}, "hash": "b9be1f83859f0946ece2c6476cba82215ced855a8db80bbe40b0e31aedadea3d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "24\nsaxubv\n\u2022Recall T-dist(x) = min { T-dist(a) + L(a, x) , T-dist(b) + L(b, x) }\n\u2022Suppose the algorithm adds a new vertex v to T.\n-Let T\u2019 denote the new tree. \n-Let T\u2019-dist denote the updated tree-distance.\nZhiyi HuangCOMP3251\nHow to update T-dist(x)?\n25saxubv\n\u2022If there is no edge (v, x), then we have\nT\u2019-dist(x) = min { T\u2019-dist(a) + L(a, x) , T\u2019-dist(b) + L(b, x) }\n\u2022Adding v to T does not change the tree-distance of a and b: T\u2019-dist(a) = T-dist(a), T\u2019-dist(b) = T-dist(b). Hence, no change.\nZhiyi HuangCOMP3251\nHow to update T-dist(x)?\n26saxubv\n\u2022If there is edge (u, x), then T\u2019-dist(x) is equal to\nmin { T\u2019-dist(a) + L(a, x) , T\u2019-dist(b) + L(b, x) , T\u2019-dist(v) + L(v, x) }\n\u2022Note that T-dist and T\u2019-dist are the same for v, a, b. Thus, \nT\u2019-dist(x) = min { T-dist(x) , T-dist(v) + L(v, x) }\nZhiyi HuangCOMP3251\nHow to update T-dist(x)?\n27saxubv\nConclusion:  After adding v to enlarge T, we only need to\n\u2022scan the adjacent list of v in order to update T-dist;\n\u2022for each vertex x in the adjacent list, update its tree-distance as the minimal of the old tree-distance and T-dist(v) + L(v, x).\nZhiyi HuangCOMP3251The Algorithm (DPV 4.1.1)\nRunning time: \u2022Steps 1, 2, 5 take O(|V|) time. Steps 6, 7 takes O(|E|) time.\n\u2022If we implement dist(.)", "mimetype": "text/plain", "start_char_idx": 5238, "end_char_idx": 6476, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "be50dd89-e34a-4108-b84d-7b30aece13c0": {"__data__": {"id_": "be50dd89-e34a-4108-b84d-7b30aece13c0", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "49b5fa49-f2b2-4eaf-9fa4-9b87e954f9ce", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "4ac852eb51ca23f2310452c20fe6e1de34004264fbe002c753fbf5618743a1b7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "99104018-0577-4ea3-ac2d-7c3ee66b79b4", "node_type": "1", "metadata": {}, "hash": "9c4bef38aa738f64d085fab0bdcdde68019671e6a9ae41a8f08b48403f5469ad", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251The Algorithm (DPV 4.1.1)\nRunning time: \u2022Steps 1, 2, 5 take O(|V|) time. Steps 6, 7 takes O(|E|) time.\n\u2022If we implement dist(.) as a simple array, step 4 takes O(|V|) time to \ufb01nd the smallest dist(.), and since we execute step 4 O(|V|) times, total time is O(|V|2).28\n1)initialize dist(s) = 0, and dist(x) = \u221e for other vertices x;\n2)V\u2019 = { };\n3)while V\u2019 \u2260 V do\n4)    pick the node v \u2209 V\u2019 with the smallest dist(.)\n5)    add v to V\u2019                                                                        \n6)    for all edges (v, x) \u2208 E :\n7)        if dist(x) > dist(v) + L(v, x) : update dist(x) = dist(v) + L(v, x).\nZhiyi HuangCOMP3251Priority Queue Implementation\u2022It is usually more e\ufb03cient to store dist(.) in a priority queue, e.g., implemented through binary min heap.\n\u2022Recap of basic properties of binary min heap:\n-Building an empty heap (build-heap): O(1);\n-Finding the minimal number (\ufb01nd-min): O(1);\n-Deleting a the minimal number (delete-min): O(log n).\n-Inserting a new number (insert): O(log n);\n29\nZhiyi HuangCOMP3251Priority Queue Implementation\n30\nsadubvcedist(v)dist(d)dist(c)dist(e)\nZhiyi HuangCOMP3251\nPriority Queue Implementation\n31sadubvcedist(v)dist(d)dist(c)dist(e)\ufb01nd-min\nZhiyi HuangCOMP3251\nPriority Queue Implementation\n32sadubvcedist(d)dist(e)dist(c)delete(v)\nZhiyi HuangCOMP3251\nPriority Queue Implementation\n33sadubvcedist(d)dist(e)Update dist[x] for every x s.t.", "mimetype": "text/plain", "start_char_idx": 6330, "end_char_idx": 7742, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "99104018-0577-4ea3-ac2d-7c3ee66b79b4": {"__data__": {"id_": "99104018-0577-4ea3-ac2d-7c3ee66b79b4", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "be50dd89-e34a-4108-b84d-7b30aece13c0", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "7000b5535fe981d4ec6dc35020a0b75c32ff42be8d5e520c0405227ab5e274ab", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6147262-ba42-491e-b599-af12aa780687", "node_type": "1", "metadata": {}, "hash": "948ed733aa1531c4f27a735bec6fdf3ee4d54f90548f7835c91e127bbf5579b6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "there is edge (v, x); for example, dist[c] may be decrease by some \u0394 > 0.dist(c)-\u0394\nZhiyi HuangCOMP3251\nPriority Queue Implementation\n34sadubvcedist(d)dist(e)Remember, we may need to shift up the new value in order to restore heap order.dist(c)-\u0394\nZhiyi HuangCOMP3251Running time for this implementation\u2022Initially, we set dist(s) = 0, and dist(u) = \u221e for all other vertices u. Then, we insert all n vertices to a heap: O(|V| log |V|) time.\n\u2022We need to delete the minimum value from the heap n times to add n vertices to the SPT: O(|V| log |V|) time.\n\u2022After adding each vertex to the SPT, we need to scan its adjacency list and for each vertex x in the list, we may need to update dist(x) and shift up to restore heap order.\n-The hight of the tree is log |V|, so we need to shift up at most log |V| times per vertex in the adjacency list.\n-Total size of the adjacency lists of all vertices is O(|E|).\n-In total, this takes O(|E| log |V|) time.\n\u2022In sum, the running time is O( (|E| + |V|) log |V| ).35\nZhiyi HuangCOMP3251Advance topic: d-heap implementation\n36Heap3-Heapd-Heapbuild-heapO(1)O(1)O(1)insertO(log n)O(log3 n)O(logd n)\ufb01nd-minO(1)O(1)O(1)delete-minO(log n)O(3 log3 n)O(d logd n)depth \u2028O(logd n)\nZhiyi HuangCOMP3251Advance topic: d-heap implementation\u2022Initially, we set dist(s) = 0, and dist(u) = \u221e for all other vertices u. Then, we insert all n vertices to a heap: O(|V| logd |V|) time.", "mimetype": "text/plain", "start_char_idx": 7743, "end_char_idx": 9137, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b6147262-ba42-491e-b599-af12aa780687": {"__data__": {"id_": "b6147262-ba42-491e-b599-af12aa780687", "embedding": null, "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9ebaed13-13c4-4fb1-958b-1d901b614163", "node_type": "4", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "c199f3c94cbb65d736bc2018c2c5bb240a0641b2a34d96fde8f81bfe4169bd19", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99104018-0577-4ea3-ac2d-7c3ee66b79b4", "node_type": "1", "metadata": {"file_name": "S09 Dijkstra Algorithm_processed.txt", "source_file": "S09 Dijkstra Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S09 Dijkstra Algorithm_processed.txt"}, "hash": "5c928e768dd36d38684279a5d0151f80d0003bdac7251a729d26b5962a2b661f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022We need to delete the minimum value from the heap n times to add n vertices to the SPT: O(|V| d logd |V|) time.\n\u2022After adding each vertex to the SPT, we need to scan its adjacency list and for each vertex x in the list, we may need to update dist(x) and shift up to restore heap order.\n-The hight of the tree is logd |V|, so we need to shift up at most log |V| times per vertex in the adjacency list.\n-Total size of the adjacency lists of all vertices is O(|E|).\n-In total, this takes O(|E| logd |V|) time.\n\u2022Total O( (|E| + d |V|) logd |V|) time.\n\u2022Choosing d = |E|/|V|, the running time is O( |E| log|E|/|V| |V| ).37", "mimetype": "text/plain", "start_char_idx": 9138, "end_char_idx": 9755, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3da069da-4613-4ffa-b703-a6e611c72c9e": {"__data__": {"id_": "3da069da-4613-4ffa-b703-a6e611c72c9e", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a5f3732d-3457-4b62-9ed8-18ddf5d5fcf7", "node_type": "1", "metadata": {}, "hash": "63fab3df486162ed2ebc4c0aed14e960e7e3626ad3f5739c88890fa8ffd54110", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 10: Bellman-Ford Algorithm\n(Chapter 4.6)\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n2\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n2\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n3\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths914152321853020Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n3\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths914152321853020Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251\nRecap: Single-Source Shortest Path\n4\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths914152321853020Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251\nRecap: Single-Source Shortest Path\n5\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths914152321853020Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251\nRecap: Single-Source Shortest Path\n6\nGiven a directed graph with edge lengths and a source vertex s,", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1673, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a5f3732d-3457-4b62-9ed8-18ddf5d5fcf7": {"__data__": {"id_": "a5f3732d-3457-4b62-9ed8-18ddf5d5fcf7", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3da069da-4613-4ffa-b703-a6e611c72c9e", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c4a22cbd4514671d66fab6dda2216c55c0ab79e95bf6412e38295c49720b6e17", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c529181b-c8f6-480a-b65e-8bd66de70ef9", "node_type": "1", "metadata": {}, "hash": "0cbd87972d86790369d60491fff4ee61ba629f22dd67feef6a9b0b612d366485", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths914152321853020Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251\nRecap: Single-Source Shortest Path\n6\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths914152321853020Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n7\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths91415232185302009321115Positive Lengths\nDijkstra AlgorithmdistanceT-dist\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n8\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths91415232185302009321115Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251Recap: Single-Source Shortest Path\n9\nGiven a directed graph with edge lengths and a source vertex s, \ufb01nd the length of the shortest path from s to v for every vertex v.\nBreadth First SearchUnit Lengths9141523218530200929111530Positive Lengths\nDijkstra Algorithm\nZhiyi HuangCOMP3251Today: Negative Edge Lengths\n10sab\ncde9141523-1001853020\u2022Negative lengthes are natural in some applications.\n\u2022The correctness of Dijkstra depends on the fact that no edge has negative weight.\nDijkstra will add this edge to SPT at step 1, and assert dist(a) = 9.\nBut there is a path with distance -86\nZhiyi HuangCOMP3251What goes wrong in the proof of Dijkstra\u2019s correctness with negative edges?", "mimetype": "text/plain", "start_char_idx": 1402, "end_char_idx": 3091, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c529181b-c8f6-480a-b65e-8bd66de70ef9": {"__data__": {"id_": "c529181b-c8f6-480a-b65e-8bd66de70ef9", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a5f3732d-3457-4b62-9ed8-18ddf5d5fcf7", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "8e26027b1dab13076025a16cc2d9b98f0007a5bd86992415d493a00d416d621a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "954bee3a-ec11-47ca-8dce-3057004fea06", "node_type": "1", "metadata": {}, "hash": "c5027df5f3ddf7f91f865da34db3d384f3f3688eaa65fcd2b7f46c2e581127ff", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022The correctness of Dijkstra depends on the fact that no edge has negative weight.\nDijkstra will add this edge to SPT at step 1, and assert dist(a) = 9.\nBut there is a path with distance -86\nZhiyi HuangCOMP3251What goes wrong in the proof of Dijkstra\u2019s correctness with negative edges?\n11\nsuv2410ab\nZhiyi HuangCOMP3251What goes wrong in the proof of Dijkstra\u2019s correctness with negative edges?\n11\nsuv2410\nBy our choice of v\u2028 T-dist(v) \u2264 T-dist(b)ab\nZhiyi HuangCOMP3251What goes wrong in the proof of Dijkstra\u2019s correctness with negative edges?\n11\nsuv2410\nBy our choice of v\u2028 T-dist(v) \u2264 T-dist(b)ab\nSince going through u is the shortest T-path from s to v, any alternative path from s to v must go through some vertex b \u2209 T, and T-dist(b) \u2265 T-dist(v).\nZhiyi HuangCOMP3251What goes wrong in the proof of Dijkstra\u2019s correctness with negative edges?\n11\nsuv2410\nBy our choice of v\u2028 T-dist(v) \u2264 T-dist(b)ab\nSince going through u is the shortest T-path from s to v, any alternative path from s to v must go through some vertex b \u2209 T, and T-dist(b) \u2265 T-dist(v).\nThe length of this part from b to v is positive. \u2028(all edges have positive length.)The red part is \u2028no longer true.\nZhiyi HuangCOMP3251Negative cyclesNote:  \u201cshortest path\u201d is not well de\ufb01ned if the input graph has negative cycles.\n\u2022From s to c, we can traverse the red cycle as many times as we want to get a path with distance as small as we want.\n12sab\ncde9141523-1001853020\nThis lecture: Bellman-Ford algorithmFor graphs that have negative edges, but do not have negative cycle, we can use the Bellman-Ford algorithm to solve the single source shortest path problem.\nZhiyi HuangCOMP3251Negative Lengths??", "mimetype": "text/plain", "start_char_idx": 2806, "end_char_idx": 4469, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "954bee3a-ec11-47ca-8dce-3057004fea06": {"__data__": {"id_": "954bee3a-ec11-47ca-8dce-3057004fea06", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c529181b-c8f6-480a-b65e-8bd66de70ef9", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "aa3bea55a53f7f7bd3f9d0210beeb9feee941748ddade2db90ef6af1cf9aab8a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "27bc06fe-ded1-4ef7-89c8-55d66245f95c", "node_type": "1", "metadata": {}, "hash": "77c525433f7a41aa9500884e909c24b0f3b0814a14f17ef9aa7389368ba416bc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022From s to c, we can traverse the red cycle as many times as we want to get a path with distance as small as we want.\n12sab\ncde9141523-1001853020\nThis lecture: Bellman-Ford algorithmFor graphs that have negative edges, but do not have negative cycle, we can use the Bellman-Ford algorithm to solve the single source shortest path problem.\nZhiyi HuangCOMP3251Negative Lengths??\n14\nZhiyi HuangCOMP3251Negative Lengths??\u2022Suppose Zhiyi will go to New Zealand in reading week and needs some New Zealand dollars\u2028\u2028\u2028\n14\nHK$\nNZ$exch. rate 0.23\nZhiyi HuangCOMP3251Negative Lengths??\u2022Suppose Zhiyi will go to New Zealand in reading week and needs some New Zealand dollars\u2028\u2028\u2028\u2022Or:\u2028\u2028\u2028\u2028\n14\nHK$\nNZ$exch. rate 0.23\nHK$\nJP\u00a5rate 19.36\nNZ$rate 0.012with 19.36\u00d70.012=0.23232\nZhiyi HuangCOMP3251Negative Lengths??\u2022Suppose Zhiyi will go to New Zealand in reading week and needs some New Zealand dollars\u2028\u2028\u2028\u2022Or:\u2028\u2028\u2028\u2028\u2022Or:\n14\nHK$\nNZ$exch.", "mimetype": "text/plain", "start_char_idx": 4093, "end_char_idx": 5003, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "27bc06fe-ded1-4ef7-89c8-55d66245f95c": {"__data__": {"id_": "27bc06fe-ded1-4ef7-89c8-55d66245f95c", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "954bee3a-ec11-47ca-8dce-3057004fea06", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "5b8d16d28c55d214f1ecb0a89b7fd73b944ca1be5a45dbb89548871f73f949a4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "187f38e1-9bf5-4254-b197-7bb86c0cdba9", "node_type": "1", "metadata": {}, "hash": "edb24ab6bed0fbf15aa0891a437509eeac062c0bd901553f8775c7228e884961", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "rate 0.23\nHK$\nJP\u00a5rate 19.36\nNZ$rate 0.012with 19.36\u00d70.012=0.23232\nZhiyi HuangCOMP3251Negative Lengths??\u2022Suppose Zhiyi will go to New Zealand in reading week and needs some New Zealand dollars\u2028\u2028\u2028\u2022Or:\u2028\u2028\u2028\u2028\u2022Or:\n14\nHK$\nNZ$exch. rate 0.23\nHK$\nJP\u00a5rate 19.36\nNZ$rate 0.012with 19.36\u00d70.012=0.23232\nHK$\nEURO \u20acrate 0.12\nJP\u00a5\nNZ$rate 0.012\u2026with 0.12\u00d7\u2026\u00d70.012=0.236\nZhiyi HuangCOMP3251\u201cReduction\u201d to Shortest Path\u2022This is a path with (1) currencies as vertices, (2) exchanges as edges, and (3) exchange rates as \u201cedge weights\u201d\n15\nHK$\nEURO \u20acrate 0.12\nJP\u00a5\nNZ$rate 0.012\u2026with 0.12\u00d7\u2026\u00d70.012=0.236\nZhiyi HuangCOMP3251\u201cReduction\u201d to Shortest Path\u2022This is a path with (1) currencies as vertices, (2) exchanges as edges, and (3) exchange rates as \u201cedge weights\u201d\u2022Goal:  maximizing the product of rates along the path\n15\nHK$\nEURO \u20acrate 0.12\nJP\u00a5\nNZ$rate 0.012\u2026with 0.12\u00d7\u2026\u00d70.012=0.236\nZhiyi HuangCOMP3251\u201cReduction\u201d to Shortest Path\u2022This is a path with (1) currencies as vertices, (2) exchanges as edges, and (3) exchange rates as \u201cedge weights\u201d\u2022Goal:  maximizing the product of rates along the path\u2022Compared to minimizing the sum of edge lengths\n15\nHK$\nEURO \u20acrate 0.12\nJP\u00a5\nNZ$rate 0.012\u2026with 0.12\u00d7\u2026\u00d70.012=0.236\nZhiyi HuangCOMP3251\u201cReduction\u201d to Shortest Path\u2022This is a path with (1) currencies as vertices, (2) exchanges as edges, and (3) exchange rates as \u201cedge weights\u201d\u2022Goal:  maximizing the product of rates along the path\u2022Compared to minimizing the sum of edge lengths\u2022Product vs.", "mimetype": "text/plain", "start_char_idx": 4781, "end_char_idx": 6238, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "187f38e1-9bf5-4254-b197-7bb86c0cdba9": {"__data__": {"id_": "187f38e1-9bf5-4254-b197-7bb86c0cdba9", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "27bc06fe-ded1-4ef7-89c8-55d66245f95c", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "1ad5205b9baa5dd974cc2d6bd59f8cf2768c3425d08fa59fde7e10bd3940642a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fb18bdda-d33f-464a-af39-b408f6e16c41", "node_type": "1", "metadata": {}, "hash": "4e0f8c2d57248908657e23d27bfd53f4f6a0fa32be6a2651b8249bc1751dc320", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Sumlog(abc)=log(a)+log(b)+log(c)\n15\nHK$\nEURO \u20acrate 0.12\nJP\u00a5\nNZ$rate 0.012\u2026with 0.12\u00d7\u2026\u00d70.012=0.236\nZhiyi HuangCOMP3251\u201cReduction\u201d to Shortest Path\u2022This is a path with (1) currencies as vertices, (2) exchanges as edges, and (3) exchange rates as \u201cedge weights\u201d\u2022Goal:  maximizing the product of rates along the path\u2022Compared to minimizing the sum of edge lengths\u2022Product vs. Sumlog(abc)=log(a)+log(b)+log(c)\u2022Maximization vs. Minimizationmaxa+b+c\u21d4min(\u2212a)+(\u2212b)+(\u2212c)15\nHK$\nEURO \u20acrate 0.12\nJP\u00a5\nNZ$rate 0.012\u2026with 0.12\u00d7\u2026\u00d70.012=0.236\nZhiyi HuangCOMP3251Putting together\n16\nZhiyi HuangCOMP3251Putting together\u2022Let there be a vertex for each currency\n16\u2026 \u2026\nHK$\nEURO \u20ac\nJP\u00a5\nNZ$\nUS$\nCN\u00a5\nZhiyi HuangCOMP3251Putting together\u2022Let there be a vertex for each currency\u2022Let there be a directed edge between each pair of currencies with the negative logarithm of exchange rate as \u201clength\u201d\n16\u2026 \u2026\nHK$\nEURO \u20ac\nJP\u00a5\nNZ$\nUS$\nCN\u00a5\u2212ln(0.12)=2.12\u2212ln(0.012)\u22484.42\u2212ln(0.13)\u22482.04\u2212ln(0.94)\u22480.062\u2212ln(7.28)\u2248\u22121.99\u2212ln(1.04)\u2248\u22120.", "mimetype": "text/plain", "start_char_idx": 6239, "end_char_idx": 7224, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fb18bdda-d33f-464a-af39-b408f6e16c41": {"__data__": {"id_": "fb18bdda-d33f-464a-af39-b408f6e16c41", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "187f38e1-9bf5-4254-b197-7bb86c0cdba9", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "387319c62f86a88d5c23e6e9606109a24d01c628943330787711acd32d93b71a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6086d7f6-2bb7-4741-aa32-e8bfedf1aeac", "node_type": "1", "metadata": {}, "hash": "5abe88ba8d1d2d98f85470dae79027328fc6f98248d947499e2159e0ec056b33", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "12)=2.12\u2212ln(0.012)\u22484.42\u2212ln(0.13)\u22482.04\u2212ln(0.94)\u22480.062\u2212ln(7.28)\u2248\u22121.99\u2212ln(1.04)\u2248\u22120.039\nZhiyi HuangCOMP3251Putting together\u2022Let there be a vertex for each currency\u2022Let there be a directed edge between each pair of currencies with the negative logarithm of exchange rate as \u201clength\u201d\u2022Find shortest path from HK$ to NZ$\n16\u2026 \u2026\nHK$\nEURO \u20ac\nJP\u00a5\nNZ$\nUS$\nCN\u00a5\u2212ln(0.12)=2.12\u2212ln(0.012)\u22484.42\u2212ln(0.13)\u22482.04\u2212ln(0.94)\u22480.062\u2212ln(7.28)\u2248\u22121.99\u2212ln(1.04)\u2248\u22120.039\nZhiyi HuangCOMP3251Putting together\u2022Let there be a vertex for each currency\u2022Let there be a directed edge between each pair of currencies with the negative logarithm of exchange rate as \u201clength\u201d\u2022Find shortest path from HK$ to NZ$\n16\u2026 \u2026\nHK$\nEURO \u20ac\nJP\u00a5\nNZ$\nUS$\nCN\u00a5\u2212ln(0.12)=2.12\u2212ln(0.012)\u22484.42\u2212ln(0.13)\u22482.04\u2212ln(0.94)\u22480.062\u2212ln(7.28)\u2248\u22121.99\u2212ln(1.04)\u2248\u22120.039\nnegative cycle\n= \narbitrage \nZhiyi HuangCOMP3251Another view on DijkstraBasic step:  update (u, v) for an edge (u, v) \u2208 E as follows\ndist(v) = min { dist(v), dist(u) + L(u, v) }\nIntuition: \n-dist(v) is the length of the shortest path we have found so far from s to v. \n-Whenever we \ufb01nd a shorter path, we update dist(v).", "mimetype": "text/plain", "start_char_idx": 7144, "end_char_idx": 8250, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6086d7f6-2bb7-4741-aa32-e8bfedf1aeac": {"__data__": {"id_": "6086d7f6-2bb7-4741-aa32-e8bfedf1aeac", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb18bdda-d33f-464a-af39-b408f6e16c41", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "785aaff2c63fa7a9018fce5f579632a4abc48247f4953e0673e0870749ed8121", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c7384d99-8130-4d7b-97f2-75dd0c6b45af", "node_type": "1", "metadata": {}, "hash": "f36c38f31af6fa5f7dffe89bd8fa0e854e7e7815b1a323897ace1d2009535ca8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "v) for an edge (u, v) \u2208 E as follows\ndist(v) = min { dist(v), dist(u) + L(u, v) }\nIntuition: \n-dist(v) is the length of the shortest path we have found so far from s to v. \n-Whenever we \ufb01nd a shorter path, we update dist(v).\n17svuold path with \u2028length dist(v)there is a path from s \u2028to u with length dist(u)\ntogether with edge (u, v)\u2028we may \ufb01nd a shorter \u2028path from s to v\nZhiyi HuangCOMP3251An Example\n18svudist(v) = 12dist(u) = 52before update:\nsvudist(v) = 7dist(u) = 52after update:dist(v) = min { dist(v), dist(u) + L(u, v) }\nZhiyi HuangCOMP3251Bellman-Ford algorithm\u2022Without negative weights, Dijkstra updates edges in a clever order so that the algorithm updates each edge only once.\n\u2022With negative weights, Dijkstra\u2019s clever order no longer works.\n\u2022Bellman-Ford returns to the \u201cstupid\u201d way and updates each edge multiple times:\n191)initialize dist(s) = 0, and dist(x) = \u221e for other vertices x;\n2)do\n3)    for each edge (u, v) in E : \n4)        dist(v) = min { dist(v), dist(u) + L(u, v) }\n5)until there is no more update\nZhiyi HuangCOMP3251Bellman-Ford algorithm\u2022Without negative weights, Dijkstra updates edges in a clever order so that the algorithm updates each edge only once.\n\u2022With negative weights, Dijkstra\u2019s clever order no longer works.", "mimetype": "text/plain", "start_char_idx": 8026, "end_char_idx": 9279, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c7384d99-8130-4d7b-97f2-75dd0c6b45af": {"__data__": {"id_": "c7384d99-8130-4d7b-97f2-75dd0c6b45af", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6086d7f6-2bb7-4741-aa32-e8bfedf1aeac", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c504aee02eecb5c00b9dc86c6b701e88eb368ea41aa74c43d9d8eb32052bb4e9", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "66302d08-b2cb-492d-a660-6e301e33569e", "node_type": "1", "metadata": {}, "hash": "35da0d9a444265560cccfe40bab34063feb228ed0e974fe204001cf82bb788d3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022With negative weights, Dijkstra\u2019s clever order no longer works.\n\u2022Bellman-Ford returns to the \u201cstupid\u201d way and updates each edge multiple times:\n201)initialize dist(s) = 0, and dist(x) = \u221e for other vertices x;\n2)for i from 1 to |V| - 1 :\n3)    for each edge (u, v) in E : \n4)        dist(v) = min { dist(v), dist(u) + L(u, v) }\nZhiyi HuangCOMP3251Bellman-Ford algorithm\u2022Without negative weights, Dijkstra updates edges in a clever order so that the algorithm updates each edge only once.\n\u2022With negative weights, Dijkstra\u2019s clever order no longer works.\n\u2022Bellman-Ford returns to the \u201cstupid\u201d way and updates each edge multiple times:\n201)initialize dist(s) = 0, and dist(x) = \u221e for other vertices x;\n2)for i from 1 to |V| - 1 :\n3)    for each edge (u, v) in E : \n4)        dist(v) = min { dist(v), dist(u) + L(u, v) }\nRunning time: O(|V||E|) = O(|V|3)\nZhiyi HuangCOMP3251Sample Run\n21\n01234567S0A\u221eB\u221eC\u221eD\u221eE\u221eF\u221eG\u221e\nZhiyi HuangCOMP3251Sample Run\n22\n01234567S00A\u221e10B\u221e\u221eC\u221e\u221eD\u221e\u221eE\u221e\u221eF\u221e\u221eG\u221e8\nZhiyi HuangCOMP3251Sample Run\n23", "mimetype": "text/plain", "start_char_idx": 9215, "end_char_idx": 10224, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "66302d08-b2cb-492d-a660-6e301e33569e": {"__data__": {"id_": "66302d08-b2cb-492d-a660-6e301e33569e", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c7384d99-8130-4d7b-97f2-75dd0c6b45af", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c4132df18eaa70d3c87b5cf674c5cb8586f9c823e9734671d2824efa669582d5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b2f54f3b-bd03-49af-a426-4eb16339e99d", "node_type": "1", "metadata": {}, "hash": "ad92e2fda4d5b8c42196178cea6517436cc26ca4949571f6f3c414e2a74861af", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251Sample Run\n22\n01234567S00A\u221e10B\u221e\u221eC\u221e\u221eD\u221e\u221eE\u221e\u221eF\u221e\u221eG\u221e8\nZhiyi HuangCOMP3251Sample Run\n23\n01234567S000A\u221e1010B\u221e\u221e\u221eC\u221e\u221e\u221eD\u221e\u221e\u221eE\u221e\u221e12F\u221e\u221e9G\u221e88\nZhiyi HuangCOMP3251Sample Run\n24\n01234567S0000A\u221e10105B\u221e\u221e\u221e10C\u221e\u221e\u221e\u221eD\u221e\u221e\u221e\u221eE\u221e\u221e128F\u221e\u221e99G\u221e888\nZhiyi HuangCOMP3251Sample Run\n25\n01234567S00000A\u221e101055B\u221e\u221e\u221e106C\u221e\u221e\u221e\u221e11D\u221e\u221e\u221e\u221e\u221eE\u221e\u221e1287F\u221e\u221e999G\u221e8888\nZhiyi HuangCOMP3251Sample Run\n26\n01234567S000000A\u221e1010555B\u221e\u221e\u221e1065C\u221e\u221e\u221e\u221e117D\u221e\u221e\u221e", "mimetype": "text/plain", "start_char_idx": 10136, "end_char_idx": 10527, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b2f54f3b-bd03-49af-a426-4eb16339e99d": {"__data__": {"id_": "b2f54f3b-bd03-49af-a426-4eb16339e99d", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "66302d08-b2cb-492d-a660-6e301e33569e", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "134d9a5c4be7963bc78fc73febaf09b2b6dfe36eba9931cc439323eb2eb55230", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad2e5552-8e36-47d7-8686-c8d4f41a70fc", "node_type": "1", "metadata": {}, "hash": "8cf425c5403a5425640e2adef1d45ff5f1be3c605021bd5b1f1a8dbd6a88be8f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "999G\u221e8888\nZhiyi HuangCOMP3251Sample Run\n26\n01234567S000000A\u221e1010555B\u221e\u221e\u221e1065C\u221e\u221e\u221e\u221e117D\u221e\u221e\u221e\u221e\u221e14E\u221e\u221e12877F\u221e\u221e9999G\u221e88888\nZhiyi HuangCOMP3251Sample Run\n27\n01234567S0000000A\u221e10105555B\u221e\u221e\u221e10655C\u221e\u221e\u221e\u221e1176D\u221e\u221e\u221e\u221e\u221e1410E\u221e\u221e128777F\u221e\u221e99999G\u221e888888\nZhiyi HuangCOMP3251Sample Run\n28\n01234567S00000000A\u221e101055555B\u221e\u221e\u221e106555C\u221e\u221e\u221e\u221e11766D\u221e\u221e\u221e\u221e\u221e14109E\u221e\u221e1287777F\u221e\u221e999999G\u221e8888888\nZhiyi HuangCOMP3251Correctness of Bellman-FordSuppose that G =", "mimetype": "text/plain", "start_char_idx": 10440, "end_char_idx": 10850, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ad2e5552-8e36-47d7-8686-c8d4f41a70fc": {"__data__": {"id_": "ad2e5552-8e36-47d7-8686-c8d4f41a70fc", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b2f54f3b-bd03-49af-a426-4eb16339e99d", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "2d773514fbc5cc4bd3e52ca0bbedb03d0364c7600426a08f1e4f8b419349acdb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d4e696ef-06d2-4283-a467-9e5786e5b7a7", "node_type": "1", "metadata": {}, "hash": "73dfb7056bb7820e99257eb9c739357e4c1451e7ee88e6fefaff443fb604b882", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "4109E\u221e\u221e1287777F\u221e\u221e999999G\u221e8888888\nZhiyi HuangCOMP3251Correctness of Bellman-FordSuppose that G = (V, E) is a weighted directed graph without negative cycles. \nObservation 1:  For every vertex v, there is a shortest path from s to v with at most |V| - 1 edges.\nWhy? -We can assume without loss of generality that there is a shortest path that does not contain any cycle.\n-All the vertices on this shortest path must be distinct; otherwise there is a cycle.\n-Thus, there are at most |V| vertices, and thus at most \u2028|V| - 1 edges on this path.29\nZhiyi HuangCOMP3251Correctness of Bellman-Ford (cont\u2019d)Fact:  dist[v] is no larger than the length of the shortest path from s to v through out the algorithm.\nObservation 2:  For any vertex v, if there is a shortest path from \u2028s to u with i edges, then dist[v] = d(s, v) after the i-th iteration.\n-Prove by mathematical induction.\n-Base case:  obviously true for i = 0 because only s has a shortest path with no edge.\n-Inductive hypothesis:  suppose it is true for iteration i - 1.\n-Consider a shortest path of length i: P = (s, u1, \u2026 , ui-1, v).\n30svui-1shortest path from s to vshortest path from s to ui-1\nZhiyi HuangCOMP3251Correctness of Bellman-Ford (cont\u2019d)\n\u2022Thus, there is a shortest path from s to ui-1 with i - 1 edges.", "mimetype": "text/plain", "start_char_idx": 10755, "end_char_idx": 12026, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d4e696ef-06d2-4283-a467-9e5786e5b7a7": {"__data__": {"id_": "d4e696ef-06d2-4283-a467-9e5786e5b7a7", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad2e5552-8e36-47d7-8686-c8d4f41a70fc", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "2859333689d62e75a7884312ad3028d5914fb5fef22888ab8a1ba7d417402792", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ca5925ba-f690-4092-a934-603344c8ebab", "node_type": "1", "metadata": {}, "hash": "b2b2ef8d4f87652021118c285c94a9f0c3ee508e992e2180151ea2d5501a698e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Consider a shortest path of length i: P = (s, u1, \u2026 , ui-1, v).\n30svui-1shortest path from s to vshortest path from s to ui-1\nZhiyi HuangCOMP3251Correctness of Bellman-Ford (cont\u2019d)\n\u2022Thus, there is a shortest path from s to ui-1 with i - 1 edges.\n\u2022By the inductive hypothesis, we have dist[ui-1] = d(s, ui-1) after iteration i-1.\n\u2022When the algorithm update edge (ui-1, v) at iteration i, \ndist(v) = min { dist(v), dist(ui-1) + L(ui-1, v) } = d(s, v)\n\u2022Note that dist[v] will remain the same hereafter because there are no shorter paths from s to v.31svui-1shortest path from s to vshortest path from s to ui-1\nZhiyi HuangCOMP3251Correctness of Bellman-Ford (cont\u2019d)Observation 1:  For every vertex v, there is a shortest path from s to v with at most |V| - 1 edges.\nObservation 2:  For any vertex v, if there is a shortest path from \u2028s to v with i edges, then dist[v] = d(s, v) after the i-th iteration.\n\u2022When Bellman-Ford terminates, it has iterated |V| - 1 times.\n\u2022By the above observations, dist[v] = d(s, v) when Bellman-Ford terminates.\n32\nOptional Topic:\u2028Shortest Path in DAGs (Chapter 4.7)\nZhiyi HuangCOMP3251Shortest Path in DAGs\u2022Given a Directed Acyclic Graph (DAG) G with possibly negative-length edges, we can solve the single-source shortest path problem in O(|V| + |E|) time.\n\u2022Note:  Since G is a DAG, it does not have any cycle, and thus it does not have any negative cycle.", "mimetype": "text/plain", "start_char_idx": 11779, "end_char_idx": 13167, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ca5925ba-f690-4092-a934-603344c8ebab": {"__data__": {"id_": "ca5925ba-f690-4092-a934-603344c8ebab", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d4e696ef-06d2-4283-a467-9e5786e5b7a7", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "04b92d1e1be4a5b14255b4c1ed08aa9c24c7d5808a82df484a621636e10a9156", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "30c44384-3643-4d52-ab9f-59140664db99", "node_type": "1", "metadata": {}, "hash": "144d8e73afead52a017d4a97f23d09d9cf7201f98f75ec937663bc4b68a133d8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "32\nOptional Topic:\u2028Shortest Path in DAGs (Chapter 4.7)\nZhiyi HuangCOMP3251Shortest Path in DAGs\u2022Given a Directed Acyclic Graph (DAG) G with possibly negative-length edges, we can solve the single-source shortest path problem in O(|V| + |E|) time.\n\u2022Note:  Since G is a DAG, it does not have any cycle, and thus it does not have any negative cycle.\n\u2022Recall:  We can linearize G in a line such that every edge is from left to right by running a DFS in O(|V| + |E|) time.\n34caesbddcesab\nZhiyi HuangCOMP3251Shortest Path in DAGs\n351)initialize dist(s) = 0, and dist(u) = \u221e for all other u \u2208 V\n2)Linearize G;\n3)for each u \u2208 V in linearized order : \n4)    for all edges (u, v), update (u, v) as follows : dist(v) = min { dist(v), dist(u) + L(u, v) }dcesab\nInitially, dist(s) is correct.0\u221e\u221e\u221e\u221e\u221e\nZhiyi HuangCOMP3251Shortest Path in DAGs\n361)initialize dist(s) = 0, and dist(u) = \u221e for all other u \u2208 V\n2)Linearize G;\n3)for each u \u2208 V in linearized order : \n4)    for all edges (u, v), update (u, v) as follows : dist(v) = min { dist(v), dist(u) + L(u, v) }dcesab\nAfter the 1st iteration of the \ufb01rst for loop (step 3), the 1st vertex following s has correct dist(.)", "mimetype": "text/plain", "start_char_idx": 12821, "end_char_idx": 13974, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "30c44384-3643-4d52-ab9f-59140664db99": {"__data__": {"id_": "30c44384-3643-4d52-ab9f-59140664db99", "embedding": null, "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "9902006e-65e3-41c5-9933-ab84e016afd6", "node_type": "4", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "c49478c0754157d46e7006381cb21bc964de90ccbdcce46af9e1053118f3e84e", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ca5925ba-f690-4092-a934-603344c8ebab", "node_type": "1", "metadata": {"file_name": "S10 Bellman-Ford_processed.txt", "source_file": "S10 Bellman-Ford", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S10 Bellman-Ford_processed.txt"}, "hash": "6231a767ebf5de76478cf852e426145c1910205826046bfdba4433057bfc17fa", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "value.011\u221e\u221e\u221e\nZhiyi HuangCOMP3251Shortest Path in DAGs\n371)initialize dist(s) = 0, and dist(u) = \u221e for all other u \u2208 V\n2)Linearize G;\n3)for each u \u2208 V in linearized order : \n4)    for all edges (u, v), update (u, v) as follows : dist(v) = min { dist(v), dist(u) + L(u, v) }dcesab011\u221e\u221e\u221e\nAfter the i-th iteration of the \ufb01rst for loop (step 3), the i-th vertex following s has correct dist(.) value.", "mimetype": "text/plain", "start_char_idx": 13975, "end_char_idx": 14370, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d1492e08-6161-49cd-94b1-551aa42e75c9": {"__data__": {"id_": "d1492e08-6161-49cd-94b1-551aa42e75c9", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b939572a-9ca0-450a-a0e5-c2cd904da8a4", "node_type": "1", "metadata": {}, "hash": "44de29d47c97de6f728a2139813621766922c39397aad21e758a49fa3e1df06b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 11: Prim's Algorithm \u2028(Chapter 5.1)\nZhiyi HuangCOMP3251Recap of Graph AlgorithmsDFS is much like walking in a maze:\n-Basic exploration step:  When reaching some vertex u, pick an adjacent vertex v and (recursively) explore v.\n-If we hit a dead end, backtrack.\n-Mark visited vertices and do not re-visit them.\n-Applications:  detecting cycles, topological ordering, \ufb01nding strongly connected components\nBFS is like expanding water front:\n-We \ufb01rst visit all vertices that are directly adjacent to the root s, then all vertices that have distance 2 from s, etc.\n-Applications:  single-source shortest path problem when all edges have length 1.2\nZhiyi HuangCOMP3251Recap of Graph AlgorithmsDijkstra solves the single-source shortest path problem with non-negative edge lengths:\n-Similar to BFS, it explore vertices in ascending order of their distance from the root vertex s.\n-Dijkstra\u2019s greedy rule along with a non-trivial priority heap implementation allows us to do it in nearly linear time.\nBellman-Ford solves the single-source shortest path problem with arbitrary edge lengths and without negative cycles.\n3\nZhiyi HuangCOMP3251Greedy AlgorithmsGreedy algorithms build up a solution piece by piece, always choosing the next piece that o\ufb00ers the most obvious and immediate bene\ufb01t.\nExample 1:  Finish the homework assignment with the closest deadline \ufb01rst.\nExample 2:  Dijkstra's algorithm is a greedy algorithm that gives us the shortest path tree (SPT).\n4\nZhiyi HuangCOMP3251Example 1:  Job SchedulingInput:  A set of n jobs (homework assignments), \u2028where each job j is associated with a size sj and a deadline dj.\nOutput:  An assignment of jobs to time slots such that:\n1)each job gets a number of time slots that equals its size;\n2)each job is completed before its corresponding deadline.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1809, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b939572a-9ca0-450a-a0e5-c2cd904da8a4": {"__data__": {"id_": "b939572a-9ca0-450a-a0e5-c2cd904da8a4", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d1492e08-6161-49cd-94b1-551aa42e75c9", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "d26fecb9d65172906b032bec268ba4448e2b561a489af6c56af19ef58e8390af", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6662634b-449a-4f2a-a389-cf2112dfb8ad", "node_type": "1", "metadata": {}, "hash": "6c21f9235f4234f9c81e5783e6d72d379f0704030d75cc18573069b1251dc3cb", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "4\nZhiyi HuangCOMP3251Example 1:  Job SchedulingInput:  A set of n jobs (homework assignments), \u2028where each job j is associated with a size sj and a deadline dj.\nOutput:  An assignment of jobs to time slots such that:\n1)each job gets a number of time slots that equals its size;\n2)each job is completed before its corresponding deadline.\nExample: \n5jobs12345size12122deadline24589time12345678910job assignment1-2234455-\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028\n6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.\n6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.Proof.  (Assume for simplicity that d1 < d2 < \u2026 < dn.)\n6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.Proof.  (Assume for simplicity that d1 < d2 < \u2026 < dn.", "mimetype": "text/plain", "start_char_idx": 1473, "end_char_idx": 3165, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6662634b-449a-4f2a-a389-cf2112dfb8ad": {"__data__": {"id_": "6662634b-449a-4f2a-a389-cf2112dfb8ad", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b939572a-9ca0-450a-a0e5-c2cd904da8a4", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "41c11939ff686dc517b9ff5644ce5ed833da2a3652227b82e1b7d6f4e8178fb5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "15559778-461f-4d10-b7f4-517d286b4384", "node_type": "1", "metadata": {}, "hash": "ea372686fafa14c0e15015943a9d5993a28f64ba4f1337dbee0998b1b17b07ef", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.Proof.  (Assume for simplicity that d1 < d2 < \u2026 < dn.)-The \ufb01rst s1 time slots are assigned to job 1, the next s2 time slots are assigned to job 2, and so on.\n6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.Proof.  (Assume for simplicity that d1 < d2 < \u2026 < dn.)-The \ufb01rst s1 time slots are assigned to job 1, the next s2 time slots are assigned to job 2, and so on.-Let j be a job that is not completed by its deadline.\n6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.Proof.  (Assume for simplicity that d1 < d2 < \u2026 < dn.", "mimetype": "text/plain", "start_char_idx": 2791, "end_char_idx": 4177, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "15559778-461f-4d10-b7f4-517d286b4384": {"__data__": {"id_": "15559778-461f-4d10-b7f4-517d286b4384", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6662634b-449a-4f2a-a389-cf2112dfb8ad", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "06f6bc1a0767ba0e280bfd565c363de33aa6d8c03d56d719e855ffeb70b79b73", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "54aaf650-63de-4e82-a5ac-995f4bb6d0ef", "node_type": "1", "metadata": {}, "hash": "b219034afc985fcf45bb01416c4aab33eefad592e004c09d8e6e5854ddf12a9a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "6\nZhiyi HuangCOMP3251Greed is good!A greedy algorithm for job scheduling:  \u2028Finish the job (homework assignment) with the closest deadline, and then the job with the second closest deadline, and so on.\u2028Claim.  If the greedy algorithm fails to \ufb01nd a feasible schedule, then the input jobs do not admit a feasible schedule.Proof.  (Assume for simplicity that d1 < d2 < \u2026 < dn.)-The \ufb01rst s1 time slots are assigned to job 1, the next s2 time slots are assigned to job 2, and so on.-Let j be a job that is not completed by its deadline.-That means, s1 + s2 + \u2026 + sj > dj, namely, the amount of work that has to be done from time 1 to time dj is more than dj!6\nZhiyi HuangCOMP3251Dijkstra Algorithm as a Greedy AlgorithmInput:  A directed graph G = (E, V), where each edge (u, v) is associated with a length L(u, v), and a starting vertex s.\nOutput:  A Shortest Path Tree (SPT) rooted at s.\nDijkstra Algorithm: \n\u2022Starting from the smallest subtree of SPT that contains only s. \n\u2022Iteratively attached a \u201ccorrect\u201d edge to the subtree such that the larger tree is still a subtree of SPT.  \n7\nsuvT: a subtree of SPT\nGrow T by adding v with the minimum \u2028T-distance.\nThis Lecture:\u2028A Greedy Algorithm for the \u2028Minimum Spanning Tree Problem\nZhiyi HuangCOMP3251Spanning TreeDe\ufb01nition.  Given a connected undirected graph G = (V, E), a spanning tree of G is a subset of edges that forms a tree that contains all the vertices.\u2028Examples: -Connecting all cities in a country by building the minimum number of highways.\n-Building a network that connects a set of hubs using the minimum number of cables.", "mimetype": "text/plain", "start_char_idx": 3803, "end_char_idx": 5387, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "54aaf650-63de-4e82-a5ac-995f4bb6d0ef": {"__data__": {"id_": "54aaf650-63de-4e82-a5ac-995f4bb6d0ef", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "15559778-461f-4d10-b7f4-517d286b4384", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "136d2d30cdb6978344213d660c45bb6cd87c9a6cca476b073d5c238becaa4ccb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4e7b27c1-9a4e-47e9-a000-acf365fe20b9", "node_type": "1", "metadata": {}, "hash": "3cfbf266a469cc668e74677569ed76719f6563c6fe283d8b72ec8af75555d937", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Given a connected undirected graph G = (V, E), a spanning tree of G is a subset of edges that forms a tree that contains all the vertices.\u2028Examples: -Connecting all cities in a country by building the minimum number of highways.\n-Building a network that connects a set of hubs using the minimum number of cables.\u2028Solutions: -BFS or DFS (the BFS and DFS trees are spanning trees if the graph is connected).9\nZhiyi HuangCOMP3251Minimum Spanning TreeDe\ufb01nition:  Given a connected undirected graph G = (V, E) in which every edge e \u2208 E is associated with a positive weight w(e), a minimum spanning tree (MST) is a subset of edges T \u2286 E s.t.\n(i)T forms a spanning tree; and\n(ii)the sum of edge weights of T is minimized.\nExample:\n106531217345317\nFor the short path problem, each edge is associated with a length. For the MST problem, each edge is associated with a weight.w(T) = 16\nZhiyi HuangCOMP3251Two Useful Properties1.Removing an edge in a cycle will not disconnect a graph.\n2.Let G = (V, E) be an undirected graph. The following three statements are equivalent:\n-G is a spanning tree.\n-G is connected and does not have any cycle.\n-G is connected and has |V| - 1 edges.\n11\nZhiyi HuangCOMP3251Two Greedy Algorithms for MSTPrim\u2019s algorithm (this lecture) -Start with some root node s and grow a tree T outward. \n-At each step, add the minimum weight outgoing edge. \n-This algorithm is almost the same as the Dijkstra's algorithm, except that we add the outgoing edge with the minimum weight, not the one with minimum T-distance.\nKruskal\u2019s algorithm (sequel lectures) -Start with T being the empty tree. \n-Consider edges in ascending order of cost; insert edge e in T unless doing so would create a cycle.12\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n131)Start with some root node s and grow a tree T outward.", "mimetype": "text/plain", "start_char_idx": 5075, "end_char_idx": 6890, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4e7b27c1-9a4e-47e9-a000-acf365fe20b9": {"__data__": {"id_": "4e7b27c1-9a4e-47e9-a000-acf365fe20b9", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "54aaf650-63de-4e82-a5ac-995f4bb6d0ef", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "219ad2bce13af8f7c78c326c3ce2d26429f0c14b7ebda73880642ac0a42f040f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "dcb8b949-a400-4033-a6cc-153076c4edf0", "node_type": "1", "metadata": {}, "hash": "fd5ecd526cfb5dcd8bb2e4ae5cc7f43fefc3fbd2d941060fdbfa38e6b9154dda", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Kruskal\u2019s algorithm (sequel lectures) -Start with T being the empty tree. \n-Consider edges in ascending order of cost; insert edge e in T unless doing so would create a cycle.12\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n131)Start with some root node s and grow a tree T outward. \n2)At each step, add the minimum weight outgoing edge.\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n141)Start with some root node s and grow a tree T outward. \n2)At each step, add the minimum weight outgoing edge.653121734Initially, we start from a root node s\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n151)Start with some root node s and grow a tree T outward. \n2)At each step, add the minimum weight outgoing edge.6531217343At step one, there are two outgoing edges with \u2028weight 3 and 5; add the edge with weight 3.\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n161)Start with some root node s and grow a tree T outward. \n2)At each step, add the minimum weight outgoing edge.65312173453\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n171)Start with some root node s and grow a tree T outward. \n2)At each step, add the minimum weight outgoing edge.653121734531\nZhiyi HuangCOMP3251Prim's Algorithm (Chapter 5.1.5)\n181)Start with some root node s and grow a tree T outward. \n2)At each step, add the minimum weight outgoing edge.6531217345317\nZhiyi HuangCOMP3251Correctness of Prim's AlgorithmLemma.  Let S \u2286 V be any subset of vertices, and let e \u2208 E be the outgoing edge of S with the smallest weight (call this edge the minimum outgoing edge of S). Then the MST T* contains e.\nProof.", "mimetype": "text/plain", "start_char_idx": 6602, "end_char_idx": 8203, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "dcb8b949-a400-4033-a6cc-153076c4edf0": {"__data__": {"id_": "dcb8b949-a400-4033-a6cc-153076c4edf0", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4e7b27c1-9a4e-47e9-a000-acf365fe20b9", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "f8e5e8673bf4ead1eee6a2f61c33b1b04bb0d9c144f53ee101c6c4f37c09c454", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "416032bc-6ec5-40f4-bcbc-c0dabef88a69", "node_type": "1", "metadata": {}, "hash": "d69fd69404c1baf5cc5bceb3af27da48119e667b077229cb5c96da0c287a4f00", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2)At each step, add the minimum weight outgoing edge.6531217345317\nZhiyi HuangCOMP3251Correctness of Prim's AlgorithmLemma.  Let S \u2286 V be any subset of vertices, and let e \u2208 E be the outgoing edge of S with the smallest weight (call this edge the minimum outgoing edge of S). Then the MST T* contains e.\nProof. (exchange argument)\n-To simplify the discussion, we assume that all edges have distinct weights. In this case, the MST is unique.\n-Suppose e does not belong to T*.\n19 e S\nZhiyi HuangCOMP3251Correctness of Prim's AlgorithmLemma.  Let S \u2286 V be any subset of vertices, and let e \u2208 E be the outgoing edge of S with the smallest weight (call this edge the minimum outgoing edge of S). Then the MST T* contains e.\nProof. (exchange argument)\n-Adding e to T* creates a cycle C (the red edges) in T*.\n-There must be an edge in the cycle other than e which bring us from inside S to outside, say, e\u2019.\n20 e S e\u2019 \nZhiyi HuangCOMP3251Correctness of Prim's AlgorithmLemma.  Let S \u2286 V be any subset of vertices, and let e \u2208 E be the outgoing edge of S with the smallest weight (call this edge the minimum outgoing edge of S). Then the MST T* contains e.\nProof. (exchange argument)\n-By our assumption, w(e\u2019) > w(e).\n21 e S e\u2019 \nZhiyi HuangCOMP3251Correctness of Prim's AlgorithmLemma.  Let S \u2286 V be any subset of vertices, and let e \u2208 E be the outgoing edge of S with the smallest weight (call this edge the minimum outgoing edge of S). Then the MST T* contains e.\nProof. (exchange argument)\n-Removing e\u2019 from T* and adding e to it, we get another spanning tree whose total weight of edges is smaller.", "mimetype": "text/plain", "start_char_idx": 7893, "end_char_idx": 9488, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "416032bc-6ec5-40f4-bcbc-c0dabef88a69": {"__data__": {"id_": "416032bc-6ec5-40f4-bcbc-c0dabef88a69", "embedding": null, "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c9e863b1-6a1c-494c-8cd3-812888e067cc", "node_type": "4", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "1e550989364c4b2740bb52bfc728c253b75cd0d5792cabc1f1f3c9bcef876333", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "dcb8b949-a400-4033-a6cc-153076c4edf0", "node_type": "1", "metadata": {"file_name": "S11 Prims Algorithm_processed.txt", "source_file": "S11 Prims Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S11 Prims Algorithm_processed.txt"}, "hash": "338d8933c651063ec45539521a446c82ea22283988b614b20ebf71c8429b1b63", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Let S \u2286 V be any subset of vertices, and let e \u2208 E be the outgoing edge of S with the smallest weight (call this edge the minimum outgoing edge of S). Then the MST T* contains e.\nProof. (exchange argument)\n-Removing e\u2019 from T* and adding e to it, we get another spanning tree whose total weight of edges is smaller.\n22 e S e\u2019 \nZhiyi HuangCOMP3251Prim's Algorithm \u2028[Jarn\u00edk \u201930, Prim \u201957, Dijkstra \u201959]\nCorrectness:  Follow from the previous Lemma.\nRunning Time: (leave as exercise)\n-Key question:  How to e\ufb03ciently \ufb01nd the edge in step 4?\n-Hint:  This is the similar to the Dijkstra's algorithm.\n-O( (|E| + |V|) log |V| ) if we use a binary heap implementation.\n-O(|E| log|E|/|V| |V|) using d-heap for an appropriate value of d.231)Choose the starting node s arbitrarily;\n2)initialize S = { s } and T = { };\n3)for i = 1 to |V| - 1 :\n4)    add the outgoing edge from S with minimum weight to T;\n5)    add the corresponding new vertex to S.", "mimetype": "text/plain", "start_char_idx": 9173, "end_char_idx": 10110, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0b6ffb33-51dd-4ad6-bfc4-f17c019683e1": {"__data__": {"id_": "0b6ffb33-51dd-4ad6-bfc4-f17c019683e1", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a567e4f6-51d8-4c76-bbde-14c6fc05f458", "node_type": "1", "metadata": {}, "hash": "d55cc3ec65ec20754208bd77dcdafec28859716443c7328c60ffa6524380e7f6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "COMP3251\u2028Lecture 12: Kruskal's Algorithm (Chapter 5.1)\nZhiyi HuangCOMP3251Minimum Spanning TreeDe\ufb01nition:  Given a connected undirected graph G = (V, E) in which every edge e \u2208 E is associated with a positive weight w(e), a minimum spanning tree (MST) is a subset of edges T \u2286 E s.t.\n(i)T forms a spanning tree; and\n(ii)the sum of edge weights of T is minimized.\nExample:\n26531217345317w(T) = 16\nZhiyi HuangCOMP3251Two Greedy Algorithms for MSTPrim\u2019s algorithm (last lecture) -Start with some root node s and grow a tree T outward. \n-At each step, add the minimum weight outgoing edge. \n-This algorithm is almost the same as the Dijkstra's algorithm, except that we add the outgoing edge with the minimum weight, not the one with minimum T-distance.\nKruskal\u2019s algorithm (this lecture) -Start with T being the empty forest. \n-Consider edges in ascending order of cost; insert edge e in T unless doing so would create a cycle.3\nZhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n41)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n5653121734Initially, T contains no edges.1)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n6653121734At step 1, the minimum weight edge \u2028we could add has weight 1.11)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1643, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a567e4f6-51d8-4c76-bbde-14c6fc05f458": {"__data__": {"id_": "a567e4f6-51d8-4c76-bbde-14c6fc05f458", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0b6ffb33-51dd-4ad6-bfc4-f17c019683e1", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "d564df657bb78c89fddb93b7b5be39d3d13a75e3b29f34d981bededdb816ae82", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "caf5be9f-4350-4e36-995f-120abe976a4e", "node_type": "1", "metadata": {}, "hash": "828d85d3df3957bbc28f71e73b902699542104bcf9ff2442796c73614113f2a1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n6653121734At step 1, the minimum weight edge \u2028we could add has weight 1.11)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n765312173431At step 2, the minimum weight edge \u2028we could add has weight 3.1)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n8653121734531At step 3, the minimum weight edge \u2028we could add has weight 5.1)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Kruskal\u2019s Algorithm (Chapter 5.1.3)\n96531217345317At step 4, the edge with weight 6 creates a cycle, \u2028so we add the edge with weight 7 instead.1)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s AlgorithmProof by picture: -Recall that if e is the minimum weight outgoing edge of some subset of vertices S, then the MST must contain e.\n-For every edge e we add in the sample run, we will explain the subset of vertices S for which e is the minimum weight outgoing edge of S, certifying e must be in the MST.", "mimetype": "text/plain", "start_char_idx": 1370, "end_char_idx": 2858, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "caf5be9f-4350-4e36-995f-120abe976a4e": {"__data__": {"id_": "caf5be9f-4350-4e36-995f-120abe976a4e", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a567e4f6-51d8-4c76-bbde-14c6fc05f458", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e08f75f59d8645e6987aeb0e0e476d8df1373fdce731c3a2038fdd6b3ad00a2e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5d4b4a1d-cbeb-4a7b-8430-c0a6368cdd16", "node_type": "1", "metadata": {}, "hash": "b457709ab8961039aa10396b239f130ec42c81a96af84c9baabf9c57ffb5709e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness of Kruskal\u2019s AlgorithmProof by picture: -Recall that if e is the minimum weight outgoing edge of some subset of vertices S, then the MST must contain e.\n-For every edge e we add in the sample run, we will explain the subset of vertices S for which e is the minimum weight outgoing edge of S, certifying e must be in the MST.\n10cgdfe7214910bhai481182714\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n11cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n12cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(h,g) is the minimum weight edge \u2028going out from S = { h }.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n13cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(i,c) is the minimum weight edge \u2028going out from S = { c }.", "mimetype": "text/plain", "start_char_idx": 2503, "end_char_idx": 3499, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5d4b4a1d-cbeb-4a7b-8430-c0a6368cdd16": {"__data__": {"id_": "5d4b4a1d-cbeb-4a7b-8430-c0a6368cdd16", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "caf5be9f-4350-4e36-995f-120abe976a4e", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "c0fa56332df91ae6a7ab364f2009a6350440f84fb4a114b30dd72b8a62403288", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "17f86ef6-2bd5-4f38-93ca-ca669c2829f9", "node_type": "1", "metadata": {}, "hash": "00574c0afd5d1c04a11f348639a6e4e5e86a6ad6ee2a216a702d1ff572a8da3f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n13cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(i,c) is the minimum weight edge \u2028going out from S = { c }.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n14cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(g,f) is the minimum weight edge \u2028going out from S = { f }.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n15cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(a,b) is the minimum weight edge \u2028going out from S = { a }.", "mimetype": "text/plain", "start_char_idx": 3276, "end_char_idx": 3947, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "17f86ef6-2bd5-4f38-93ca-ca669c2829f9": {"__data__": {"id_": "17f86ef6-2bd5-4f38-93ca-ca669c2829f9", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5d4b4a1d-cbeb-4a7b-8430-c0a6368cdd16", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "531e919f662b99ceae8490630edceffdb1ed0264165624531b9ab04cc3367fff", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e81fcac5-a6d4-4985-97d9-1459bfc32744", "node_type": "1", "metadata": {}, "hash": "8881a991ac40e2a47b7a7fe70b9d36336873f1be659d3077d6d06d70c0459388", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n15cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(a,b) is the minimum weight edge \u2028going out from S = { a }.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n16cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n16cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(c,f) is the minimum weight edge \u2028going out from S = { c, i }.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n17cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n17cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(c,d) is the minimum weight edge \u2028going out from S = { d }.", "mimetype": "text/plain", "start_char_idx": 3724, "end_char_idx": 4728, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e81fcac5-a6d4-4985-97d9-1459bfc32744": {"__data__": {"id_": "e81fcac5-a6d4-4985-97d9-1459bfc32744", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "17f86ef6-2bd5-4f38-93ca-ca669c2829f9", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "d874bc33969f98b01775c002864bc285c0ebb93126798e764288453c180f2386", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a330f51c-e3ec-4f04-97c9-3ea61db49426", "node_type": "1", "metadata": {}, "hash": "10771a3cb2271902bb2f68e74ade482b8c1e16ae46ccdd0122f48358fbbdf7b0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n18cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n18cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(h,i) cannot be added to the solution\u2028because doing so would create a cycle.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n19cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n19cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(b,c) is the minimum weight edge \u2028going out from S = { a, b }.", "mimetype": "text/plain", "start_char_idx": 4729, "end_char_idx": 5526, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a330f51c-e3ec-4f04-97c9-3ea61db49426": {"__data__": {"id_": "a330f51c-e3ec-4f04-97c9-3ea61db49426", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e81fcac5-a6d4-4985-97d9-1459bfc32744", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "a4325e74abf07d319ffda387a6b4de058d1893f1d296e1f55a3338f47a66578f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03a8645c-1bd3-4632-ac9f-4434b4085650", "node_type": "1", "metadata": {}, "hash": "e79a28e3934a4077027e5c9d56b7efe2080f3a3d658b15ef3691edcba5c15570", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n20cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n20cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(a,h) cannot be added to the solution\u2028because doing so would create a cycle.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n21cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n21cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14(d,e) is the minimum weight edge \u2028going out from S = { e }.", "mimetype": "text/plain", "start_char_idx": 5527, "end_char_idx": 6321, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "03a8645c-1bd3-4632-ac9f-4434b4085650": {"__data__": {"id_": "03a8645c-1bd3-4632-ac9f-4434b4085650", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a330f51c-e3ec-4f04-97c9-3ea61db49426", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "ca64c5d5d7d0a92a26259dcfaa856c3f29b7a0a41a1e0565ed7d8726ac7abbfd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5bf06c3a-a7ab-473d-9240-2869a15683e4", "node_type": "1", "metadata": {}, "hash": "78119e69280406bb85f8c5dce0865c628b16149ce55314cb88a26b70588eb84c", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n22cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s Algorithm\n22cgdfe63141011bhai491282715(h,g)1(i,c)2(g,f)3(a,b)4(c,f)5(c,d)6(h,i)7(b,c)8(a,h)9(d,e)10(e,f)11(b,h)12(d,f)14We already have |V|-1 edges. So adding any \u2028of the remaining edges would create a cycle.\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s AlgorithmFact 1.  The algorithm adds an edge only if it is in the MST. Key question:  Why we can always \ufb01nd a subset of vertices S such that e is the minimum weight outgoing edge from S? -Throughout the algorithm, we have a set of subtrees.\n-We add an edge e only if it does not create any cycle.\n-So the two endpoints of e cannot be in the same subtree.\u2028That is, e connects two di\ufb00erent subtrees, say T1 and T2 \n-So e is an outgoing edges of T1. Further, the algorithm has not processed any outgoing edges of T1 when we add e.\n-Choosing S = T1 su\ufb03ces because by our choice of e, \u2028it must have the minimum edge weight among them. 23\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s AlgorithmFact 2.  Each edge in the MST will be added by the algorithm. Proof:  Consider an edge e in the MST.\n-Since the algorithm checks all edges before it stops, it must have checked edge e.\n-Since the only edges added by the algorithm are those in the MST, e cannot create a cycle.", "mimetype": "text/plain", "start_char_idx": 6322, "end_char_idx": 7746, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5bf06c3a-a7ab-473d-9240-2869a15683e4": {"__data__": {"id_": "5bf06c3a-a7ab-473d-9240-2869a15683e4", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "03a8645c-1bd3-4632-ac9f-4434b4085650", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "f8ceb09fa5eccf2fe2430d0aca1c1b9805dde37ef846a419b277831b28df35cd", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c175c9d7-39bd-4026-be64-f5d0df600644", "node_type": "1", "metadata": {}, "hash": "4c967855b6a8d563ff49e8bbb73db8765ac60f28b88661cc5b344ae9946f204d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "23\nZhiyi HuangCOMP3251Correctness of Kruskal\u2019s AlgorithmFact 2.  Each edge in the MST will be added by the algorithm. Proof:  Consider an edge e in the MST.\n-Since the algorithm checks all edges before it stops, it must have checked edge e.\n-Since the only edges added by the algorithm are those in the MST, e cannot create a cycle.\n-So the algorithm would have added edge e to the solution.\n24\n\u2028Implementing Kruskal\u2019s Algorithm \u2028(A Data Structure for Disjoint Sets)\nZhiyi HuangCOMP3251Implementing Kruskal\u2019s Algorithm\u2022Note that log |E| = O(log |V|) because |E| = O(|V|2).\n\u2022Sorting the edges in ascending order takes O(|E| log |E|) = \u2028O(|E| log |V|) time.\n\u2022The for loop has |E| iterations.\n\u2022Key questions:  \n-How to implement an iteration of the for loop? \n-How to determine if adding an edge creates a cycle?261)Start from an empty forest T. \n2)for all edges e in ascending order of weights :\n3)    insert edge e in T unless doing so would create a cycle.\nZhiyi HuangCOMP3251Observation:  During the execution of the algorithm, the set of edges added to the solution (red edges) forms a set of disjoint sub-trees of the MST.\n-To determine if adding an edge creates a cycle is the same as to determine if its end points are in the same sub-tree.Implementing Kruskal\u2019s Algorithm\n27cgdfebhaiIn this step, there are 4 disjoint sub-trees.\nZhiyi HuangCOMP3251Observation:  During the execution of the algorithm, the set of edges added to the solution (red edges) forms a set of disjoint sub-trees of the MST.\n-To determine if adding an edge creates a cycle is the same as to determine if its end points are in the same sub-tree.\nImplementing Kruskal\u2019s Algorithm\n27cgdfebhaiIn this step, there are 4 disjoint sub-trees.", "mimetype": "text/plain", "start_char_idx": 7414, "end_char_idx": 9127, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c175c9d7-39bd-4026-be64-f5d0df600644": {"__data__": {"id_": "c175c9d7-39bd-4026-be64-f5d0df600644", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5bf06c3a-a7ab-473d-9240-2869a15683e4", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "2d4c3b5197984122241ccf1d32a4a4d8cf7d69be8c54e26d563c3b4fcb0c6ff4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9fadeb1c-2cd8-4032-92cd-920248b9963c", "node_type": "1", "metadata": {}, "hash": "9b848d5711132082ca24605579514cef36b829c03b3f1aee84e74ebe84d0d52a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Observation:  During the execution of the algorithm, the set of edges added to the solution (red edges) forms a set of disjoint sub-trees of the MST.\n-To determine if adding an edge creates a cycle is the same as to determine if its end points are in the same sub-tree.\nImplementing Kruskal\u2019s Algorithm\n27cgdfebhaiIn this step, there are 4 disjoint sub-trees.\nZhiyi HuangCOMP3251Observation:  During the execution of the algorithm, the set of edges added to the solution (red edges) forms a set of disjoint sub-trees of the MST.\n-To determine if adding an edge creates a cycle is the same as to determine if its end points are in the same sub-tree.\nImplementing Kruskal\u2019s Algorithm\n27cgdfebhaiIn this step, there are 4 disjoint sub-trees.\nZhiyi HuangCOMP3251Observation:  During the execution of the algorithm, the set of edges added to the solution (red edges) forms a set of disjoint sub-trees of the MST.\n-To determine if adding an edge creates a cycle is the same as to determine if its end points are in the same sub-tree.\nImplementing Kruskal\u2019s Algorithm\n27cgdfebhaiIn this step, there are 4 disjoint sub-trees.\nZhiyi HuangCOMP3251Observation:  During the execution of the algorithm, the set of edges added to the solution (red edges) forms a set of disjoint sub-trees of the MST.\n-To determine if adding an edge creates a cycle is the same as to determine if its end points are in the same sub-tree.\nImplementing Kruskal\u2019s Algorithm\n27cgdfebhaiIn this step, there are 4 disjoint sub-trees.\nZhiyi HuangCOMP3251Idea:  Design a data structure that remembers the current set of disjoint sub-trees such that we can e\ufb03ciently\n1)\ufb01nd the subtree that a vertex, say, c, belongs to, through a procedure \ufb01nd-set(c); and\n2)merge two subtrees through union(\ufb01nd-set(c), \ufb01nd-set(d)).", "mimetype": "text/plain", "start_char_idx": 8749, "end_char_idx": 10543, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9fadeb1c-2cd8-4032-92cd-920248b9963c": {"__data__": {"id_": "9fadeb1c-2cd8-4032-92cd-920248b9963c", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c175c9d7-39bd-4026-be64-f5d0df600644", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "59438939ac0a0fc639fa4e84b788053062f016ab64d3b0c8015acf37fa8337eb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bd41bf3c-92fe-486b-805b-8ad55c07c0b0", "node_type": "1", "metadata": {}, "hash": "c677a6d4ad2752091e185f6ce9723b9b11489ea4b407d6534670b0c073dcd8a3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Zhiyi HuangCOMP3251Idea:  Design a data structure that remembers the current set of disjoint sub-trees such that we can e\ufb03ciently\n1)\ufb01nd the subtree that a vertex, say, c, belongs to, through a procedure \ufb01nd-set(c); and\n2)merge two subtrees through union(\ufb01nd-set(c), \ufb01nd-set(d)).\nImplementing Kruskal\u2019s Algorithm\n28cgdfebhai\nZhiyi HuangCOMP3251Implementing Kruskal\u2019s Algorithm\nRunning Time: \u2022# of make-set: |V|;  # of \ufb01nd-set: 2|E|;  # of union: |V|-1.\n\u2022Suppose the data structure implements these subroutine in O(log |V|) time, then the total running time is O(|E| log |V|).291)initialize T = { }. \n2)for all vertices v : initialize a sub-tree for v via make-set(v).\n3)for all edges (u, v) in ascending order of weights :\n4)    if \ufb01nd-set(u) \u2260 \ufb01nd-set(v) :\n5)        add (u, v) to T;\n6)        union(\ufb01nd-set(u), \ufb01nd-set(v)).\nZhiyi HuangCOMP3251A Data Structure of Disjoint SetsWe need to maintain a collection of sets from n elements (vertices). Our data structure must support the followings:\n-Given any two elements x, y, we need to determine whether\u2028\ufb01nd-set(x) = \ufb01nd-set(y), i.e., to determine whether x and y belongs to the same set.\n-Given any two sets in the current collection, we need to replace these two sets by its union.\n30\nZhiyi HuangCOMP3251High-Level ApproachIdea:  Maintain a tree for the vertices in each set and name each set after the root vertex.\n-For \ufb01nd-set(x), we just trace back to the root.\n-To union two sets, we append the root of one set to be a child of the root of the other set.", "mimetype": "text/plain", "start_char_idx": 10265, "end_char_idx": 11774, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bd41bf3c-92fe-486b-805b-8ad55c07c0b0": {"__data__": {"id_": "bd41bf3c-92fe-486b-805b-8ad55c07c0b0", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9fadeb1c-2cd8-4032-92cd-920248b9963c", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "396f296c4dfec3aaf9a03cdd6b4cbf4ce4725532a7887f2c64365916302a4b3c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f65a3ad9-149c-49a6-87a6-afdf5f457f30", "node_type": "1", "metadata": {}, "hash": "4db915876dee1379b725e8eb0b2dfecf7e53a591b509dd192d31b13f55e4d074", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Given any two sets in the current collection, we need to replace these two sets by its union.\n30\nZhiyi HuangCOMP3251High-Level ApproachIdea:  Maintain a tree for the vertices in each set and name each set after the root vertex.\n-For \ufb01nd-set(x), we just trace back to the root.\n-To union two sets, we append the root of one set to be a child of the root of the other set.\n31\nZhiyi HuangCOMP3251Sample Run\n32abcdefg{a} {b} {c} {d} {e} {f} {g}union( \ufb01nd(a), \ufb01nd(e) )\nZhiyi HuangCOMP3251Sample Run\n32abcdefg{a} {b} {c} {d} {e} {f} {g}union( \ufb01nd(a), \ufb01nd(e) )abcdefg\nZhiyi HuangCOMP3251Sample Run\n33abcdfgunion( \ufb01nd(d), \ufb01nd(g) )e{a, e} {b} {c} {d} {f} {g}\nZhiyi HuangCOMP3251Sample Run\n33abcdfgunion( \ufb01nd(d), \ufb01nd(g) )e{a, e} {b} {c} {d} {f} {g}\nabcdefg\nZhiyi HuangCOMP3251Sample Run\n34abcdfunion( \ufb01nd(e), \ufb01nd(g) )eg{a, e} {b} {c} {d, g} {f}\nZhiyi HuangCOMP3251Sample Run\n34abcdfunion( \ufb01nd(e), \ufb01nd(g) )eg{a, e} {b} {c} {d, g} {f}\nabcdefg\nZhiyi HuangCOMP3251\u2022To execute \ufb01nd-set(x), we traverse the parent pointers from x up to the root, and the root is used as the name of the set.", "mimetype": "text/plain", "start_char_idx": 11403, "end_char_idx": 12477, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f65a3ad9-149c-49a6-87a6-afdf5f457f30": {"__data__": {"id_": "f65a3ad9-149c-49a6-87a6-afdf5f457f30", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bd41bf3c-92fe-486b-805b-8ad55c07c0b0", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "80cd8e2fdfeca7fa7fa6ecc91e7010dc52f4713bd56e7f8986700f3d719f7234", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fcb627f0-507c-4f6a-a239-cc5cece49878", "node_type": "1", "metadata": {}, "hash": "be2847fe309108673e909421724a5551b4f140f6c6e83fe6bfc7d4e8907d1acf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022So, \ufb01nd-set(x) = \ufb01nd-set(y) if and only if the root returned by \ufb01nd-set(x) is equal to that returned by \ufb01nd-set(y).\n\u2022To execute union(r1, r2), we make a root to be the child of the other root.Summary\n35r1r2r1r2\nQuestion:  Which vertex shall be the new root?\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdef\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))union(\ufb01nd-set(d), \ufb01nd-set(e))\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).", "mimetype": "text/plain", "start_char_idx": 12478, "end_char_idx": 14045, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fcb627f0-507c-4f6a-a239-cc5cece49878": {"__data__": {"id_": "fcb627f0-507c-4f6a-a239-cc5cece49878", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f65a3ad9-149c-49a6-87a6-afdf5f457f30", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "a7b45a38abe451356d518b5456d3c650e43227b9d95505d739a2e4f4b208fa85", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "87d70abd-3c01-4749-b1ae-93729ddd947a", "node_type": "1", "metadata": {}, "hash": "d229c97bcafb90c34efc4f7576a351ab652462ae3a5aafc6d3445912ff4e7075", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))union(\ufb01nd-set(d), \ufb01nd-set(e))\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))union(\ufb01nd-set(d), \ufb01nd-set(e))union(\ufb01nd-set(c), \ufb01nd-set(d))\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))union(\ufb01nd-set(d), \ufb01nd-set(e))union(\ufb01nd-set(c), \ufb01nd-set(d))union(\ufb01nd-set(b), \ufb01nd-set(c))\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).", "mimetype": "text/plain", "start_char_idx": 13747, "end_char_idx": 14997, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "87d70abd-3c01-4749-b1ae-93729ddd947a": {"__data__": {"id_": "87d70abd-3c01-4749-b1ae-93729ddd947a", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fcb627f0-507c-4f6a-a239-cc5cece49878", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "4c57d67adf66be787f158184dacc69afd403b4df03913ac3b123944dcfa3fe07", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25241697-315f-48f4-8ef7-974f2abd50e3", "node_type": "1", "metadata": {}, "hash": "7b1e79625b35f170c25ee46b13c99d36cb6536218154ceb64b45d0bb2fb152cd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))union(\ufb01nd-set(d), \ufb01nd-set(e))union(\ufb01nd-set(c), \ufb01nd-set(d))union(\ufb01nd-set(b), \ufb01nd-set(c))union(\ufb01nd-set(a), \ufb01nd-set(b))\nZhiyi HuangCOMP3251Running Time AnalysisTo answer the question, we need to \ufb01rst understand how the running time of \ufb01nd-set and union depends on the structure of the trees that we maintain.\n-Running time for a union operation: O(1).\n-Running time for a \ufb01nd-set(x): \u2028the height of the tree containing x, which can be O(n).\n36abcdefunion(\ufb01nd-set(e), \ufb01nd-set(f))union(\ufb01nd-set(d), \ufb01nd-set(e))union(\ufb01nd-set(c), \ufb01nd-set(d))union(\ufb01nd-set(b), \ufb01nd-set(c))union(\ufb01nd-set(a), \ufb01nd-set(b))\nThen, \ufb01nd-set(f) \u2028takes n-1 steps.\nZhiyi HuangCOMP3251Can we guarantee small height?\u2022If we could implement union such that the trees have small height, then \ufb01nd-set would have small running time.\n\u2022How? One way to do it is the union-by-size heuristic:\n-To union(s1, s2), we make the tree with smaller size the child of the one with larger size.\n-Break ties arbitrarily.\n-Example:\n37r123 \u2028nodesr25 \u2028nodesr123 \u2028nodesr25 \u2028nodes\u2714\u2718\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)),", "mimetype": "text/plain", "start_char_idx": 14866, "end_char_idx": 16196, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "25241697-315f-48f4-8ef7-974f2abd50e3": {"__data__": {"id_": "25241697-315f-48f4-8ef7-974f2abd50e3", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "87d70abd-3c01-4749-b1ae-93729ddd947a", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "8ec622ab5d3447a00b868782582bc4512d85655eb86b5229483a2b65b0a404b1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f9545f6b-fade-42f7-a843-82e04cbcbe68", "node_type": "1", "metadata": {}, "hash": "bd8e1680f8af1e3e12a35e834085e63250718ddaed21d6fa9e550892442c6a47", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-Break ties arbitrarily.\n-Example:\n37r123 \u2028nodesr25 \u2028nodesr123 \u2028nodesr25 \u2028nodes\u2714\u2718\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n38abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n39abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n40abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n41abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)),", "mimetype": "text/plain", "start_char_idx": 15971, "end_char_idx": 17083, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f9545f6b-fade-42f7-a843-82e04cbcbe68": {"__data__": {"id_": "f9545f6b-fade-42f7-a843-82e04cbcbe68", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25241697-315f-48f4-8ef7-974f2abd50e3", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "9283eacdd50a90d68adc95978e349eaa63e582241d2053abc3800688b1e267fb", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4ef0ab90-5a91-48ff-91bf-72a3e6f1ca9f", "node_type": "1", "metadata": {}, "hash": "5ae65b681f62937707f4047d865758af5a253bffb5ffc590615975a4a7e7f83b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n41abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n42abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n43abcdef\nZhiyi HuangCOMP3251Revisiting the O(n)-Time Exampleunion(\ufb01nd-set(e), \ufb01nd-set(f)), union(\ufb01nd-set(d), \ufb01nd-set(e)), union(\ufb01nd-set(c), \ufb01nd-set(d)), union(\ufb01nd-set(b), \ufb01nd-set(c)), union(\ufb01nd-set(a), \ufb01nd-set(b))\n43abcdef\nThe union-by-size heuristic \u2028gives a tree with height 1!\nZhiyi HuangCOMP3251Analyzing the Union-By-Size Heuristic Claim.  If we use union-by-size, then any tree with height h must have at least 2h nodes.\nProof (by induction). Base case: h = 0 is true as any tree has at least 1 node.\nInductive hypothesis:  The claim is true for trees with height h.\nInductive step:  We will show it is true for trees with height h+1.\n-Key observation:  We get a tree with height h+1 only when we union two trees and one of them has hight h.", "mimetype": "text/plain", "start_char_idx": 16857, "end_char_idx": 18075, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4ef0ab90-5a91-48ff-91bf-72a3e6f1ca9f": {"__data__": {"id_": "4ef0ab90-5a91-48ff-91bf-72a3e6f1ca9f", "embedding": null, "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6173c44e-5815-41db-b385-fe5d507dc819", "node_type": "4", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "e6ad27cfacc15517f2a5088485a7497c73b495b009df9f93c43f3dd0c5a058a6", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f9545f6b-fade-42f7-a843-82e04cbcbe68", "node_type": "1", "metadata": {"file_name": "S12 Kruskals Algorithm_processed.txt", "source_file": "S12 Kruskals Algorithm", "file_path": "uploads\\rag_upload_20250731_214004\\processed_texts\\S12 Kruskals Algorithm_processed.txt"}, "hash": "a9a011e26f027e4d26bfbdeaba96325d8d8dec334d30a22fe64cb314618fef64", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Proof (by induction). Base case: h = 0 is true as any tree has at least 1 node.\nInductive hypothesis:  The claim is true for trees with height h.\nInductive step:  We will show it is true for trees with height h+1.\n-Key observation:  We get a tree with height h+1 only when we union two trees and one of them has hight h.\n44r1\u2265 2h \u2028nodesr2\u2265 2h \u2028nodesheight htotal height h+1 \u2265 2h+1 nodesbecause it is \nthe larger tree\nZhiyi HuangCOMP3251Analyzing the Union-By-Size Heuristic Claim.  If we use union-by-size, then any tree with height h must have at least 2h nodes.\nCorollary.  If we use union-by-size, then any tree must have height h \u2264 log n.\nProof. -Since there are only n nodes, the size of any tree is \u2264 n.  \n-Together with the above claim, we have n \u2265 tree size \u2265 2h.\n-Equivalently, we have log n \u2265 log(tree size) \u2265 h.\n45\nZhiyi HuangCOMP3251Summary\u2022If we implement the Disjoint Sets data structure using the union-by-size heuristic, then \n-\ufb01nd-set runs in time O(log n);\n-union runs in time O(1).\n\u2022Substitute these bounds in our analysis of the running time, we conclude that Kruskal's algorithm runs in O(m log n) time.\n46", "mimetype": "text/plain", "start_char_idx": 17755, "end_char_idx": 18882, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}}